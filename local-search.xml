<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TI AM243x-LP USB驱动开发记录</title>
    <link href="/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="TI-AM243x-LP-USB驱动开发记录"><a href="#TI-AM243x-LP-USB驱动开发记录" class="headerlink" title="TI AM243x-LP USB驱动开发记录"></a>TI AM243x-LP USB驱动开发记录</h1><p>不得不承认之前被ST的软件生态养的太好了，第一次用TI的Soc开发板，踩了很多坑，但是狠狠恶补了一波多核和Soc的知识点，不亏。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>TI官网上给开发者提供的相关资料有</p><ul><li>AM243x芯片手册</li><li>AM243x-LP开发板硬件手册</li><li>SDK（最新版本SDK分为mcu+sdk，motor control sdk，industrial sdk三种）</li><li>SDK使用手册</li></ul><p>SDK使用手册直接用浏览器打开然后用浏览器的翻译功能就行,芯片手册和开发板硬件手册只有英文版pdf，所以我用了Zotero+pdf2zh插件进行翻译（这个是github开源的pdf翻译方案，而且有双语对照功能，还是挺好用的）</p><p>我想把翻译好的芯片手册和开发板硬件手册的链接放在下面，但是发现github传不了100Mb以上的文件，等我有空研究一下</p><h2 id="踩坑过程"><a href="#踩坑过程" class="headerlink" title="踩坑过程"></a>踩坑过程</h2><h4 id="BOOT过程"><a href="#BOOT过程" class="headerlink" title="BOOT过程"></a>BOOT过程</h4><p>因为网上关于TI开发板的视频资料较少，所以基本上是直接根据SDK使用手册一步一步做的，这就导致了一旦使用手册里有写的不明确的地方，就要在这些地方卡一段时间去试错。</p><p>我遇到的第一个问题是芯片如何正确启动并初始化。就像其他的高级Soc一样，TI为AM2434的启动设置了多阶段引导加载程序，也就是多级bootloader。</p><img src="/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/0f634769-308d-424b-a8dc-9764f103067d.png" class=""><p>首先是第一级bootloader，出于安全考虑，TI在芯片出厂前将其保存在安全的只读内存ROM中，称为ROM引导加载程序（RBL）。RBL程序负责引导进入下一级bootloader，而不需要知道芯片的其他内核。</p><p>然后是第二级bootloader，主要负责处理不同内核上的复杂引导加载，称为SBL（second bootloader）。加载多核应用程序比加载单核应用程序要复杂很多，要考虑映像准备和共享内存访问等问题。好在TI提供了相关的makefile文件<code>makefile_ccs_bootimage_gen</code>，方便用户自定义编译出需要的SBL文件。</p><p>在了解完这些前置知识点后，我就老老实实一步一步跟着SDK使用手册的步骤。</p><p>对于AM243X-LP开发板来说，TI提供了多种启动方法（通过UART,SD卡或CCS脚本）需要注意的是这里的启动只需要我们将TI提供的SBL想办法放到芯片的二级启动地址下，对应使用手册中的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;SDK_INSTALL_PATH&#125;</span>/tools/boot<br> python uart_uniflash.py -p COM&lt;x&gt; --cfg=sbl_prebuilt/am243x-lp/default_sbl_null.cfg<br></code></pre></td></tr></table></figure><p>然而我在执行这一步时就卡住了，问题现象时是正常执行第一条命令，在执行第二条命令时会卡住并应执行超时而失败，失败原因是XMODEM协议校验不通过</p><img src="/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/f55d9c0c2143326082f46bf8f2b85083.jpg" class=""><p>于是我尝试了其他的启动方案比如用CCS脚本，甚至为此去下载了TI官方的烧录工具uniflash，最后也没能成功。没办法，只能去TI的论坛下面求助，那天刚好是星期五，周末TI不上班，最后星期二才回我</p><img src="/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/da0a6b92-1163-467f-af45-1a8772a4f39f.png" class=""><p>这个时候我才知道原来TI的这款芯片还分了三种安全等级，分别对应</p><ul><li>GG 非安全   适用固件后缀为无后缀</li><li>HS 高安全   适用固件后缀为_hs</li><li>FS 现场安全   适用固件后缀为_fs</li></ul><p>除了看芯片丝印信息这一方法来得知安全等级信息，在逛TI论坛时我还发现了一个方法来看自己的芯片是GP还是HS_FS，这里就不多介绍了，放个链接[<a href="https://e2echina.ti.com/support/machine-translation/mt-processors/f/mt-processors-forum/1010320/faq-tda4vm-gp-fs?tisearch=e2e-sitesearch&keymatch=GP#">FAQ] [参考译文] [常见问题解答] TDA4VM：如何检查器件类型(GP FS)？ - 处理器（参考译文帖）(Read Only) - 处理器（参考译文帖） - E2E™ 设计支持</a></p><p>但其实从22年9月后TI就逐渐取消了对GP型号的生产和支持，SDK在9.0版本后就完全不支持GP型号了，所以基本上现在市面上买到的器件都是HS_FS型号的，所以不用担心这个问题，直接用最新版的SDK就行。</p><p>而我的芯片由于是GP型号的，只能去官网上下载了08030018版本的SDK和1.12.1版本的sysconfig工具，并导入到CCS的product中。如果是HS_FS型号的开发板，版本下载官网最新的就行。</p><p>在经历了这些后，我终于在老版本的SDK上找到了后缀不带.hs_fs的SBL文件并成功复现了SDK使用手册中的步骤。这个时候就可以将LP启动模式切换到OSPI模式了，然后跟着使用手册的步骤应该没有什么坑了，遇到问题就问AI，大概率能解决。执行完OSPI boot之后，就可以直接用CCS直接烧录和调试程序了，不需要每次切换回UART boot模式。</p><blockquote><blockquote><p>在终端执行命令行时尽量用相对路径而不用绝对路径，这样能有效避免应命令引用路径过长导致的问题</p></blockquote><blockquote><p>如果是HS_FS型号的开发板，要装OpenSSL，当编译好一个程序镜像后，TI 的构建流程会调用 OpenSSL 来生成一个数字签名（就像给软件盖一个加密的印章）。芯片上的 ROM 引导程序或二级引导程序在加载应用前，会使用预先烧录在芯片中的公钥来验证这个签名。如果验证失败，说明软件可能被篡改，芯片将拒绝执行，从而防止恶意代码运行</p></blockquote></blockquote><h4 id="示例代码的调试与运行"><a href="#示例代码的调试与运行" class="headerlink" title="示例代码的调试与运行"></a>示例代码的调试与运行</h4><p>示例代码的使用在使用手册中的开发者指南有详细的教学，包括怎么导入，编译和烧录。</p><p>主要讲一下烧录，只需将tool文件夹复制到工作区，然后修改default_sbl_ospi.cfg文件，将第四个命令的file对象改为自己编译出来的.appimage文件，第五行命令是执行XIP image文件的，直接注释就行</p><img src="/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/4ac3ee73-0cc1-41e3-80f7-7b88a189df08.png" class=""><blockquote><p><strong>XIP Image</strong> 的全称是 <strong>eXecute-In-Place Image</strong>，中文可译为 <strong>“就地执行映像”</strong> 或 <strong>“直接执行映像”</strong>。</p><p>它是一种<strong>存储在非易失性存储器（如 Flash）中，且能够被 CPU 直接从中读取并执行的程序二进制文件</strong>，而无需将其先复制到 RAM（内存）中，这个是由链接脚本决定的。</p><p>用于快速启动，节省RAM空间，但是执行速度较慢，写入困难</p></blockquote><p>在debug的时候能注意到左边的线程中有很多内核对象，我查了一下它们的命名规则</p><img src="/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/f6cd1f99-f18d-4784-a251-4ff17ddb3ddd.png" class=""><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 1c">MAIN_Cortex_R5_0_0  <span class="hljs-comment">// 集群0，核心0</span><br>MAIN_Cortex_R5_0_1  <span class="hljs-comment">// 集群0，核心1  </span><br>MAIN_Cortex_R5_1_0  <span class="hljs-comment">// 集群1，核心0</span><br>MAIN_Cortex_R5_1_1  <span class="hljs-comment">// 集群1，核心1</span><br>DMSC_Cortex_M3_0    <span class="hljs-comment">// 设备管理安全控制器</span><br>ICSS_G0_PRU_0       <span class="hljs-comment">// 可编程实时单元0</span><br>ICSS_G0_RTU_PRU_0   <span class="hljs-comment">// 实时单元PRU0</span><br>ICSS_G0_TX_PRU_0    <span class="hljs-comment">// 发送PRU0</span><br>ICSS_G0_PRU_1       <span class="hljs-comment">// 可编程实时单元1</span><br>BLAZAR_Cortex_M4F_0 <span class="hljs-comment">// 通用处理核心</span><br></code></pre></td></tr></table></figure><p>最后放一下执行USB CDC示例代码后的运行效果</p><img src="/2025/10/31/TI%20AM243x-LP%20USB%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/d4798e5b0d2a2a31b548aa669d8c6a5a.png" class=""><h4 id="将示例代码从R5F内核移植到M4F内核上"><a href="#将示例代码从R5F内核移植到M4F内核上" class="headerlink" title="将示例代码从R5F内核移植到M4F内核上"></a>将示例代码从R5F内核移植到M4F内核上</h4><p>（持续更新中）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Soc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>典中典之最容易被遗忘的ADC原理</title>
    <link href="/2025/10/23/%E5%85%B8%E4%B8%AD%E5%85%B8%E4%B9%8B%E6%9C%80%E5%AE%B9%E6%98%93%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84ADC%E5%8E%9F%E7%90%86/"/>
    <url>/2025/10/23/%E5%85%B8%E4%B8%AD%E5%85%B8%E4%B9%8B%E6%9C%80%E5%AE%B9%E6%98%93%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84ADC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="典中典之最容易被遗忘的ADC原理"><a href="#典中典之最容易被遗忘的ADC原理" class="headerlink" title="典中典之最容易被遗忘的ADC原理"></a>典中典之最容易被遗忘的ADC原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前打RM的时候很少用到ADC，因为赛场上ADC没有什么复杂的应用场景，导致我之前对ADC的理解一直停留在了一个很浅的层面。最近实习有个需求需要用到单路ADC多通道采集的功能，就趁此机会好好研究了一下MCU中的ADC，以及尝试一下找出不同应用场景下使用ADC的最优解。</p><h2 id="ADC原理"><a href="#ADC原理" class="headerlink" title="ADC原理"></a>ADC原理</h2><p>在我心目中，ADC应该是最经典的生产者之一，所以要想实现整条生产-消费链路的高效化，生产时间无疑是其中非常重要的一环。这就要求我们得了解ADC是如何从模拟信号输入到数字信号输出的整个流程。</p><h5 id="1-扛混叠滤波"><a href="#1-扛混叠滤波" class="headerlink" title="1.扛混叠滤波"></a>1.扛混叠滤波</h5><p>这个其实是在MCU外部进行处理的，由模拟电路物理上滤除模拟信号中高于奈奎斯特频率的高频成分，通常是一个简单的RC低通滤波器。</p><p>由于这个不是影响ADC生产时间的重要因素，作为软件开发，了解一下即可。</p><h5 id="2-采样与保持"><a href="#2-采样与保持" class="headerlink" title="2.采样与保持"></a>2.采样与保持</h5><ul><li><strong>采样</strong>：按固定的时间间隔，快速“抓取”模拟信号的瞬时值。这好比在生产线上，以极高的速度对连续流动的原料进行瞬时拍照，记录下某一刻的状态。</li><li><strong>保持</strong>：采样结束后，需要立即将这个瞬时电压值“冻结”住，并保持一段时间。这就为后续的精细加工（量化和编码）提供了稳定的工作条件。通常由采样保持电路实现，其核心是一个电容，采样时充电以记录电压，保持阶段则维持该电压。</li></ul><p>根据奈奎斯特采样定理，采样频率必须至少是输入信号最高频率分量的两倍，才能无失真地还原原始信号。在实际应用中，为了更好保留细节，通常会选择信号最高频率的5到10倍甚至更高作为采样频率。</p><h5 id="3-量化与编码"><a href="#3-量化与编码" class="headerlink" title="3.量化与编码"></a>3.量化与编码</h5><p>这里直接把量化和编码过程合称为转换过程。ADC的分辨率（位数，n）越高，量化等级（2^n）就越多，每个等级所代表的电压范围（LSB，最低有效位）就越小，量化误差也就越小，测量结果越精确。</p><p>转换过程花费的时间主要取决于ADC的架构，逐次逼近型ADC转化时间固定为N个时钟周期，Σ-Δ型ADC转换时间则较长，这个马上就详细讲讲。</p><h2 id="主流的ADC架构"><a href="#主流的ADC架构" class="headerlink" title="主流的ADC架构"></a>主流的ADC架构</h2><p>目前直到我写这篇博客的时候，STM32除了L0和L1没有使用SAR ADC，其他系列都是SAR ADC，所以主要只需了解逐次逼近型ADC的架构就行。</p><h5 id="1-逐次逼近型ADC（SAR-ADC）"><a href="#1-逐次逼近型ADC（SAR-ADC）" class="headerlink" title="1. 逐次逼近型ADC（SAR ADC）"></a>1. 逐次逼近型ADC（SAR ADC）</h5><ul><li><strong>工作原理</strong>：采用一种“二分搜索”或“天平称重”的策略。从最高位（MSB）开始，逐位试探性地置1，并通过内部的数模转换器（DAC）产生对应的模拟电压，与输入电压进行比较。根据比较结果决定该位最终是1还是0，直至最低位（LSB）。</li><li><strong>特点</strong>：在速度、精度和功耗之间取得了很好的平衡。<strong>转换时间是固定的，需要N个时钟周期完成N位转换。</strong></li><li><strong>应用</strong>：非常广泛，常见于微控制器的内置ADC中，适用于中速数据采集系统、传感器接口、工业控制等。</li></ul><h5 id="2-Σ-Δ型ADC"><a href="#2-Σ-Δ型ADC" class="headerlink" title="2. Σ-Δ型ADC"></a>2. Σ-Δ型ADC</h5><ul><li><strong>工作原理</strong>：采用“过采样”和“噪声整形”技术。它以远高于奈奎斯特频率的速率对信号进行采样（过采样），并将量化噪声“驱赶”到高频区域，然后通过数字滤波器滤除这些高频噪声，从而在有效信号带宽内获得极高的信噪比和分辨率。</li><li><strong>特点</strong>：能够实现极高的分辨率（可达16-24位甚至更高），但转换速度通常较慢。</li><li><strong>应用</strong>：高精度测量领域，如音频采集与处理、高精度传感器（电子秤、压力传感器）信号调理、地震监测仪器等。</li></ul><h5 id="3-流水线型ADC"><a href="#3-流水线型ADC" class="headerlink" title="3. 流水线型ADC"></a>3. 流水线型ADC</h5><ul><li><strong>工作原理</strong>：将整个转换任务分解为多个阶段（级），每一级同时处理前一次采样留下的“残差”，并将自己的结果传递给下一级。这种流水线作业方式使得它能够并行处理多个采样数据，从而实现很高的吞吐率。</li><li><strong>特点</strong>：兼具高速度和中高分辨率。但电路复杂，通常会有较大的初始延迟（延迟）。</li><li><strong>应用</strong>：通信系统（如基站）、数字视频处理、医疗成像（如超声设备）、高速数据采集卡等需要高速处理的场景。</li></ul><h5 id="4-闪存型ADC"><a href="#4-闪存型ADC" class="headerlink" title="4. 闪存型ADC"></a>4. 闪存型ADC</h5><ul><li><strong>工作原理</strong>：采用“并行处理”策略，使用大量的比较器（2^N - 1个）同时将输入电压与一系列参考电压进行比较，并通过一个优先级编码器直接输出对应的数字码。</li><li><strong>特点</strong>：<strong>速度极快</strong>，是转换速度最快的ADC架构，但功耗和芯片面积随分辨率指数级增长，因此分辨率通常较低（一般不超过8位）。</li><li><strong>应用</strong>：超高速信号处理领域，如雷达信号接收、高速示波器、光纤通信等。</li></ul><h2 id="回归实践使用"><a href="#回归实践使用" class="headerlink" title="回归实践使用"></a>回归实践使用</h2><p>上面说了这么多，其实需要关注的只有采样时间和转换时间。转换时间跟分辨率，也就是ADC的位数有关，12位ADC对应的总时间就是<br>$$<br>ADC生产时间&#x3D;采样时间+保持时间+转换时间&#x3D;采样时间+0.5周期的采样保持+12周期的逐次逼近比较&#x3D;采样时间+12.5ADC时钟周期<br>$$<br>采样时间，其实就是ADC内部采样保持电容对输入电压进行充电的时间。采样时间越长，电容充电越充分，测量结果越精确，但相应的转换速度会变慢。</p><table><thead><tr><th>考虑因素</th><th>采样时间</th><th>理由</th></tr></thead><tbody><tr><td>信号源高阻抗</td><td>55周期及以上</td><td>信号源驱动能力弱，需要更长的充电时间</td></tr><tr><td>要求高精度</td><td>55周期及以上</td><td>更长的充电时间能确保电容电压稳定后才采样</td></tr><tr><td>要求高采样率</td><td>1.5，7.5，13.5周期</td><td>这个不用多说</td></tr><tr><td>输入信号频率高</td><td>1.5，7.5周期</td><td>为了满足奈奎斯特采样定理，需要更快的ADC整体速度</td></tr></tbody></table><p>以我现在的工程举例，根据STM32G0x1用户手册，ADCCLK最大16Mhz，对应一个时钟周期为0.0625us，使用了ADC1的5个通道并且这5个通道采样周期都配置为7.5个时钟周期，用了扫描模式+连续转换模式+DMA循环+一轮扫描后转换的配置，则<br>$$<br>ADC生产时间&#x3D;（12.5+7.5*5）*0.0625us&#x3D;3.125us<br>$$<br>也就是说ADC外设在开启DMA的情况下只需3.125us。</p><p>知道这个之后玩法就有很多了，比如可以配置DMA缓冲区为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint16</span>_t adcBuffer[通道数*N];  <span class="hljs-comment">//采集N组数据而非1组用于滤波算法</span><br></code></pre></td></tr></table></figure><p>这样也能有效地防止一个问题，ADC生产速度过快导致就算开启了DMA，CPU还是一直被ADC转换完成中断抢占的情况。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被CANFD问题硬控一整天后有感</title>
    <link href="/2025/10/18/%E8%A2%ABCANFD%E9%97%AE%E9%A2%98%E7%A1%AC%E6%8E%A7%E4%B8%80%E6%95%B4%E5%A4%A9%E5%90%8E%E6%9C%89%E6%84%9F/"/>
    <url>/2025/10/18/%E8%A2%ABCANFD%E9%97%AE%E9%A2%98%E7%A1%AC%E6%8E%A7%E4%B8%80%E6%95%B4%E5%A4%A9%E5%90%8E%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="被CANFD问题硬控一整天后有感"><a href="#被CANFD问题硬控一整天后有感" class="headerlink" title="被CANFD问题硬控一整天后有感"></a>被CANFD问题硬控一整天后有感</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近拿到一个CANFD示教按键的需求，需要实现检测按键长按3s后通过CAN总线发一个报文的功能。本来以为这是一个简单的任务，没想到最后被CANFD数据段高波特率下的数据传输问题硬控了一整天。还好最后解决了,不然晚上真的睡不好觉。</p><h2 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h2><p>总体思路还是对按键检测和CAN收发两个功能实现模块化封装，方便之后可能的移植需求</p><h3 id="1-按键检测模块"><a href="#1-按键检测模块" class="headerlink" title="1.按键检测模块"></a>1.按键检测模块</h3><p>这个功能有很多种实现的方法，主要分为GPIO外部中断和定时器中断轮询这两种方法。这里让AI对比了一下两种方案的优劣</p><table><thead><tr><th align="left">特性对比</th><th align="left"><strong>定时器中断轮询</strong></th><th align="left"><strong>GPIO外部中断</strong></th></tr></thead><tbody><tr><td align="left"><strong>核心机制</strong></td><td align="left">定时器周期性触发中断，在中断服务程序（ISR）中<strong>主动扫描</strong>所有按键的状态</td><td align="left">按键电平变化（如按下&#x2F;释放）时<strong>主动触发</strong>中断，CPU再响应</td></tr><tr><td align="left"><strong>CPU占用</strong></td><td align="left"><strong>相对较高</strong>。即使无按键操作，定时器中断仍会周期性发生，占用CPU时间片。</td><td align="left"><strong>极低</strong>。无按键动作时，CPU完全不被干扰，可处理其他任务或进入低功耗模式。</td></tr><tr><td align="left"><strong>响应速度</strong></td><td align="left"><strong>固定延迟</strong>。响应时间取决于扫描周期（如10ms），存在最大为一次扫描周期的延迟。</td><td align="left"><strong>近乎实时</strong>。电平变化瞬间即可触发响应，延迟极短。</td></tr><tr><td align="left"><strong>抗干扰能力</strong></td><td align="left"><strong>较强</strong>。可在软件扫描逻辑中实现稳定的消抖算法，可靠性高。</td><td align="left"><strong>对硬件设计敏感</strong>。易受硬件抖动和噪声影响，需在硬件（RC滤波）或软件（中断内延时判断）层面做消抖。</td></tr><tr><td align="left"><strong>多按键扩展</strong></td><td align="left"><strong>易于扩展</strong>。单个定时器即可扫描多个按键，对硬件引脚无特殊要求。</td><td align="left"><strong>受限于硬件资源</strong>。每个按键需占用一个支持外部中断的GPIO引脚，且某些MCU中多个引脚可能共享一个中断向量，需在ISR内二次判断。</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">多按键系统（如键盘矩阵）、对实时性要求不极端、需要稳定可靠消抖的应用。</td><td align="left">按键数量少、对响应速度和低功耗有极高要求的应用（如电池设备、游戏手柄）。</td></tr></tbody></table><p>考虑到硬件电路中按键对应的输入GPIO不支持外部中断，所以我采用的方案是定时器中断轮询，这个方案的劣势在于定时器会一直触发按键状态机轮询检测，CPU占用过高且无法实现低功耗，不过还好已知后续这个项目的拓展不会特别复杂，所以经过评估后使用这个方案。</p><p>除了考虑检测到按键按下的方案，我们还要考虑按下之后的3s长按检测，这个3s的时间检测可以用另一个定时器计时，也可以用系统时钟计时。我采用的是另一个定时器计时（这里由于项目不复杂，其实还是用系统时钟计时更好）</p><p>有了大致方案思路后就可以开始代码编写了，新建key.c和key.h放到中间层文件夹下，里面主要实现按键状态机的轮询和相关按键状态下的消抖算法。然后第一个定时器中断中只要调用轮询的函数，第二个定时器中断中只要调用CANFD的发送函数，这样就很好地实现了模块的封装和接口的调用。</p><h3 id="2-CANFD收发模块"><a href="#2-CANFD收发模块" class="headerlink" title="2.CANFD收发模块"></a>2.CANFD收发模块</h3><p>要实现的功能主要是CANFD的初始化（包括硬件过滤器和全局过滤器的初始化），CANFD的发送函数，CANFD的接收回调函数这三个。为了方便之后的移植，我将每路CAN封装成实例，在初始化时分别对每路CAN进行初始化，并用指针数组加上CANID偏移指向这路CAN的句柄,这样之后使用CAN时只需要用instance_id来表示使用的是哪路CAN即可</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  初始化MyCAN模块</span><br><span class="hljs-comment">  * @author  xujiawei</span><br><span class="hljs-comment">  * @param  hfdcan: 指向FDCAN_HandleTypeDef结构的指针（指向HAL库的CAN句柄）</span><br><span class="hljs-comment">  * @param  instance_id: 实例标识符，用于指定要操作的多路CAN中的某一实例（0=CAN1, 1=CAN2）</span><br><span class="hljs-comment">  * @retval MyCAN_Status_e 初始化状态</span><br><span class="hljs-comment">  */</span><br>MyCAN_Status_e MyCAN_Init(FDCAN_HandleTypeDef *hfdcan, uint8_t instance_id)<br>&#123;<br>    <span class="hljs-keyword">if</span> (hfdcan == NULL || instance_id &gt;= MYCAN_MAX_INSTANCES) &#123;<br>        return MYCAN_ERROR;<br>    &#125;<br><br>    MyCAN_Handle_t *p_can = &amp;can_handles[instance_id];<br>    <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>phfdcan = hfdcan;<br><br>    <span class="hljs-comment">/* 初始化该实例的接收FIFO */</span><br>    <span class="hljs-function"><span class="hljs-title">memset</span>((void*)p_can-&gt;</span><span class="hljs-function"><span class="hljs-title">rx_fifo</span>, 0, sizeof(p_can-&gt;</span>rx_fifo));<br>    <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>rx_write_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>rx_read_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>rx_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>rx_callback = NULL;<br>    <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>tx_callback = NULL;<br><br>    HAL_FDCAN_C<span class="hljs-function"><span class="hljs-title">onfigTxDelayCompensation</span>(hfdcan, hfdcan-&gt;</span>I<span class="hljs-function"><span class="hljs-title">nit</span>.DataPrescaler * hfdcan-&gt;</span>Init.DataTimeSeg1, <span class="hljs-number">0</span>);<br>    HAL_FDCAN_EnableTxDelayCompensation(hfdcan);<br><br>    <span class="hljs-comment">/* 使能接收FIFO中断 */</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (HAL_FDCAN_ActivateNotification(p_can-&gt;</span>phfdcan, FDCAN_IT_RX_FIFO0_NEW_MESSAGE, <span class="hljs-number">0</span>) != HAL_OK) &#123;<br>        return MYCAN_ERROR;<br>    &#125;<br><br>    <span class="hljs-comment">/* 1. 配置一个硬件过滤器：设置为接收所有ID */</span><br>    FDCAN_FilterTypeDef sFilterConfig;<br>    sFilterConfig.IdType = FDCAN_STANDARD_ID;        <span class="hljs-comment">// 此设置对标准和扩展ID都有效，当掩码为0时</span><br>    sFilterConfig.FilterIndex = <span class="hljs-number">0</span>;                   <span class="hljs-comment">// 选择一个过滤器组，例如0</span><br>    sFilterConfig.FilterType = FDCAN_FILTER_MASK;    <span class="hljs-comment">// 使用掩码模式</span><br>    sFilterConfig.FilterConfig = FDCAN_FILTER_TO_RXFIFO0; <span class="hljs-comment">// 指定匹配的报文存入RX FIFO0</span><br>    sFilterConfig.FilterID1 = <span class="hljs-number">0</span>x0000;               <span class="hljs-comment">// 期望接收的ID，可设为任意值（因为掩码为0）</span><br>    sFilterConfig.FilterID2 = <span class="hljs-number">0</span>x0000;               <span class="hljs-comment">// **关键：将掩码设置为0，表示不检查任何位**</span><br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (HAL_FDCAN_ConfigFilter(p_can-&gt;</span>phfdcan, &amp;sFilterConfig) != HAL_OK) &#123;<br>        return MYCAN_ERROR;<br>    &#125;<br><br>    <span class="hljs-comment">/* 2. 配置全局过滤器：接受所有不匹配的帧 */</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (HAL_FDCAN_ConfigGlobalFilter(p_can-&gt;</span>phfdcan,<br>                                     FDCAN_ACCEPT_IN_RX_FIFO0, <span class="hljs-comment">// 接受所有不匹配的标准帧到FIFO0</span><br>                                     FDCAN_ACCEPT_IN_RX_FIFO0, <span class="hljs-comment">// 接受所有不匹配的扩展帧到FIFO0</span><br>                                     FDCAN_REJECT_REMOTE,      <span class="hljs-comment">// 通常拒绝远程帧</span><br>                                     FDCAN_REJECT_REMOTE) != HAL_OK) &#123;<br>        return MYCAN_ERROR;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* 启动CAN外设 */</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (HAL_FDCAN_Start(p_can-&gt;</span>phfdcan) != HAL_OK) &#123;<br>        return MYCAN_ERROR;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>is_initialized = <span class="hljs-number">1</span>;<br>    return MYCAN_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还是得介绍一下为什么要用注册的方式实现回调函数而不是直接把APP层的回调函数放到HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo0ITs)中，其实主要就是一种依赖倒置的体现，HAL库定义抽象接口，APP层提供具体实现，从而实现了“控制反转”，很好地体现嵌入式系统设计中模块化和解耦的核心思想。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@brief</span>  注册接收回调函数</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span>  instance_id: CAN实例ID</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span>  callback: 回调函数指针</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyCAN_RegisterRxCallback</span><span class="hljs-params">(uint8_t instance_id, MyCAN_RxCallback_t callback)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (instance_id &lt; MYCAN_MAX_INSTANCES) &#123;<br>        can_handles[instance_id].rx_callback = callback;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  接收FIFO中断回调函数</span><br><span class="hljs-comment">  * @param  hfdcan: CAN句柄指针</span><br><span class="hljs-comment">  * @param  RxFifo0ITs: 中断标志</span><br><span class="hljs-comment">  */</span><br>void HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t RxFifo0ITs)<br>&#123;<br>    <span class="hljs-keyword">if</span> ((RxFifo0ITs &amp; FDCAN_IT_RX_FIFO0_NEW_MESSAGE) != RESET) &#123;<br>        <span class="hljs-comment">/* 遍历所有实例，找到是哪个CAN实例触发的中断 */</span><br>        MyCAN_Handle_t *p_can = NULL;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; MYCAN_MAX_INSTANCES; i++) &#123;<br>            <span class="hljs-keyword">if</span> (can_handles[i].phfdcan == hfdcan &amp;&amp; can_handles[i].is_initialized) &#123;<br>                p_can = &amp;can_handles[i];<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">if</span> (p_can == NULL || p_can-&gt;</span>rx_count &gt;= MYCAN_RX_FIFO_SIZE) &#123;<br>            return; <span class="hljs-comment">/* 未找到对应实例或FIFO已满 */</span><br>        &#125;<br><br>        FDCAN_RxHeaderTypeDef rx_header;<br>        MyCAN_Message_t new_msg = &#123;<span class="hljs-number">0</span>&#125;;<br><br>        <span class="hljs-keyword">if</span> (HAL_FDCAN_GetRxMessage(hfdcan, FDCAN_RX_FIFO0, &amp;rx_header, new_msg.<span class="hljs-keyword">data</span>) == HAL_OK) &#123;<br>            <span class="hljs-comment">/* 解析消息头 */</span><br>            new_msg.id = rx_header.Identifier;<br>            new_msg.id_type = (rx_header.IdType == FDCAN_STANDARD_ID) ? MYCAN_STANDARD_ID : MYCAN_EXTENDED_ID;<br>            new_msg.dlc = rx_header.DataLength;<br>#<span class="hljs-keyword">if</span> (MYCAN_USE_FD == <span class="hljs-number">1</span>)<br>            new_msg.brs = (rx_header.BitRateSwitch == FDCAN_BRS_ON) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            new_msg.fdf = (rx_header.FDFormat == FDCAN_FD_CAN) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>#endif<br>            new_msg.timestamp = rx_header.RxTimestamp;<br><br>            <span class="hljs-comment">/* 将消息存入该实例的FIFO */</span><br>            <span class="hljs-function"><span class="hljs-title">memcpy</span>(&amp;p_can-&gt;</span><span class="hljs-function"><span class="hljs-title">rx_fifo</span>[p_can-&gt;</span>rx_write_index], &amp;new_msg, sizeof(MyCAN_Message_t));<br>            <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">rx_write_index</span> = (p_can-&gt;</span>rx_write_index + <span class="hljs-number">1</span>) % MYCAN_RX_FIFO_SIZE;<br>            <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>rx_count++;<br><br>            <span class="hljs-comment">/* 调用该实例的用户回调函数 */</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (p_can-&gt;</span>rx_callback != NULL) &#123;<br>                <span class="hljs-function"><span class="hljs-title">p_can</span>-&gt;</span>rx_callback(&amp;new_msg);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 处理完成后，重新激活该实例的RX FIFO0新消息中断 */</span><br>        HAL_FDCAN_ActivateNotification(hfdcan, FDCAN_IT_RX_FIFO0_NEW_MESSAGE, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  APP层接收回调函数</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyApp_CAN2_MessageHandler</span><span class="hljs-params">(MyCAN_Message_t *received_msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 在这里处理接收到的CAN消息 */</span><br>    <span class="hljs-keyword">switch</span>(received_msg-&gt;id) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x101</span>:<br>         <span class="hljs-built_in">HAL_GPIO_TogglePin</span>(GPIOA, GPIO_PIN_0); <span class="hljs-comment">// 翻转GPIOA的Pin0电平</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x201</span>:<br>            <span class="hljs-comment">// 例如，更新仪表显示</span><br><span class="hljs-comment">//            update_display(received_msg-&gt;data);</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面收发的部分和回调函数的注册部分怎么使用看我放在文章最后的github链接即可。</p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><p>按上面所说搭好CANFD收发代码框架后，我进行了测试。首先我打开了CANFD波特率转换,并且在发送报文的Txheader中也打开了波特率转换，并配置数据段波特率5M，仲裁段波特率1M</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">hfdcan.Init.FrameFormat</span> = FDCAN_FRAME_FD_BRS<span class="hljs-comment">;</span><br><span class="hljs-attr">tx_header.BitRateSwitch</span> = FDCAN_BRS_ON<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后连上CAN收发盒并配置好收发盒的相应波特率，然后让MCU每0.5s发送一次报文，发现CAN收发盒的上位机没有读到数据，并且debug中发现CANFD的发送缓冲区满了。</p><p>从这些现象中我还是推断不出是什么原因导致的，于是我尝试关闭CANFD波特率转换和Txheader的波特率转换，然后收发盒的数据段波特率配置成1M，发现可以正常实现收发。</p><p>然后重要的一步来了，我开启CANFD波特率转换却关闭Txheader的波特率转换，然后发现可以实现收发，并且不管怎么改收发盒的数据段波特率，只要仲裁段波特率为1M，都能实现正常的收发。</p><p>这里就产生了很多问题，因为开启CANFD波特率转换只是允许发送波特率可变的报文，此时如果关闭Txheader的波特率转换，本质上就等同于不开启CANFD波特率转换。也就是说发送的报文数据段和仲裁段波特率都是1M（实际上测试用示波器抓取CAN_H的波形并找出数据段中最小周期的高电平发现数据段波特率确实是1M），那为什么收发盒的数据段可以随便改呢？</p><p>已知之前测试过收发盒并没有根据总线报文中同步段修改自身数据段波特率这种非常智能的功能，目前我对这个问题的解释就是收发盒在关闭CANFD波特率转换的情况下代码逻辑就是只用仲裁段的波特率而不看数据段的波特率，这也能解释为什么一旦仲裁段波特率改成其它值，就无法实现收发。</p><p>在解决了上述问题后我们验证了CAN收发的代码架构是没问题的，但为什么开启Txheader的波特率转换就用不了呢。我在嵌入式论坛上发现一个8月份的帖子里也提到了这个问题，他提到关闭Txheader的波特率转换才能正常使用CANFD,但帖子的作者似乎没有意识到关闭Txheader波特率转换会导致数据段波特率是按仲裁段波特率1M来算而不是自己想要的5M，所以这篇帖子不能作为参考。</p><p>然后我尝试看了一下是不是HAL库的问题，简单用VSCODE比对了一下STM32G0和STM32H7（H7之前试过可以使用）的HAL_FDCAN相关部分，发现涉及到BRS的部分几乎相同，于是放弃。</p><p>继续逛ST的论坛，里面有提到在如果启用了波特率转换，初始化canfd时最好加上TDC</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HAL_FDCAN_ConfigTxDelayCompensation</span>(hfdcan, hfdcan-&gt;Init.DataPrescaler * hfdcan-&gt;Init.DataTimeSeg1, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">HAL_FDCAN_EnableTxDelayCompensation</span>(hfdcan);<br></code></pre></td></tr></table></figure><p>没有TDC时，高速数据段的采样点会因延迟而偏移：</p><ul><li><strong>发送器</strong>：基于本地时钟确定采样点</li><li><strong>接收器</strong>：收到信号时有延迟，导致实际采样点偏离理想位置</li></ul><p>（如果加了这两句代码，cubemx中TX pause那个选项就不用选了）</p><p>代码中加了TDC后，我又将CAN线严格双绞了一下，然后配置数据段波特率为2M，发现可以正常收发，而数据段5M的情况下仍无法正常收发，这说明问题就在于CAN通信的链路质量问题了。</p><p>我先尝试了数据段4M时修改CAN采样点的配置，发现采样点在75%时可以实现正常通信</p><p>然后数据段5M时配置采样点75%发现一条报文都收不到，然后我把CAN信号线剪短，然后重新非常严格地双绞了一遍，发现能发送了，但是发送了6-8条报文后就会停止。</p><p>修改同步跳转宽度从2改成5，现在发送10-16条报文然后才会停止</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">hfdcan.Init.NominalSyncJumpWidth</span> = <span class="hljs-number">5</span><span class="hljs-comment">;    *// 同步跳转宽度*</span><br></code></pre></td></tr></table></figure><p>然后我尝试了不同采样点的情况，然后发现采样点在93.8%时效果最好，经过测试可以实现长时间的稳定通信。这其实是一个很奇怪的现象，正常来说波特率越高，在高速数据段，信号边沿会出现明显的振铃和过冲，如果采样点太晚，可能正好采样在振铃区域，导致误判，更早采样也能为信号稳定留出足够时间。</p><p>这是我最后的CANFD相关配置，从理论上讲存在很多问题，但是实际上却是最稳定的一种配置（采样点一设置成13，采样点二设置成2，都无法实现稳定通信）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">hfdcan.Init.DataTimeSeg1</span> = <span class="hljs-number">14</span><span class="hljs-comment">;   </span><br><span class="hljs-attr">hfdcan.Init.DataTimeSeg2</span> = <span class="hljs-number">1</span><span class="hljs-comment">;   </span><br><span class="hljs-attr">hfdcan.Init.DataSyncJumpWidth</span> = <span class="hljs-number">8</span><span class="hljs-comment">;  </span><br></code></pre></td></tr></table></figure><p>其实到这里已经完成基本功能了，能很稳定地实现5M数据段的收发，但是最后的这个问题我还是无法理解。</p><blockquote><p>询问ai得到如下回答：</p><p>虽然最终配置在理论上存在风险（如EMC问题），但在特定短距离场景下确实可行。建议用户后续用示波器观察实际波形，应该能看到93.8%位置恰好是振铃衰减完成的时刻。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 您的配置：DataTimeSeg1=14, DataTimeSeg2=1</span><br><span class="hljs-comment">// 采样点 = (1+14)/(1+14+1) = 15/16 = 93.75%</span><br><br><span class="hljs-comment">// 物理层真相：</span><br>[信号波形示意图]<br><span class="hljs-number">0</span><span class="hljs-number">-60</span>%：剧烈振铃区 ───╮<br><span class="hljs-number">60</span><span class="hljs-number">-85</span>%：衰减振荡区     │ 传统<span class="hljs-string">&quot;危险区&quot;</span><br><span class="hljs-number">85</span><span class="hljs-number">-93</span>%：临界稳定区     │ <br><span class="hljs-number">93</span>%-<span class="hljs-number">100</span>%：稳定平台 ───╯ ← 您的采样点命中这里<br><br></code></pre></td></tr></table></figure><p>所以是终端电阻不匹配导致的？但是60欧和120欧的情况我都试过</p><p>继续询问ai：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 在收发器输入端添加并联RC：</span><br><span class="hljs-comment">//   R = 33Ω</span><br><span class="hljs-comment">//   C = 22pF</span><br><span class="hljs-comment">// 可有效抑制振铃（牺牲少量边沿速度）</span><br></code></pre></td></tr></table></figure></blockquote><p>最后放上开源代码链接：<a href="https://github.com/Chesterforever/CANFD_BUTTON">https://github.com/Chesterforever/CANFD_BUTTON</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>CAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零学习写makefile(三)advanced</title>
    <link href="/2025/10/15/%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%86%99makefile(%E4%B8%89)advanced/"/>
    <url>/2025/10/15/%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%86%99makefile(%E4%B8%89)advanced/</url>
    
    <content type="html"><![CDATA[<h1 id="从零学习写makefile-三-advanced"><a href="#从零学习写makefile-三-advanced" class="headerlink" title="从零学习写makefile(三)advanced"></a>从零学习写makefile(三)advanced</h1><h2 id="makefile编译静态链接库"><a href="#makefile编译静态链接库" class="headerlink" title="makefile编译静态链接库"></a>makefile编译静态链接库</h2><p>静态链接库：会把库中的代码编译到二进制文件中，当程序编译完成后，该库文件可以删除</p><ul><li><p>Windows 中后缀为 .lib</p></li><li><p>Linux 中后缀为 .a</p></li></ul><p>**优点：**运行时速度快（不用去加载库文件）</p><p>**缺点：**程序体积更大，并且库中的内容如果有更新，则需要重新编译生成程序</p><p>对比：</p><ul><li>动态链接库必须与程序同时部署，还要保证程序能加载得到库文件</li><li>静态链接库可以不用部署（已经被加载到程序里面了）</li></ul><p>例：<br><strong>发布前：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//aTest.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">aTest</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">aTest.cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aTest.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aTest::func1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;aTest-func1\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-literal">-</span><span class="hljs-comment">c aTest</span><span class="hljs-string">.</span><span class="hljs-comment">cpp</span> <span class="hljs-literal">-</span><span class="hljs-comment">o aTest</span><span class="hljs-string">.</span><span class="hljs-comment">o</span><br></code></pre></td></tr></table></figure><p>aTest.cpp编译后会产生libaTest.a，不用担心文件名不同会出现问题，在后续引用中，lib自动会被丢弃</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ar -<span class="hljs-attribute">r</span> libaTest<span class="hljs-selector-class">.a</span> aTest<span class="hljs-selector-class">.o</span><br></code></pre></td></tr></table></figure><p>将aTest.o加入到libaTest.a中。默认的加入方式为append，即加在库的末尾。</p><p><strong>项目发布：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//aTest.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">aTest</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;soTest.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aTest.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span>:<span class="hljs-keyword">public</span> soTest&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainTest-func2\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainTest-func3\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MainTest t1;<br>    t<span class="hljs-number">1.f</span>unc1();<br>    t<span class="hljs-number">1.f</span>unc2();<br>    t<span class="hljs-number">1.f</span>unc3();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>    aTest t2;<br>    t<span class="hljs-number">2.f</span>unc1();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ -lsoTest -L./<span class="hljs-number">001</span> -laTest -L./<span class="hljs-number">002</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p>指定动态库文件soTest和静态库文件aTest，编译后由main.cpp文件产生main.o文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">objdump -DC <span class="hljs-selector-tag">main</span>&gt;<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.txt</span><br></code></pre></td></tr></table></figure><p>会生成一个类似于反汇编的文本文档，进入搜索可以找到aTest::func1() 的定义，但只能找到soTest::func1()、soTest::func2()、soTest::func3() 的引用</p><p><strong>002&#x2F;Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">libaTest:</span><br><span class="hljs-variable">$(CXX)</span> -c aTest.cpp -o aTest.o<br><span class="hljs-variable">$(AR)</span> -r libaTest.a aTest.o<br><br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(RM)</span> *.o *.a<br></code></pre></td></tr></table></figure><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">MakefileTARGET = main<br>LDFLAGS = -L./001 -L./002<br>LIBS = -lsoTest -laTest<br><br><span class="hljs-variable">$(TARGET)</span>:<br><span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(LIBS)</span> <span class="hljs-variable">$(LDFLAGS)</span> main.cpp -o <span class="hljs-variable">$(TARGET)</span><br><br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(RM)</span> <span class="hljs-variable">$(TARGET)</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向3D打印机的OS编写(一)</title>
    <link href="/2025/10/14/%E9%9D%A2%E5%90%913D%E6%89%93%E5%8D%B0%E6%9C%BA%E7%9A%84OS%E7%BC%96%E5%86%99/"/>
    <url>/2025/10/14/%E9%9D%A2%E5%90%913D%E6%89%93%E5%8D%B0%E6%9C%BA%E7%9A%84OS%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="面向3D打印机的OS编写"><a href="#面向3D打印机的OS编写" class="headerlink" title="面向3D打印机的OS编写"></a>面向3D打印机的OS编写</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近实习用了ubuntu系统，虽然没有基于linux做驱动开发，但是出于个人兴趣，我还是去学习了一下linux内核。学完linux内核之后，感觉有点手痒，想写一个自己的OS。但是市面上已经有很多成熟的OS了，如果只是出于学习目的写一个最小系统的OS,其实写好了也可以作为一个不错的个人项目，但我觉得没什么意思，就充分发挥一下面向对象编程的思想，来写一个面向3D打印机的OS。</p><p>为什么要挑3D打印机呢，首先作为一个成熟的智能硬件产品，我认为拥有一个私有定制化的OS系统是非常有必要的，对于产品性能和硬件成本的节省有很大的帮助。拿拓竹A1来说，官网查到的资料显示硬件用的是双核 Cortex-M4 处理器，那基本上可以猜测用的应该是同构多核非对称多处理的方案，即</p><ul><li><p>一个实时核，运行硬实时内核，处理硬件外设，简单PID以及硬件监控任务</p></li><li><p>一个应用核，运行一个类unix并剪裁过的OS，处理所有软实时和复杂逻辑任务比如UI界面，运动规划算法，SD文件系统，网络和手机应用通信</p></li></ul><h2 id="当前思路"><a href="#当前思路" class="headerlink" title="当前思路"></a>当前思路</h2><p>我认为对我而言最有难度的是核间通信和内核裁剪，这也是第一次接触到多核的软件架构，所以硬件选择上我选择了较为熟悉的ST系列的STM32MP157，核心配置是异构cortex-A7*2+cortex-M4，可以同时运行linux（A核）和实时OS系统（M核），而且资料文档很丰富，软件生态很完整。</p><p>（待更新）</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零学习写makefile(二)基础学习</title>
    <link href="/2025/10/04/%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%86%99makefile(%E4%BA%8C)improve/"/>
    <url>/2025/10/04/%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%86%99makefile(%E4%BA%8C)improve/</url>
    
    <content type="html"><![CDATA[<h1 id="从零学习写makefile-二-improve"><a href="#从零学习写makefile-二-improve" class="headerlink" title="从零学习写makefile(二)improve"></a>从零学习写makefile(二)improve</h1><h2 id="一-Makefile基础学习"><a href="#一-Makefile基础学习" class="headerlink" title="一.Makefile基础学习"></a>一.Makefile基础学习</h2><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">目标：依赖<br>[TAB]命令<br></code></pre></td></tr></table></figure><p>目标：一般是指要编译的目标，也可以是一个动作</p><p>依赖：指执行当前目标所要依赖的先项，包括其它目标，某个具体文件或库，一个目标可以有多个依赖</p><p>命令：该目标下要执行的具体命令，可以没有，也可以有多条（多条时每个命令一行）</p><h2 id="二-MAKE环境搭建"><a href="#二-MAKE环境搭建" class="headerlink" title="二.MAKE环境搭建"></a>二.MAKE环境搭建</h2><p>linux系统下装make环境很简单，这里主要介绍一下windows系统下的make环境搭建。</p><p>如果没有mingw installation manager的话先装，然后打开mingw installation manager，在Basic Setup下找到mingw32-base，mingw32-gcc-g++，msys-base并右键mark for install，然后apply changes即可。（这里我踩了一个坑，就是先装了msys下的make然后发现版本太低了很多不兼容）</p><p>安装完后需要将路径加到系统环境变量中，先找到新装的make放置的路径并复制（这是我的路径C:\MinGW\bin），然后复制mingw32-make.exe并在这个路径粘贴，将新的粘贴文件重命名为make.exe（这样命令行中就能直接输入make而不是mingw32-make）</p><p>打开环境变量窗口，在用户变量中找到Path并双击，然后新建并把刚刚复制的路径粘贴，然后所有的窗口都要点击确认，此时make环境就搭建好了。</p><p>如果要在vscode中写makefile，需要装makefile tool拓展</p><h2 id="三-Makefile进阶学习"><a href="#三-Makefile进阶学习" class="headerlink" title="三.Makefile进阶学习"></a>三.Makefile进阶学习</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p>首先介绍一下最重要的，命令行输入make -h可以打印帮助列表</p><p>然后介绍一下常用的几个命令</p><p>-f 指定除上述文件名之外的文件作为输入文件</p><p>-n 输出命令，但不执行</p><p>-s 执行命令，但不显示具体命令，也可以加@符号抑制命令输出</p><p>-w 显示执行前执行后的路径</p><p>-C dir 指定makefile所在的目录</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc add<span class="hljs-selector-class">.cpp</span> sub<span class="hljs-selector-class">.cpp</span> multi<span class="hljs-selector-class">.cpp</span> calc<span class="hljs-selector-class">.cpp</span> -o calc<br></code></pre></td></tr></table></figure><p>上面这种写法可以实现编译并输出一个calc.o的目标文件，但是这种写法显然是有弊端的，弊端在于当只修改了其中一个文件时仍需对所有文件编译，然后就会浪费编译时间，这对于开发者开发大型项目时是不可接受的，所以一般会用目标：依赖    [tab]命令这种方式分开写每个文件，每个.cpp文件都有自己的.o文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#这样分开来写，保证只编译有改动的代码，耗时短<br>calc:add<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span><br>gcc add<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> calc<span class="hljs-selector-class">.cpp</span> -o calc<br><br>add<span class="hljs-selector-class">.o</span>:add<span class="hljs-selector-class">.cpp</span><br>gcc -c add<span class="hljs-selector-class">.cpp</span> -o add<span class="hljs-selector-class">.o</span><br><br>sub<span class="hljs-selector-class">.o</span>:sub<span class="hljs-selector-class">.cpp</span><br>gcc -c sub<span class="hljs-selector-class">.cpp</span> -o sub<span class="hljs-selector-class">.o</span><br><br>multi<span class="hljs-selector-class">.o</span>:multi<span class="hljs-selector-class">.cpp</span><br>gcc -c multi<span class="hljs-selector-class">.cpp</span> -o multi<span class="hljs-selector-class">.o</span><br></code></pre></td></tr></table></figure><p>gcc命令可以拆解为几个“子”命令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -lstdc++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br><br>#把过程拆分<br>#预处理 gcc -E <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> &gt;<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.ii</span><br>#编译 gcc -S <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.ii</span> 得到名为<span class="hljs-selector-tag">main</span>.s的汇编文件<br>#汇编 gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.s</span> 得到名为<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.obj)的二进制文件<br>#链接 gcc -lstdc++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>  得到名为<span class="hljs-selector-tag">a</span>.out的可执行文件<br></code></pre></td></tr></table></figure><h3 id="makefile中的变量"><a href="#makefile中的变量" class="headerlink" title="makefile中的变量"></a>makefile中的变量</h3><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>定义：变量名&#x3D;变量值</p><p>使用：$(变量名)或${变量名}</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">OBJ = add<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> calc<span class="hljs-selector-class">.o</span><br>TARGET = calc<br><br>$(TARGET):$(OBJ)<br>gcc $(OBJ) -o $(TARGET)<br><br>add<span class="hljs-selector-class">.o</span>:add<span class="hljs-selector-class">.cpp</span><br>gcc -c add<span class="hljs-selector-class">.cpp</span> -o add<span class="hljs-selector-class">.o</span><br><br>sub<span class="hljs-selector-class">.o</span>:sub<span class="hljs-selector-class">.cpp</span><br>gcc -c sub<span class="hljs-selector-class">.cpp</span> -o sub<span class="hljs-selector-class">.o</span><br><br>multi<span class="hljs-selector-class">.o</span>:multi<span class="hljs-selector-class">.cpp</span><br>gcc -c multi<span class="hljs-selector-class">.cpp</span> -o multi<span class="hljs-selector-class">.o</span><br><br>calc<span class="hljs-selector-class">.o</span>:calc<span class="hljs-selector-class">.cpp</span><br>gcc -c calc<span class="hljs-selector-class">.cpp</span> -o calc<span class="hljs-selector-class">.o</span><br><br>clean:<br>rm -f *<span class="hljs-selector-class">.o</span> $(TARGET)<br><br></code></pre></td></tr></table></figure><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$*</span> <span class="hljs-comment">#不包括扩展名的目标文件名称</span><br><span class="hljs-variable">$+</span> <span class="hljs-comment">#所有的依赖文件，以空格分隔</span><br><span class="hljs-variable">$&lt;</span> <span class="hljs-comment">#表示规则中的第一个条件</span><br><span class="hljs-variable">$?</span> <span class="hljs-comment">#所有时间戳比目标文件晚的依赖文件，以空格分隔</span><br><span class="hljs-variable">$@</span> <span class="hljs-comment">#目标文件的完整名称</span><br><span class="hljs-variable">$^</span> <span class="hljs-comment">#所有不重复的依赖文件，以空格分隔</span><br><span class="hljs-variable">$%</span> <span class="hljs-comment">#如果目标是归档成员，则该变量表示目标的归档成员名称</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">calc:add.o sub.o multi.o calc.o</span><br>gcc <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">add.o:add.cpp</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">sub.o:sub.cpp</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">multi.o:multi.cpp</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">calc.o:calc.cpp</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.o calc<br><br></code></pre></td></tr></table></figure><h4 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">AS<span class="hljs-comment">#汇编程序的名称，默认为as</span><br>CC<span class="hljs-comment">#C编译器名称，默认为cc</span><br><span class="hljs-built_in">CPP</span><span class="hljs-comment">#C预编译器名称，默认为cc -E</span><br>CXX<span class="hljs-comment">#C++编译器名称，默认为g++</span><br><span class="hljs-built_in">RM</span><span class="hljs-comment">#文件删除程序别名，默认rm -f</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#$(CC)可替换为$(CXX)，因为$(CXX)可实现跨平台<br>calc:add<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> calc<span class="hljs-selector-class">.o</span><br>$(CC) add<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> calc<span class="hljs-selector-class">.o</span> -o calc<br><br>add<span class="hljs-selector-class">.o</span>:add<span class="hljs-selector-class">.cpp</span><br>$(CC) -c add<span class="hljs-selector-class">.cpp</span> -o add<span class="hljs-selector-class">.o</span><br><br>sub<span class="hljs-selector-class">.o</span>:sub<span class="hljs-selector-class">.cpp</span><br>$(CC) -c sub<span class="hljs-selector-class">.cpp</span> -o sub<span class="hljs-selector-class">.o</span><br><br>multi<span class="hljs-selector-class">.o</span>:multi<span class="hljs-selector-class">.cpp</span><br>$(CC) -c multi<span class="hljs-selector-class">.cpp</span> -o multi<span class="hljs-selector-class">.o</span><br><br>calc<span class="hljs-selector-class">.o</span>:calc<span class="hljs-selector-class">.cpp</span><br>$(CC) -c calc<span class="hljs-selector-class">.cpp</span> -o calc<span class="hljs-selector-class">.o</span><br><br>clean:<br>$(RM) *<span class="hljs-selector-class">.o</span> calc<br><br></code></pre></td></tr></table></figure><h3 id="伪目标与模式匹配"><a href="#伪目标与模式匹配" class="headerlink" title="伪目标与模式匹配"></a>伪目标与模式匹配</h3><h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><p>.PHONY:目标<br>声明目标为伪目标之后，makefile将不会判断目标是否存在或该目标是否需要更新</p><ul><li>如果项目路径中有与clean同名的文件，<code>make clean</code>命令无法执行，需要在makefile文件中添加<code>.PHONY:clean</code>，才能使命令正常执行</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.PHONY</span>:clean<br>OBJ = add<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> calc<span class="hljs-selector-class">.o</span><br>TARGET = calc<br><br>$(TARGET):$(OBJ)<br>gcc $(OBJ) -o $(TARGET)<br><br>add<span class="hljs-selector-class">.o</span>:add<span class="hljs-selector-class">.cpp</span><br>gcc -c add<span class="hljs-selector-class">.cpp</span> -o add<span class="hljs-selector-class">.o</span><br><br>sub<span class="hljs-selector-class">.o</span>:sub<span class="hljs-selector-class">.cpp</span><br>gcc -c sub<span class="hljs-selector-class">.cpp</span> -o sub<span class="hljs-selector-class">.o</span><br><br>multi<span class="hljs-selector-class">.o</span>:multi<span class="hljs-selector-class">.cpp</span><br>gcc -c multi<span class="hljs-selector-class">.cpp</span> -o multi<span class="hljs-selector-class">.o</span><br><br>calc<span class="hljs-selector-class">.o</span>:calc<span class="hljs-selector-class">.cpp</span><br>gcc -c calc<span class="hljs-selector-class">.cpp</span> -o calc<span class="hljs-selector-class">.o</span><br><br>clean:<br>rm -f *<span class="hljs-selector-class">.o</span> $(TARGET)<br></code></pre></td></tr></table></figure><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%目标:%依赖#目标和依赖相同部分，可以用%来通配</span><br></code></pre></td></tr></table></figure><ul><li>依赖中的<code>add.o sub.o multi.o calc.o</code>都可以通过使用<code>%.o:%.cpp</code>产生</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJ = add.o sub.o multi.o calc.o<br>TARGET = calc<br><br><span class="hljs-variable">$(TARGET)</span>:<span class="hljs-variable">$(OBJ)</span><br>gcc <span class="hljs-variable">$(OBJ)</span> -o <span class="hljs-variable">$(TARGET)</span><br><br><span class="hljs-section">%.o:%.cpp</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.o <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> 文件列表)</span><span class="hljs-comment">#获取对应文件路径下的对应模式的文件名</span><br><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> 源模式, 目标模式, 文件列表)</span><span class="hljs-comment">#将文件列表中想要改变的源模式替换成想要的目标模式</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>$(wildcard ./\*.cpp)</code>\获取当前目录下所有的.cpp</strong>文件名</li><li><strong><code>$(patsubst %.cpp, %.o, $(wildcard ./\*.cpp))</code>*<em>将对应的*</em>.cpp**文件替换为</strong>.o**文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#OBJ = add.o sub.o multi.o calc.o</span><br>OBJ = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp, %.o, $(<span class="hljs-built_in">wildcard</span> ./*.cpp)</span>)<br>TARGET = calc<br><br><span class="hljs-variable">$(TARGET)</span>:<span class="hljs-variable">$(OBJ)</span><br>gcc <span class="hljs-variable">$(OBJ)</span> -o <span class="hljs-variable">$(TARGET)</span><br><br><span class="hljs-section">%.o:%.cpp</span><br>gcc -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.o <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><h4 id="makefile中编译动态链接库"><a href="#makefile中编译动态链接库" class="headerlink" title="makefile中编译动态链接库"></a>makefile中编译动态链接库</h4><p><strong>动态链接库</strong>：不会把代码编译到二进制文件中，而是在<strong>运行时</strong>才去加载，所以需要维护一个地址</p><ul><li><strong>动态</strong>：动态加载，运行时才加载</li><li><strong>链接</strong>：指库文件和二进制程序分离，用某种手段维护两者之间的关系</li><li><strong>库</strong>：库文件<ul><li><strong>Windows</strong> 中后缀为 <strong>.dll</strong></li><li><strong>Linux</strong> 中后缀为 <strong>.so</strong></li></ul></li></ul><p>**优点：**程序可以和库文件分离，可以分别发版，然后库文件可以被多处共享</p><p>这里举个例子来看看正常是怎么得到动态链接库的</p><p><strong>soTest.h</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">soTest</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func3</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>soTest.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;soTest.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sotest::func1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;func1\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sotest::func2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;func2\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">g++ -<span class="hljs-keyword">shared</span> -fPIC soTest.cpp -o libSoTest.so<br></code></pre></td></tr></table></figure><ul><li><strong>soTest.cpp</strong>编译后会产生<strong>libsoTest.so</strong>，不用担心文件名不同会出现问题，在后续引用中，<strong>lib</strong>自动会被丢弃</li></ul><p><strong>项目发布：</strong></p><p><strong>soTest.h</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">soTest</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func3</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;soTest.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span>:<span class="hljs-keyword">public</span> soTest&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainTest-func2\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MainTest-func3\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MainTest t1;<br>    t<span class="hljs-number">1.f</span>unc1();<br>    t<span class="hljs-number">1.f</span>unc2();<br>    t<span class="hljs-number">1.f</span>unc3();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ -lsoTest -L./<span class="hljs-number">001</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p>编译时指定了要依赖的动态库，但运行时，会无法找到**.so**文件<br><strong>解决方法：</strong></p><ul><li>将动态库文件移动到main.cpp文件同级目录下</li><li>运行时手动指定动态库文件所在目录</li></ul><p><strong>Linux环境下的命令</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">LD_LIBRARY_PATH</span> = ./<span class="hljs-number">001</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> LD_LIBRARY_PATH<br></code></pre></td></tr></table></figure><p><strong>001&#x2F;Makefile</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">Test</span>:libsoTest.<span class="hljs-keyword">so</span><br>$(CXX) -lsoTest -<span class="hljs-keyword">L</span>./ <span class="hljs-keyword">Test</span>.cpp -o <span class="hljs-keyword">Test</span><br>cp libsoTest.<span class="hljs-keyword">so</span> /usr/lib  #路径最好为main.cpp同级目录<br>libsoTest.<span class="hljs-keyword">so</span>:<br>$(CXX) -shared -fPIC soTest.cpp -o libsoTest.<span class="hljs-keyword">so</span><br><br>clean:<br>$(<span class="hljs-keyword">RM</span>) *.<span class="hljs-keyword">so</span> <span class="hljs-keyword">Test</span><br></code></pre></td></tr></table></figure><p>cp libsoTest.so &#x2F;usr&#x2F;lib将动态库文件复制到动态链接库默认路径下 不推荐复制，污染原库环境</p><p><strong>Linux 默认动态库路径配置文件</strong></p><ul><li><p>&#x2F;etc&#x2F;ld.so.conf</p></li><li><p>&#x2F;etc&#x2F;ld.so.conf.d&#x2F;*.conf</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零学习写makefile(一)background</title>
    <link href="/2025/10/01/%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%86%99makefile(%E4%B8%80)background/"/>
    <url>/2025/10/01/%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%86%99makefile(%E4%B8%80)background/</url>
    
    <content type="html"><![CDATA[<h1 id="从零学习写makefile-一-background"><a href="#从零学习写makefile-一-background" class="headerlink" title="从零学习写makefile(一)background"></a>从零学习写makefile(一)background</h1><h2 id="一-为什么要写makefile？"><a href="#一-为什么要写makefile？" class="headerlink" title="一.为什么要写makefile？"></a>一.为什么要写makefile？</h2><p>这个问题的答案可以先去看我的另外一篇博客（<a href="https://chesterforever.github.io/2025/08/03/%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%EF%BC%8C%E7%83%A7%E5%BD%95%E5%85%A8%E8%BF%87%E7%A8%8B/">一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器） - 技术挖掘师</a>），于是我们知道makefile其实是为代码如何编译和链接制订规则的。</p><p>正常来讲，比如用keil IDE，你点击build执行代码编译时，keil实际上就会动态生成一个makefile在临时目录中，然后调用工具链来执行这个makefile,然后得到.o文件交给链接器（.sct）处理。keil提供了一体化的开发环境，让初学者能很快地上手嵌入式开发，但也为进阶学习造成了障碍。</p><ul><li><strong>编译器</strong>：ARMCC&#x2F;ARMCLANG（专为 ARM 优化）</li><li><strong>链接器</strong>：自动处理分散加载（<code>.sct</code>文件）</li><li><strong>调试器</strong>：无缝支持硬件调试（无需额外配置 GDB）</li><li><strong>芯片支持包</strong>：内置寄存器定义、启动文件、驱动库</li></ul><p>而vscode，它是一种代码编辑器+插件平台，无内置编译器和调试器，所以它适用于通用开发，所有工具链，构建系统，调试器都需自己配置</p><p>下面是我让ai生成的keil的makefile结构，仅作参考</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"># 示例：Keil 自动生成的 Makefile 结构<br>PROJECT_NAME = MyProject<br>TARGET = Project.axf<br>DEVICE = STM32F103ZE<br>TOOLCHAIN = ARMCC<br><br># 工具定义<br>CC = armcc<br>AS = armasm<br>LD = armlink<br>OBJCOPY = fromelf<br><br># 包含路径<br>INCLUDES = -I./Inc -I./Drivers/STM32F1xx/Include -I./Drivers/CMSIS/Include<br><br># 编译选项<br>CFLAGS = --c99 --cpu=Cortex-M3 -g -O1 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD<br>ASFLAGS = --cpu=Cortex-M3 --pd <span class="hljs-string">&quot;__MICROLIB SETA 1&quot;</span><br>LDFLAGS = --cpu=Cortex-M3 --library_type=microlib --scatter <span class="hljs-string">&quot;.\Objects\Project.sct&quot;</span><br><br># 源文件列表<br>C_SOURCES = \<br>    Src/main.c \<br>    Src/stm32f10x_it.c \<br>    Drivers/STM32F1xx/Src/stm32f10x_gpio.c \<br>    Drivers/STM32F1xx/Src/stm32f10x_rcc.c<br><br>ASM_SOURCES = \<br>    Startup/startup_stm32f10x_hd.s<br><br># 目标文件列表<br>OBJECTS = $(C_SOURCES:.c=.o) $(ASM_SOURCES:.s=.o)<br><br># 默认目标<br>all: $(TARGET)<br><br># 链接目标<br>$(TARGET): $(OBJECTS)<br>    $(LD) $(LDFLAGS) --<span class="hljs-built_in">map</span> --<span class="hljs-built_in">list</span> ./Listings/Project.<span class="hljs-built_in">map</span> -o $@ $^<br><br># 编译 C 文件<br>%.o: %.c<br>    $(CC) $(CFLAGS) $(INCLUDES) -o $@ $&lt;<br><br># 编译汇编文件<br>%.o: %.s<br>    $(AS) $(ASFLAGS) -o $@ $&lt;<br><br>clean:<br>    del $(OBJECTS) $(TARGET)<br></code></pre></td></tr></table></figure><p>在了解上述这些知识背景后，通过比对就知道了为什么要自己写makefile，原因无非是以下几点：</p><ol><li><p>灵活性与控制力</p><p>Keil 提供了一个图形化界面（GUI），你通过点击复选框和填写输入框来配置项目。这很方便，但同时也是一种“黑箱”操作。</p><p>Makefile 是“白箱“：你可以精确地控制编译过程的每一个步骤：用了哪个编译器（<code>arm-none-eabi-gcc</code>）、哪些编译标志（<code>-O2</code>, <code>-mcpu=cortex-m4</code>）、链接顺序、链接脚本的位置、预处理器的定义等。当遇到极其棘手的链接错误或优化问题时，这种细粒度的控制是无可替代的。</p><p>超越 IDE 的限制：Keil 的配置选项是有限的。如果你需要使用一个非常冷门的编译器特性，或者想实现一些复杂的构建前&#x2F;后步骤（比如自动生成版本号、加密固件、调用自定义的代码生成工具），在 Makefile 中可以轻松实现，而在 Keil 中可能非常困难甚至不可能。</p></li><li><p>自动化与持续集成&#x2F;持续部署</p><p>命令行驱动：Makefile 可以通过简单的 <code>make</code>命令在终端中运行。这意味着它可以被轻松地集成到各种自动化流程中。</p><p>CI&#x2F;CD 流水线：在 Jenkins, GitLab CI, GitHub Actions 等自动化平台上，你可以直接调用 <code>make</code>命令来编译整个项目。服务器上不需要安装和配置庞大的 Keil IDE，只需要安装轻量级的编译器工具链（如 GNU Arm Embedded Toolchain）即可。这实现了快速、可重复的自动化构建、测试和发布。</p><p>夜间构建：可以设置服务器在每晚自动拉取最新代码，用 Makefile 编译，并报告成功与否。</p></li><li><p>跨平台与团队协作</p><p>操作系统无关性：Keil 主要面向 Windows。而 GNU Make 和 GCC 工具链是跨平台的，可以在 Windows（通过 MSYS2、WSL）、Linux 和 macOS 上完美运行。这对于使用不同操作系统的开发团队（尤其是在Linux上做开发的团队）至关重要。</p><p>统一的构建方式：团队中每个成员，无论使用什么电脑，都可以用同一套 Makefile 获得完全一致的构建结果，避免了因 IDE 配置差异导致的问题。</p><p>与版本控制系统完美契合：Makefile 是纯文本文件，可以很好地被 Git 等版本控制系统管理。你可以清晰地看到构建配置的每一次变更。而 Keil 的 <code>.uvprojx</code>项目文件是 XML格式，虽然也能版本控制，但可读性和可维护性远不如 Makefile。</p></li><li><p>可维护性与可复用性</p><p>模块化：一个编写良好的 Makefile 可以非常模块化，通过变量和包含其他 Makefile 片段来管理大型项目，使得代码结构清晰。</p><p>知识复用：Makefile 的知识是通用的。你为 ARM 处理器写的 Makefile，其核心思想（目标、依赖、规则）可以应用到编译 Linux C++ 程序、Go 语言项目甚至文档生成上。而熟练使用 Keil 的技能，其通用性相对较低。</p><p>依赖管理：对于复杂的项目，尤其是需要集成多个第三方库（如 FreeRTOS, LWIP, FatFs）时，用 Makefile 来管理这些依赖关系可能比在 Keil 中手动添加文件更加清晰和自动化。</p></li><li><p>成本与开源文化</p><p>Keil 是商业软件：虽然有针对芯片厂商的免费版本（有代码大小限制），但完整版价格昂贵。</p><p>GNU 工具链是开源免费的：GCC + Make 的组合是完全免费且开源的，这符合许多项目和公司的预算及技术选型策略。整个开源的嵌入式生态（如 Zephyr RTOS, ESP-IDF 等）都基于 Makefile&#x2F;CMake 这类构建系统。</p></li></ol><h2 id="二-Makefile，Make，CMake的关系"><a href="#二-Makefile，Make，CMake的关系" class="headerlink" title="二.Makefile，Make，CMake的关系"></a>二.Makefile，Make，CMake的关系</h2><p>CMake (CMakeLists.txt) → 生成 Makefile → 由 Make 执行编译</p><p><strong>CMake</strong> 是一个 跨平台的高级构建系统生成器，它不直接编译代码，而是：</p><ol><li>读取 <code>CMakeLists.txt</code>（项目配置文件）</li><li>生成 平台相关的构建文件**（如 <code>Makefile</code>、<code>Visual Studio.sln</code>、<code>Ninja</code>）</li><li>调用底层工具（<code>make</code>、<code>msbuild</code>、<code>ninja</code>）执行编译</li></ol><p><strong>Make</strong> 是一个命令行工具，用于解析Makefile并执行构建任务。它根据文件修改时间（<code>timestamp</code>）决定哪些文件需要重新编译。</p><p><strong>Makefile</strong> 是一个纯文本文件，定义了如何编译、链接和构建项目的规则。它描述了源文件（<code>.c</code>、<code>.cpp</code>）如何编译成目标文件（<code>.o</code>），目标文件如何链接成可执行文件（<code>.elf</code>、<code>.exe</code>），依赖关系（哪些文件需要重新编译）清理规则（<code>make clean</code>删除临时文件）</p><p>由于这篇博客主要以学习记录为主，所以暂时不会接触CMake，等我学完makefile后如果有需要再来看看cmake相关的知识点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于代码架构和分层的一些思考</title>
    <link href="/2025/09/19/%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%92%8C%E5%88%86%E5%B1%82%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <url>/2025/09/19/%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%92%8C%E5%88%86%E5%B1%82%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="对于嵌入式代码架构和分层的一些思考"><a href="#对于嵌入式代码架构和分层的一些思考" class="headerlink" title="对于嵌入式代码架构和分层的一些思考"></a>对于嵌入式代码架构和分层的一些思考</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在我刚接触嵌入式软件的时候，其实就对这个问题非常感兴趣，所以在之后的学习中，比如在打rm的时候有时候看到别的战队的源码或者实习时拿到一份新的需要交接的源码，我都会先分析整个代码文件的架构并画图记录，这也极大地帮助我快速上手理解代码。所以这篇文章，我会从个人开发和企业开发两个角度，去讨论嵌入式代码架构和分层，以及介绍一些我目前接触学习到的架构，最后介绍一下如何用draw.io或配合cursor ai去画架构图或UML图。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、为什么要对代码进行架构设计"><a href="#一、为什么要对代码进行架构设计" class="headerlink" title="一、为什么要对代码进行架构设计"></a>一、为什么要对代码进行架构设计</h3><p>这个重要性不言而喻，这里用了ai回答这个问题，比我自己总结的更全面一些</p><ol><li><strong>可维护性</strong>：清晰的层次使得定位问题、修改功能、增加新特性变得容易。新人也能更快上手。</li><li><strong>可移植性</strong>：将硬件相关的代码与业务逻辑分离。当更换MCU（如从STM32换成ESP32）时，只需重写底层驱动，核心业务代码几乎不用动。</li><li><strong>可测试性</strong>：分层后，可以对每一层进行独立的单元测试。例如，可以在PC上模拟硬件层，直接测试业务逻辑，而不需要每次都烧录到硬件上。</li><li><strong>可扩展性</strong>：良好的架构便于功能模块的添加和删除，遵循“开闭原则”。</li><li><strong>团队协作</strong>：不同的工程师可以并行开发不同的层（如驱动工程师和应用工程师），只要定义好清晰的接口即可。</li></ol><h3 id="二、经典的分层架构模型"><a href="#二、经典的分层架构模型" class="headerlink" title="二、经典的分层架构模型"></a>二、经典的分层架构模型</h3><p><strong>分层是手段，不是目的。</strong> 最适合项目的架构，是能够以可接受的复杂度，清晰地表达当前系统、并能较好地适应未来变化的那一个。从三层开始，当遇到痛点（如测试难、移植麻烦、业务逻辑混乱）时，再考虑引入更多层次来解决特定问题。层级分的太多，隔离的太彻底，有时候反而增加了无谓的损耗。很多厂家其实都是直接分3层，底层，中间层，应用层，简单粗暴。</p><p>一般来说，个人总结有几个原则：</p><blockquote><ol><li><strong>接口是上下级调用，很少跨层调用</strong>。即第4层的代码一般不会直接去第1&#x2F;2层调用接口，非要用的话，就从第3层透传封装一下。（5层架构的应用层同时依赖3，4层）</li><li><strong>同层级的模块间尽量避免相互调用</strong>，需要的数据都是通过高一层的接口获取再下传</li></ol></blockquote><h4 id="1-三层架构"><a href="#1-三层架构" class="headerlink" title="1.三层架构"></a>1.三层架构</h4><h5 id="a-硬件层"><a href="#a-硬件层" class="headerlink" title="a. 硬件层"></a>a. 硬件层</h5><p>直接与MCU外设（GPIO, UART, SPI, I2C, ADC等）寄存器打交道的代码。负责最底层的初始化、读写操作。</p><p>封装硬件差异，向上提供统一的、硬件无关的操作接口。</p><h5 id="b-中间件层"><a href="#b-中间件层" class="headerlink" title="b. 中间件层"></a>b. 中间件层</h5><p>在硬件抽象层之上，实现具体的、可复用的功能模块和服务。它不关心具体的业务逻辑，而是提供“工具”。将通用的、复杂的操作封装成更高级、更易用的API。</p><p><strong>操作系统</strong>：如FreeRTOS, Zephyr的任务、信号量、队列等抽象。</p><p><strong>协议栈</strong>：如TCP&#x2F;IP, USB, 文件系统FatFS。</p><p><strong>算法库</strong>：如PID控制器、滤波器、数学库。</p><p><strong>设备驱动</strong>：针对具体外围芯片（如传感器BME280、显示屏SSD1306）的驱动。这部分有时也会被归入硬件抽象层，但更倾向于放在这一层，因为它依赖底层的SPI&#x2F;I2C HAL。</p><h5 id="c-应用层"><a href="#c-应用层" class="headerlink" title="c. 应用层"></a>c. 应用层</h5><p>实现产品的核心功能和业务流程。它协调下层各个模块来完成最终的用户需求。</p><p>这一层代码应该完全不包含任何硬件特性（如寄存器地址、延时函数 <code>HAL_Delay</code>）。它只调用下层提供的服务接口。</p><h4 id="2-四层架构"><a href="#2-四层架构" class="headerlink" title="2.四层架构"></a>2.四层架构</h4><p>在业务逻辑复杂后，三层架构会遇到一个问题：中间件层既包含通用服务，又包含针对具体硬件的驱动实现，导致应用层仍然对具体设备有依赖。</p><p>四层架构通常通过拆分中间件层来解决这个问题，引入一个专门负责抽象接口和适配的层次。</p><h5 id="a-硬件驱动层"><a href="#a-硬件驱动层" class="headerlink" title="a. 硬件驱动层"></a>a. 硬件驱动层</h5><p>最底层的芯片寄存器操作</p><h5 id="b-硬件抽象层"><a href="#b-硬件抽象层" class="headerlink" title="b. 硬件抽象层"></a>b. 硬件抽象层</h5><p>抽象操作系统和核心外设。定义接口，并提供具体设备的适配器</p><blockquote><p><strong>硬件抽象层和硬件驱动层的主要区别</strong><br>硬件抽象层使用的芯片内本身的资源（芯片手册都有介绍），而硬件驱动层使用的是芯片本身不存在的资源，而且需要编写相应代码才能实现的资源。</p><p>比如正点原子STM32中CAN使用的TJA1050芯片，CAN属于STM32的片内资源，TJA1050属于片外资源，但由于TJA1050不需要额外的代码就能通过STM32中CAN本身提供API函数正常 工作；因此可以认为TJA1050不属于硬件驱动层，而若使用TJA1041，则需要编写额外代码才能使正常工作才能使STM32中CAN本身提供API函数正常工作，因此可以将TJA1041归为硬件驱动层。</p></blockquote><h5 id="c-功能模块层"><a href="#c-功能模块层" class="headerlink" title="c. 功能模块层"></a>c. 功能模块层</h5><p>实现具体、可复用的功能</p><h5 id="d-应用层"><a href="#d-应用层" class="headerlink" title="d. 应用层"></a>d. 应用层</h5><p>纯业务逻辑，协调下层服务</p><h4 id="3-五层架构"><a href="#3-五层架构" class="headerlink" title="3.五层架构"></a>3.五层架构</h4><p>当业务逻辑变得极其复杂，包含大量的状态、规则和核心算法时，我们会发现应用层变得过于臃肿。这时，我们需要将核心的、与外部完全无关的业务规则独立出来，形成一个新的层次——<strong>领域模型层</strong>。</p><h5 id="a-硬件驱动层-1"><a href="#a-硬件驱动层-1" class="headerlink" title="a. 硬件驱动层"></a>a. 硬件驱动层</h5><h5 id="b-硬件抽象层-1"><a href="#b-硬件抽象层-1" class="headerlink" title="b. 硬件抽象层"></a>b. 硬件抽象层</h5><h5 id="c-功能模块层-1"><a href="#c-功能模块层-1" class="headerlink" title="c. 功能模块层"></a>c. 功能模块层</h5><p>提供基础服务，如传感器数据融合、GPS解析、RC指令解码等。</p><h5 id="d-领域模型层"><a href="#d-领域模型层" class="headerlink" title="d. 领域模型层"></a>d. 领域模型层</h5><p>系统的核心。包含核心业务实体、状态机和算法。这一层应该是纯的、平台无关的，可以被任何语言（C&#x2F;C++&#x2F;Python）实现。</p><h5 id="e-应用协调层"><a href="#e-应用协调层" class="headerlink" title="e.应用协调层"></a>e.应用协调层</h5><p>协调任务，处理外部事件。如接收遥控器信号、处理地面站指令、触发飞行模式切换。它不包含核心飞行规则。</p><h4 id="4-六层架构"><a href="#4-六层架构" class="headerlink" title="4.六层架构"></a>4.六层架构</h4><p>六层架构通常出现在大型系统或需要提供明确API给第三方开发的场景中。它通过在应用层之上再抽象一层，提供一个清晰的、稳定的、版本化的接口。</p><h5 id="a-硬件驱动层-2"><a href="#a-硬件驱动层-2" class="headerlink" title="a. 硬件驱动层"></a>a. 硬件驱动层</h5><h5 id="b-硬件抽象层-2"><a href="#b-硬件抽象层-2" class="headerlink" title="b. 硬件抽象层"></a>b. 硬件抽象层</h5><h5 id="c-功能模块层-2"><a href="#c-功能模块层-2" class="headerlink" title="c. 功能模块层"></a>c. 功能模块层</h5><h5 id="d-领域模型层-1"><a href="#d-领域模型层-1" class="headerlink" title="d. 领域模型层"></a>d. 领域模型层</h5><h5 id="e-应用协调层-1"><a href="#e-应用协调层-1" class="headerlink" title="e.应用协调层"></a>e.应用协调层</h5><h5 id="f-API层"><a href="#f-API层" class="headerlink" title="f.API层"></a>f.API层</h5><p>对外提供统一的访问接口。可以是RESTful API、gRPC、MQTT主题，或者简单的函数库接口。负责协议转换、版本管理、权限校验。</p><h4 id="5-本人rm时期的工程机器人的架构（仅作参考）"><a href="#5-本人rm时期的工程机器人的架构（仅作参考）" class="headerlink" title="5.本人rm时期的工程机器人的架构（仅作参考）"></a>5.本人rm时期的工程机器人的架构（仅作参考）</h4><p>工程机器人嵌入式软件系统架构分为 6 层。下面从顶层到底层分别介绍。</p><ol><li><p>应用层：包括 CAN 中断回调函数、 USB 回调函数、 UART 回调函数、定时器回调函数、主循环的具体实现。</p></li><li><p>功能模块层：用类的方式实现各个功能模块的参数和成员函数。包括底盘、云台、机械臂。底盘包括麦轮速度解算等、轮速控制 PID 等。云台包括控制图传模块航向和俯仰的相关成员函数。</p></li><li><p>硬件驱动层：用类的方式实现各个硬件的驱动。包括 A 板开关电源的驱动程序、 M3508电机的驱动程序、达妙 4310 电机驱动程序、遥控器驱动程序和裁判系统驱动程序。包含发送命令、接收反馈、数据处理、 PID 计算等功能。</p></li><li><p>中间件层：包含 PID 算法的功能包（类）以及自定义数学运算（如矩阵运算、限幅函数、大小端转换等）。</p></li><li><p>硬件抽象层：对 HAL 库中 CAN、 UART 等单片机外设库的重新封装。</p></li><li><p>HAL 库：由 stm32cubeMX 生成的开发者库。</p></li></ol><h3 id="三、层级之间的“连接”架构模型"><a href="#三、层级之间的“连接”架构模型" class="headerlink" title="三、层级之间的“连接”架构模型"></a>三、层级之间的“连接”架构模型</h3><h4 id="1-生产者-消费者模型（数据流控制）"><a href="#1-生产者-消费者模型（数据流控制）" class="headerlink" title="1.生产者-消费者模型（数据流控制）"></a>1.生产者-消费者模型（数据流控制）</h4><p>硬件层提供生产者ISR负责数据采集，中间件层提供消息队列负责数据协调，应用层提供消费者任务负责数据处理，这样分层实现了</p><ul><li>解耦：生产者和消费者可以独立变化</li><li>并发：生产和消费可以并行执行</li><li>流量控制：缓冲区满时生产者阻塞，空时消费者阻塞</li></ul><h4 id="2-工厂模式（对象生命周期管理）"><a href="#2-工厂模式（对象生命周期管理）" class="headerlink" title="2.工厂模式（对象生命周期管理）"></a>2.工厂模式（对象生命周期管理）</h4><p>工厂模型多了一个工厂层，通过创建函数类很方便地实现了C语言下的多态的实现（个人简单的理解，不知道准不准确，因为我没用过）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">实际案例：智能家居设备管理<br><span class="hljs-comment">// device_manager.c (应用层)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manage_devices</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">device_factory_t</span> factories[] = &#123;<br>        &amp;sensor_factory,      <span class="hljs-comment">// 中间件层工厂</span><br>        &amp;actuator_factory,    <span class="hljs-comment">// 中间件层工厂</span><br>        &amp;display_factory      <span class="hljs-comment">// HAL层工厂</span><br>    &#125;;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-type">device_t</span>* dev = factories[i]-&gt;<span class="hljs-built_in">create</span>();<br>        dev-&gt;<span class="hljs-built_in">init</span>();<br>        registered_devices[i] = dev;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// HAL层具体工厂</span><br><span class="hljs-function"><span class="hljs-type">device_t</span>* <span class="hljs-title">display_factory_create</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">display_device_t</span> disp_dev;<br>    <span class="hljs-built_in">oled_init</span>(&amp;disp_dev);  <span class="hljs-comment">// 硬件层初始化</span><br>    <span class="hljs-keyword">return</span> &amp;disp_dev.base;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种分层工厂设计，系统获得以下特性：</p><ul><li>硬件更换只需修改工厂实现</li><li>新增设备类型只需扩展工厂接口</li><li>各层级之间的依赖关系清晰可见</li><li>运行时动态检测硬件成为可能</li></ul><h4 id="3-发布-订阅模型"><a href="#3-发布-订阅模型" class="headerlink" title="3.发布-订阅模型"></a>3.发布-订阅模型</h4><p>硬件层提供发布者，中间件层提供事件总线，应用层提供订阅者</p><ul><li><strong>动态响应</strong>：订阅者可随时注册&#x2F;注销</li><li><strong>广播通信</strong>：一个事件可触发多个处理流程</li><li><strong>松耦合</strong>：发布者无需知道订阅者存在</li></ul><h4 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4. 代理模式"></a>4. 代理模式</h4><p>硬件层提供实际服务，中间件层提供代理接口，应用层提供客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 中间件层：网络代理接口</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">bool</span> (*send)(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">uint16_t</span> len);<br>    <span class="hljs-type">bool</span> (*receive)(<span class="hljs-type">uint8_t</span>* buf, <span class="hljs-type">uint16_t</span>* len);<br>&#125; <span class="hljs-type">network_proxy_t</span>;<br><br><span class="hljs-comment">// 硬件层：实际实现（WiFi驱动）</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">wifi_send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">uint16_t</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> WiFi_Transmit(data, len);<br>&#125;<br><br><span class="hljs-comment">// 应用层：客户端</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">send_telemetry</span><span class="hljs-params">(<span class="hljs-type">network_proxy_t</span>* proxy)</span> &#123;<br>    <span class="hljs-type">uint8_t</span> data[] = &#123;<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>&#125;;<br>    proxy-&gt;send(data, <span class="hljs-keyword">sizeof</span>(data)); <span class="hljs-comment">// 通过代理发送</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>访问控制</strong>：代理可添加权限检查</li><li><strong>延迟初始化</strong>：实际硬件按需初始化</li><li><strong>远程访问</strong>：代理可跨处理器通信（如协处理器）</li></ul><h4 id="5-门面模式"><a href="#5-门面模式" class="headerlink" title="5. 门面模式"></a>5. 门面模式</h4><ul><li>统一接口（门面）</li><li>子系统集合（各硬件模块）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 中间件层：系统门面</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span> (*power_on)(<span class="hljs-type">void</span>);<br>    <span class="hljs-type">void</span> (*enter_low_power)(<span class="hljs-type">void</span>);<br>    <span class="hljs-type">void</span> (*get_sensor_data)(<span class="hljs-type">sensor_data_t</span>*);<br>&#125; <span class="hljs-type">system_facade_t</span>;<br><br><span class="hljs-comment">// 子系统整合</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">system_power_on</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    PMIC_Enable();<br>    Sensor_Init();<br>    Wireless_Start();<br>&#125;<br><br><span class="hljs-comment">// 应用层：通过门面操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">system_facade_t</span> sys = &#123;<br>        .power_on = system_power_on,<br>        <span class="hljs-comment">// ...其他操作</span><br>    &#125;;<br>    sys.power_on();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>简化接口</strong>：隐藏子系统的复杂性</li><li><strong>降低依赖</strong>：应用层只依赖门面接口</li><li><strong>集中管理</strong>：子系统变化不影响上层</li></ul><h4 id="6-管道-过滤器模式"><a href="#6-管道-过滤器模式" class="headerlink" title="6. 管道-过滤器模式"></a>6. 管道-过滤器模式</h4><ul><li>数据源（硬件层）</li><li>过滤器链（中间件层）</li><li>数据接收端（应用层）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 中间件层：过滤器接口</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">data_filter_t</span>)</span><span class="hljs-params">(<span class="hljs-type">float</span>* data)</span></span>;<br><br><span class="hljs-comment">// 过滤器链</span><br><span class="hljs-type">data_filter_t</span> filters[] = &#123;<br>    moving_average_filter,<br>    temperature_compensate,<br>    scale_to_engineering_units<br>&#125;;<br><br><span class="hljs-comment">// 应用层：处理流水线</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_pipeline</span><span class="hljs-params">(<span class="hljs-type">float</span> raw_data)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) &#123;<br>        filters[i](&amp;raw_data); <span class="hljs-comment">// 数据依次通过各过滤器</span><br>    &#125;<br>    <span class="hljs-built_in">display_data</span>(raw_data);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>模块化处理</strong>：每个过滤器独立可替换</li><li><strong>灵活重组</strong>：可动态调整过滤器顺序</li><li><strong>并行处理</strong>：不同过滤器可运行在不同核上</li></ul><h4 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7. 适配器模式"></a>7. 适配器模式</h4><ul><li>目标接口（应用层期望的）</li><li>适配器（中间件层）</li><li>被适配者（硬件层）</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 应用层：期望的通用传感器接口</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-built_in">float</span> (*read)(<span class="hljs-type">void</span>);<br>&#125; <span class="hljs-type">sensor_t</span>;<br><br><span class="hljs-comment">// 硬件层：特定传感器（不兼容接口）</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">DS18B20_ReadTemp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 返回原始整型温度值</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>)<span class="hljs-built_in">DS18B20_Read_Raw</span>();<br>&#125;<br><br><span class="hljs-comment">// 中间件层：适配器</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">ds18b20_adapter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">float</span> temp = <span class="hljs-built_in">DS18B20_ReadTemp</span>();<br>    <span class="hljs-keyword">return</span> temp / <span class="hljs-number">16.0f</span>; <span class="hljs-comment">// 转换为实际温度值</span><br>&#125;<br><br><span class="hljs-comment">// 使用适配器</span><br><span class="hljs-type">sensor_t</span> temp_sensor = &#123;<br>    .read = ds18b20_adapter<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>接口转换</strong>：使不兼容的接口能协同工作</li><li><strong>遗留代码复用</strong>：适配旧硬件驱动</li><li><strong>多平台支持</strong>：同一接口适配不同实现</li></ul><h3 id="四、使用draw-io或配合cursor-ai画架构图或UML图"><a href="#四、使用draw-io或配合cursor-ai画架构图或UML图" class="headerlink" title="四、使用draw.io或配合cursor ai画架构图或UML图"></a>四、使用draw.io或配合cursor ai画架构图或UML图</h3><h4 id="draw-io的下载"><a href="#draw-io的下载" class="headerlink" title="draw.io的下载"></a>draw.io的下载</h4><p>draw.io有网页端，桌面端，也可以在vscode这样的开发工具中通过插件方式使用</p><p>draw.io桌面端是开源免费的，这里给出下载网址<a href="https://github.com/jgraph/drawio-desktop/releases">Releases · jgraph&#x2F;drawio-desktop</a></p><p>根据电脑自身系统下载对应的最新版本，我是windows系统，直接点击windows installer下载或下载如下图所示的文件</p><img src="/2025/09/19/%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%92%8C%E5%88%86%E5%B1%82%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/2ff7c3c44b16d3895549a51466c6f193.png" class=""><p>下载过程没什么坑，改下安装路径即可，如果需要桌面上的快捷方式需要手动创建</p><h4 id="在vscode中通过插件方式配合cursor使用（无需下载draw-io本体）"><a href="#在vscode中通过插件方式配合cursor使用（无需下载draw-io本体）" class="headerlink" title="在vscode中通过插件方式配合cursor使用（无需下载draw.io本体）"></a>在vscode中通过插件方式配合cursor使用（无需下载draw.io本体）</h4><p>在vscode中的拓展安装Draw.io Integration插件</p><p>在vscode中新建.drawio文件，然后最好改一下颜色主题，深色完全看不清</p><p>向Cursor描述你的需求：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">请帮我生成一个微服务架构图，包含：<br><span class="hljs-bullet">- </span>API网关<br><span class="hljs-bullet">- </span>用户服务<br><span class="hljs-bullet">- </span>订单服务<br><span class="hljs-bullet">- </span>支付服务<br><span class="hljs-bullet">- </span>数据库集群<br>使用Mermaid语法<br></code></pre></td></tr></table></figure><p>然后将得到的代码按如下图方式插入到draw.io中</p><img src="/2025/09/19/%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%92%8C%E5%88%86%E5%B1%82%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/64c62b5b-66ce-433a-a970-ef3fc867a339.png" class=""><p>最终结果</p><img src="/2025/09/19/%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%92%8C%E5%88%86%E5%B1%82%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/e82700be-d5ed-49e4-a5d3-92a74bbb795e.png" class="">]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于一些特殊中断的思考</title>
    <link href="/2025/09/12/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E4%B8%AD%E6%96%AD%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2025/09/12/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E4%B8%AD%E6%96%AD%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="关于一些特殊中断的思考"><a href="#关于一些特殊中断的思考" class="headerlink" title="关于一些特殊中断的思考"></a>关于一些特殊中断的思考</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>​    最近有一起实习的同学问我PendSV中断在FreeRTOS运行过程中是否会“堆积”导致任务调度失败，答案当然是不会。</p><img src="/2025/09/12/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E4%B8%AD%E6%96%AD%E7%9A%84%E6%80%9D%E8%80%83/8489ad8d-8788-4bee-99c0-343256293873.png" class=""><p>​    这是因为当有任务需要调度时，PendSV中断并不会直接抢占，而是先被systick挂起，由于PendSV中断通常设置为最低优先级，所以在systick中断结束后还需要看是否有其他高优先级的中断需要执行，然后最后才会在空闲时轮到PendSV中断。那么这个期间PendSV可能会被多次触发，也就会做多次标记挂起操作，而这其实跟一次标记挂起没什么区别，并不会多次入栈。而执行PendSV时只执行一次上下文切换，合并所有待处理调度请求。</p><p>​    所以我们可以看出这套PendSV中断的架构精髓其实在于挂起这个操作，于是我突发奇想，还有没有中断也是像PendSV中断一样先挂起后执行的。然后我找了一下相关资料发现，<strong>有的兄弟，有的</strong>，像PendSV这样的中断还有很多。</p><h3 id="通信协议相关的中断"><a href="#通信协议相关的中断" class="headerlink" title="通信协议相关的中断"></a>通信协议相关的中断</h3><ul><li><h6 id="DMA完成中断"><a href="#DMA完成中断" class="headerlink" title="DMA完成中断"></a>DMA完成中断</h6><p>DMA传输完成时产生中断，但可能被配置为批量处理，多个DMA完成中断合并为一个延迟处理，减少中断开销，提高吞吐量</p></li><li><h6 id="以太网MAC的RX-TX中断"><a href="#以太网MAC的RX-TX中断" class="headerlink" title="以太网MAC的RX&#x2F;TX中断"></a>以太网MAC的RX&#x2F;TX中断</h6><p>使用NAPI机制，中断被挂起，切换到轮询模式处理多个数据包，减少中断频率，提高网络性能</p></li></ul><h3 id="可挂起的系统异常"><a href="#可挂起的系统异常" class="headerlink" title="可挂起的系统异常"></a>可挂起的系统异常</h3><ul><li><h6 id="SVCall（SV异常）"><a href="#SVCall（SV异常）" class="headerlink" title="SVCall（SV异常）"></a>SVCall（SV异常）</h6><p>超级用户调用，是ARM Cortex-M的一个架构，通常设计为在特定条件下才立即响应，用于实现系统调用。它是在用户态（非特权级）的应用程序代码请求内核态（特权级）操作系统服务的标准机制。通过SVC指令（汇编）配合立即数触发具体的系统服务，然后CPU会完成压栈，更新寄存器，取向量，跳转执行SVC异常处理程序等一系列操作</p></li><li><h6 id="UsageFault，MemManage，BusFault"><a href="#UsageFault，MemManage，BusFault" class="headerlink" title="UsageFault，MemManage，BusFault"></a>UsageFault，MemManage，BusFault</h6><p>这些故障异常通常优先级很高，但是如果使能了“延迟故障处理”特性时，某些内存访问故障可能被挂起</p></li></ul><h3 id="外部中断的特殊模式"><a href="#外部中断的特殊模式" class="headerlink" title="外部中断的特殊模式"></a>外部中断的特殊模式</h3><ul><li><h6 id="电平触发中断"><a href="#电平触发中断" class="headerlink" title="电平触发中断"></a>电平触发中断</h6><p>中断信号必须保持有效直到ISR开始执行，如果中断被屏蔽，请求会持续挂起，直到解除屏蔽</p></li><li><h6 id="后期到达中断"><a href="#后期到达中断" class="headerlink" title="后期到达中断"></a>后期到达中断</h6><p>这个是ARM Cortex-M的一个特性，当处理器正在处理中断入口时，新到达的更高优先级中断会被记录但延迟处理，直到当前中断入口序列完成后再评估抢占</p></li></ul><h3 id="处理器特定的挂起机制"><a href="#处理器特定的挂起机制" class="headerlink" title="处理器特定的挂起机制"></a>处理器特定的挂起机制</h3><ul><li><h6 id="x86的APIC"><a href="#x86的APIC" class="headerlink" title="x86的APIC"></a>x86的APIC</h6><p>支持中断优先级和重定向；低优先级中断可能被挂起，直到高优先级任务完成；TPR可动态屏蔽特定优先级范围的中断；</p></li><li><h6 id="RISC-V的CLIC"><a href="#RISC-V的CLIC" class="headerlink" title="RISC-V的CLIC"></a>RISC-V的CLIC</h6><p>支持中断挂起和优先级阈值配置；可配置某些中断为非抢占模式；</p></li></ul><p>其实写到这里我就发现挂起作为中断的一种状态，其实先挂起后运行并不是一种特殊现象，而是中断的一种常规用法，哈哈，写都写了，先这样吧。</p><h3 id="额外思考"><a href="#额外思考" class="headerlink" title="额外思考"></a>额外思考</h3><ul><li><h6 id="像PendSV中断这样的挂起和OS任务的挂起有什么区别？"><a href="#像PendSV中断这样的挂起和OS任务的挂起有什么区别？" class="headerlink" title="像PendSV中断这样的挂起和OS任务的挂起有什么区别？"></a>像PendSV中断这样的挂起和OS任务的挂起有什么区别？</h6><p>PendSV的挂起操作属于硬件中断层，是通过设置SCB-&gt;ICSR寄存器的PENDSVSET位实现的，目的就是为了延迟上下文切换，确保高优先级中断能及时响应。而OS任务挂起操作属于任务管理层，是通过OS提供的API为了任务管理而实现的，调用后任务会临时停止直到调用API恢复，这种任务状态的迁移不参与任务的调度。</p></li><li><h6 id="freertos中中断优先级肯定比任务优先级高吗？"><a href="#freertos中中断优先级肯定比任务优先级高吗？" class="headerlink" title="freertos中中断优先级肯定比任务优先级高吗？"></a>freertos中中断优先级肯定比任务优先级高吗？</h6><p>针对这个问题，首先得知道freertos的一个概念：中断屏蔽范围。这个是freertos的一个可设置项，用于定义可屏蔽的中断优先级范围。为了不搞混中断优先级和任务优先级，先说明中断优先级0-15，优先级数值越大，优先级越低，而任务优先级0-15，优先级数值越大，优先级越高。中断屏蔽范围通常从0开始，到设定值例如5，那么0-5优先级的中断都会直接被OS屏蔽。</p><p>现在有两个问题：</p><p>1.被屏蔽的中断在任务运行时能进行抢占吗；</p><p>2.为什么不屏蔽低优先级中断反而屏蔽高优先级中断；</p><p>针对第一个问题，首先答案是不能。从字面意思上看，中断都被os屏蔽了，那肯定影响不到os的任务啊。具体来讲，被屏蔽的中断触发时，中断信号会被CPU接收，但不会立即执行，CPU会将中断请求挂起，直到屏蔽解除（RTOS退出临界区或离开调度器锁定的代码段），CPU开始从被挂起的最高优先级中断开始执行。为什么os要这么设计呢，其实是考虑到为了平衡实时性和安全性，因为0-5优先级的中断通常仅处理硬件紧急事件（比如NMI和HardFault），不能依赖RTOS，而6-15优先级的中断一般与外设有关，并且需要与OS交互，所以不能屏蔽，这也解释了第二个问题。未被屏蔽的中断抢占权高于所有OS任务（中断硬件优先级需高于CPU优先级）。</p><p>通过这个问题我们也发现了，如果用了freertos，那么0-5中断就不要用于外设了。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股大杂烩</title>
    <link href="/2025/09/05/%E5%85%AB%E8%82%A1%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <url>/2025/09/05/%E5%85%AB%E8%82%A1%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="八股大杂烩"><a href="#八股大杂烩" class="headerlink" title="八股大杂烩"></a>八股大杂烩</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h5 id="1-裸机和RTOS如何选择"><a href="#1-裸机和RTOS如何选择" class="headerlink" title="1.裸机和RTOS如何选择"></a><a href="#####1.%E8%A3%B8%E6%9C%BA%E5%92%8CRTOS%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">1.裸机和RTOS如何选择</a></h5><p><a href="#####2.RTOS%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%9E%E6%97%B6%E6%80%A7">2.RTOS如何保证实时性</a></p><p><a href="#####3.FreeRTOS%E6%BA%90%E7%A0%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">3.FreeRTOS源码如何实现任务调度</a></p><p><a href="#####4.FreeRTOS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2">4.FreeRTOS如何实现任务切换</a></p><p><a href="#####5.%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E8%83%BD%E9%A9%B1%E5%8A%A8%E5%87%A0%E8%B7%AF%E7%94%B5%E6%9C%BA">5.怎么判断能驱动几路电机</a></p><p><a href="#####6.%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%BB%E9%A2%91%E8%83%BD%E5%B8%A6%E5%8A%A8%E5%A4%9A%E5%B0%91%E7%94%B5%E6%9C%BA">6.如何判断主频能带动多少电机</a></p><p><a href="#####7.%E6%91%84%E5%83%8F%E5%A4%B4%E9%A9%B1%E5%8A%A8%E5%BA%95%E5%B1%82%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E9%A9%B1%E5%8A%A8%E9%94%99%E8%AF%AF">7.摄像头驱动底层，如何检测驱动错误</a></p><p><a href="#####8.%E5%A6%82%E6%9E%9C%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A512C%E9%A9%B1%E5%8A%A8">8.如果打印日志，如何根据日志排查12C驱动</a></p><p><a href="#####9.12C%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%97%B6%E5%BA%8F">9.12C驱动的时序</a></p><p><a href="#####10.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%B4%E6%96%87%E4%BB%B6">10.为什么需要头文件</a></p><p><a href="#####11.%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%B0%96%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%86%99%E5%BC%95%E5%85%A5%E7%9A%84%E9%A1%BA%E5%BA%8F">11.头文件分尖括号和双引号，应该如何写引入的顺序</a></p><p><a href="#####12.%E5%B0%B1%E6%98%AF%E8%A6%81%E5%85%88%E5%86%99%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%86%8D%E5%86%99%E5%B0%96%E6%8B%AC%E5%8F%B7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88">12.就是要先写双引号再写尖括号，为什么</a></p><p><a href="#####13.float%E5%8F%AF%E4%BB%A5%E7%A7%BB%E4%BD%8D%E5%90%97">13.float可以移位吗</a></p><p><a href="#####14.%E5%B0%B1%E6%98%AF%E8%A6%81float%E7%A7%BB%E4%BD%8D%E6%80%8E%E4%B9%88%E5%8A%9E(%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%8C%87%E9%92%88%E5%BC%BA%E8%BD%AC)">14.就是要float移位怎么办(可以用指针强转)</a></p><p><a href="#####15.new%E5%92%8Cmalloc">15.new和malloc</a></p><p>[16.FreeRTOS 任务调度的底层实现了解吗?](#####16.FreeRTOS 任务调度的底层实现了解吗?)</p><p>[17.STM32 单片机项目，为什么要使用消息队列可以用其他方式代替吗?](#####17.STM32 单片机项目，为什么要使用消息队列可以用其他方式代替吗?)</p><p><a href="#####18.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E8%A6%81%E4%BC%A0%E8%BE%93%E5%A4%A7%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0?">18.多线程之间要传输大量的数据，如何实现?</a></p><p><a href="#####19.dma%E7%9A%84%E6%9E%B6%E6%9E%84">19.dma的架构?</a></p><p><a href="#####20.%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">20.信号量和互斥锁的具体底层实现机制</a></p><p><a href="#####21.%E5%A0%86(Heap)%E5%92%8C%E6%A0%88(Stack)%E7%9A%84%E6%A6%82%E5%BF%B5">21.堆(Heap)和栈(Stack)的概念</a></p><p><a href="#####22.%E5%9C%A8%E8%A3%B8%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%88%96RTOS%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E9%AB%98%E6%95%88%E4%B8%94%E5%87%86%E7%A1%AE%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%88%96%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6?%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%9E%E9%99%85%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%90%8E%E6%A3%80%E6%9F%A5%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8%E9%87%8F?">22.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度?如何在实际运行一段时间后检查栈的使用量?</a></p><p><a href="#####23.%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E6%A0%88%E7%9A%84%E5%86%85%E5%AE%B9%E4%BC%9A%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98?">23.在哪些情况下栈的内容会发生改变?</a></p><p><a href="#####24.CPU%E5%9C%A8%E8%BF%9B%E8%A1%8C%E7%8E%B0%E5%9C%BA%E4%BF%9D%E5%AD%98(%E5%A6%82%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E3%80%81%E4%B8%AD%E6%96%AD%E5%8F%91%E7%94%9F%E6%97%B6)%E6%97%B6%EF%BC%8C%E5%85%B7%E4%BD%93%E4%BF%9D%E5%AD%98%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF?">24.CPU在进行现场保存(如函数嵌套调用、中断发生时)时，具体保存哪些信息?</a></p><p><a href="#####25.%E5%BD%93%E7%B3%BB%E7%BB%9F%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8(%E4%BE%8B%E5%A6%82%E8%BF%9B%E5%85%A5HardFault)%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90??">25.当系统发生异常(例如进入HardFault)时，如何定位问题的根源?</a></p><p><a href="#####26.%E8%AF%B7%E6%8F%8F%E8%BF%B0MCU%E4%BB%8E%E9%80%9A%E7%94%B5%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8Cmain%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B">26.请描述MCU从通电启动到执行main函数的过程</a></p><p><a href="#####27.PendSV">27.PendSV</a></p><p><a href="#####28.%E4%B8%B2%E5%8F%A3%EF%BC%8Cspi%EF%BC%8Ci2c%EF%BC%8Ccan%E8%BF%99%E4%BA%9B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">28.串口，spi，i2c，can这些如何选择</a></p><p><a href="#####29.%E5%BD%93DMA%E4%BC%A0%E8%BE%93%E5%85%A8%E6%BB%A1%E4%B8%AD%E6%96%AD(Ful)%E5%92%8C%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD(ldle)%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%E5%90%8C%E6%97%B6%E6%BB%A1%E8%B6%B3%E6%97%B6%EF%BC%8C%E4%B8%A4%E8%80%85%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97%E4%BD%8D%E4%BC%9A%E5%90%8C%E6%97%B6%E7%BD%AE%E4%BD%8D%E5%B9%B6%E8%A7%A6%E5%8F%91%E4%B8%AD%E6%96%AD%E5%90%97?">29.当DMA传输全满中断(Ful)和串口空闲中断(ldle)的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗?</a></p><p><a href="#####30.%E5%BE%AE%E7%A7%92%E7%BA%A7%E5%BB%B6%E6%97%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">30.微秒级延时如何实现</a></p><p><a href="#####31.%E5%9C%A8I2C%E9%80%9A%E4%BF%A1%E4%B8%AD%EF%BC%8C%E6%97%B6%E5%BA%8F%E6%89%80%E9%9C%80%E7%9A%84%E5%BB%B6%E6%97%B6%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84?">31.在I2C通信中，时序所需的延时是如何保证的?</a></p><p><a href="#####32.static,const,volatile%E4%BD%9C%E7%94%A8">32.static,const,volatile作用</a></p><p><a href="#####33.%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FI2C%E6%97%B6%EF%BC%8CCPU%E5%9B%A0%E5%A4%9A%E6%AC%A1%E5%BB%B6%E6%97%B6%E8%80%8C%E8%A2%AB%E9%98%BB%E5%A1%9E%EF%BC%8C%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E8%BF%99%E4%BA%9B%E5%BB%B6%E6%97%B6%E5%8F%91%E7%94%9F%E6%BB%9E%E5%90%8E%E3%80%82%E8%BF%99%E7%A7%8D%E6%BB%9E%E5%90%8E%E5%AF%B9I2C%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D%E5%90%97?">33.软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗?</a></p><p><a href="#####34.I2C%E7%9A%84%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7(SCL)%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E4%B8%8D%E5%9D%87%E5%8C%80(%E5%8D%A0%E7%A9%BA%E6%AF%94%E4%B8%8D%E4%B8%80%E8%87%B4%E6%88%96%E9%A2%91%E7%8E%87%E6%8A%96%E5%8A%A8)%EF%BC%8C%E4%BC%9A%E5%AF%B9%E9%80%9A%E4%BF%A1%E9%80%A0%E6%88%90%E5%BD%B1%E5%93%8D%E5%90%97?">34.I2C的时钟信号(SCL)如果出现不均匀(占空比不一致或频率抖动)，会对通信造成影响吗?</a></p><p><a href="#####35.%E8%AF%B7%E5%88%86%E4%BA%AB%E4%BD%A0%E4%BD%BF%E7%94%A8cmbacktrace%E5%B7%A5%E5%85%B7%E5%AE%9A%E4%BD%8D%E5%B9%B6%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%A1%88%E4%BE%8B">35.请分享你使用cmbacktrace工具定位并解决实际问题的具体案例</a></p><p><a href="#####36.%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E6%93%8D%E4%BD%9C%E6%98%AF%E5%90%A6%E5%BF%85%E7%84%B6%E5%AF%BC%E8%87%B4Hardfault%E5%BC%82%E5%B8%B8?%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%BC%95%E5%8F%91Hardfault%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%85%B6%E4%BB%96%E4%B8%8D%E8%89%AF%E5%90%8E%E6%9E%9C?">36.数组越界操作是否必然导致Hardfault异常?如果不引发Hardfault，可能会带来哪些其他不良后果?</a></p><p><a href="#####37.%E5%9C%A8Bootloader%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%B3%E9%97%ADDMA%E5%90%97?">37.在Bootloader跳转到应用程序的过程中，需要关闭DMA吗?</a></p><p><a href="#####38.%E6%A0%87%E5%87%86%E7%9A%84UART%E9%80%9A%E4%BF%A1%E5%8F%AA%E9%9C%80%E8%A6%81TX%E3%80%81RX%E4%B8%A4%E6%A0%B9%E7%BA%BF%E5%B0%B1%E5%A4%9F%E4%BA%86%E3%80%82%E4%BD%86%E5%9C%A8%E4%B8%80%E4%BA%9B%E9%AB%98%E9%80%9F%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81RTS/CTS%E8%BF%99%E4%B8%A4%E6%A0%B9%E6%B5%81%E6%8E%A7%E7%BA%BF?%E5%AE%83%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84?">38.标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS&#x2F;CTS这两根流控线?它们是怎么解决问题的?</a></p><p><a href="#####39.SPI%E9%80%9A%E4%BF%A1%E6%97%B6%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%92%8C%E4%BB%8E%E8%AE%BE%E5%A4%87%E6%97%B6%E9%92%9F%E6%9E%81%E6%80%A7%E9%85%8D%E7%BD%AE%E5%8F%8D%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">39.SPI通信时主设备和从设备时钟极性配置反了会发生什么</a></p><p><a href="#####40.%E4%B8%AD%E6%96%AD%E4%B8%AD%E8%83%BD%E5%90%A6%E8%8E%B7%E5%8F%96%E9%94%81">40.中断中能否获取锁</a></p><p><a href="#####41.stm32%E5%86%85%E9%83%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AF%84%E5%AD%98%E5%99%A8">41.stm32内部有哪些寄存器</a></p><p>[42.结构体内存对齐 为什么有这种对齐方式](#####42.结构体内存对齐 为什么有这种对齐方式)</p><p>[43.无锁操作 原子操作的底层](#####43.无锁操作 原子操作的底层)</p><p>[44.什么情况下不能使用Cache?在使用DMA的情况下，Cache flush和Cachelonq哪种方式运行效率更高，为什么?](#####44.什么情况下不能使用Cache?在使用DMA的情况下，Cache flush和Cachelonq哪种方式运行效率更高，为什么?)</p><p><a href="#####45.%E5%A6%82%E6%9E%9C%E7%94%A8SPI%E5%BE%80%E5%B1%8F%E4%B8%8A%E5%88%B7%E4%B8%80%E4%B8%AA%E5%83%8F%E7%B4%A0%E7%82%B9%EF%BC%8C%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9CSPI?">45.如果用SPI往屏上刷一个像素点，怎么操作SPI?</a></p><p><a href="#####46.%E4%BB%8E%E6%9C%BA%E6%97%A0%E5%93%8D%E5%BA%94%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86?">46.从机无响应的时候，如何做异常处理?</a></p><p><a href="#####47.%E9%A1%B9%E7%9B%AE%E4%B8%ADDMA%E9%85%8D%E5%90%88%E4%BB%80%E4%B9%88%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8%E7%9A%84?%E7%BB%99%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E7%94%A8USART%E9%85%8D%E5%90%88DMA%E5%AE%8C%E6%88%90%E4%BC%A0%E8%BE%93?%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%BC%A0%E8%BE%93%E5%AE%8C%E6%88%90?">47.项目中DMA配合什么外设使用的?给一个不定长的数据怎么用USART配合DMA完成传输?怎么判断传输完成?</a></p><p><a href="#####48.%E4%B8%AD%E6%96%AD%E6%A0%88%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB?%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C?">48.中断栈和任务栈有什么区别?保存在哪里?</a></p><p><a href="#####49.%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%AA%E6%9C%89systick%E4%B8%AD%E6%96%AD%EF%BC%8C%E4%B8%8D%E7%94%A8pensv%E5%90%97?pensv%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF?">49.要实现任务调度，可以只有systick中断，不用pensv吗?pensv有什么优势?</a></p><p><a href="#####50.%E4%BB%BB%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F?">50.任务间通信方式?</a></p><p><a href="#####51.IAP%E5%8D%87%E7%BA%A7%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C?">51.IAP升级做了什么工作?</a></p><p><a href="#####52.%E5%86%85%E5%AD%98%E8%B8%A9%E8%B8%8F%E4%B8%A5%E9%87%8D%E8%B0%83%E7%94%A8%E6%A0%88%E7%8E%B0%E5%9C%BA%E7%A0%B4%E5%9D%8F%E4%B8%A5%E9%87%8D%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98?">52.内存踩踏严重调用栈现场破坏严重的情况下如何定位问题?</a></p><p><a href="#####53.%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C%E4%B8%B4%E7%95%8C%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF?">53.互斥量，信号量，临界区有什么区别和应用场景?</a></p><p><a href="#####55.%E9%99%80%E8%9E%BA%E4%BB%AA%E9%80%9A%E4%BF%A1%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98?">55.陀螺仪通信时碰到的问题?</a></p><p><a href="#####56.%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88?%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2?">56.嵌入式中内存泄漏和内存碎片的区别是什么?如何预防?</a></p><p><a href="#####57.%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88?RTOS%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%80%E9%94%80?">57.虚函数的实现原理是什么?RTOS中使用它有哪些开销?</a></p><p>[58.SPI和 12℃ 的核心区别有哪些?云台 IMU 选哪种协议更合适?](#####58.SPI和 12℃ 的核心区别有哪些?云台 IMU 选哪种协议更合适?)</p><p>[59.如何通过示波器波形判断 12C 丢包是 SCL拉伸异常还是从设备响应延迟导致?](#####59.如何通过示波器波形判断 12C 丢包是 SCL拉伸异常还是从设备响应延迟导致?)</p><p>[60.FreeRTOS 和 Linux 二者调度算法有何差异?](#####60.FreeRTOS 和 Linux 二者调度算法有何差异?)</p><p>[61.ARM Cortex-M 内核中，如何通过栈回溯定位 HardFault 异常的根本原因?](#####61.ARM Cortex-M 内核中，如何通过栈回溯定位 HardFault 异常的根本原因?)</p><p>[62.Bootloader 双分区备份下，升级断电后如何判断加载原分区还是修复新分区?](#####62.Bootloader 双分区备份下，升级断电后如何判断加载原分区还是修复新分区?)</p><p><a href="#####63.CAN%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81%E5%8E%9F%E7%90%86">63.CAN总线仲裁原理</a></p><p><a href="#####64.%E5%AF%B9%E4%BA%8E%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%A0%B8%E7%9A%84MCU%EF%BC%8C%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97">64..对于有多个核的MCU，内存屏障有了解过吗</a></p><p><a href="#####65.%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B">65.从源码到可执行文件的过程</a></p><p><a href="#####66.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C">66.并发与并行</a></p><p><a href="#####67.%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84">67.代码架构</a></p><h5 id="1-裸机和RTOS如何选择-1"><a href="#1-裸机和RTOS如何选择-1" class="headerlink" title="1.裸机和RTOS如何选择"></a>1.裸机和RTOS如何选择</h5><p>裸机开发：要避免用延时函数，多用时间触发调度器</p><p>优势：无任务切换开销；无RTOS内核，资源占用低；直接运行main，启动速度快；</p><p>RTOS：多任务独立运行；互斥锁&#x2F;信号量安全访问共享资源；动态优先级，紧急任务可抢占；开发效率高</p><p>RTOS实现了高内聚，低耦合</p><h5 id="2-RTOS如何保证实时性"><a href="#2-RTOS如何保证实时性" class="headerlink" title="2.RTOS如何保证实时性"></a>2.RTOS如何保证实时性</h5><ul><li>抢占式调度：高优先级任务可立即抢占低优先级任务的cpu使用权</li><li>优先级翻转与继承</li><li>中断控制器优化：NVIC嵌套中断支持0延迟抢占，</li><li>使用了精确时钟源</li></ul><h5 id="3-FreeRTOS源码如何实现任务调度"><a href="#3-FreeRTOS源码如何实现任务调度" class="headerlink" title="3.FreeRTOS源码如何实现任务调度"></a>3.FreeRTOS源码如何实现任务调度</h5><p>每个任务对应一个 <code>Task Control Block</code>结构体，存储：</p><ul><li>任务栈指针（<code>pxStack</code>）</li><li>任务状态（就绪&#x2F;阻塞&#x2F;挂起）</li><li>优先级（<code>uxPriority</code>）</li><li>任务函数指针（<code>pxTaskFunction</code>）</li><li>任务列表节点（<code>xStateListItem</code>和 <code>xEventListItem</code>）</li></ul><ol><li><p><strong>就绪列表（Ready List）</strong></p><ul><li>按优先级组织的链表数组 <code>pxReadyTasksLists[configMAX_PRIORITIES]</code>，每个优先级一个链表。</li><li>任务创建时根据优先级插入对应链表。</li></ul></li><li><p><strong>阻塞状态</strong></p><ul><li>任务因延时或等待资源时，从就绪列表移至阻塞列表（<code>xDelayedTaskList1/xDelayedTaskList2</code>）。</li><li>通过 <code>vTaskDelay()</code>或信号量&#x2F;队列等API触发。</li></ul></li><li><p><strong>挂起状态</strong></p><ul><li>调用 <code>vTaskSuspend()</code>将任务移至挂起列表（<code>xSuspendedTaskList</code>），不参与调度。</li></ul></li><li><p><strong>抢占式调度（Preemptive）</strong></p><ul><li>高优先级任务就绪时立即抢占当前任务（通过 <code>taskYIELD()</code>或中断中调用 <code>portYIELD_FROM_ISR()</code>）。</li><li>依赖硬件定时器中断（如SysTick）触发 <code>xPortSysTickHandler()</code>。</li></ul></li><li><p><strong>时间片调度（Round-Robin）</strong></p><ul><li>同优先级任务共享CPU时间，通过 <code>configUSE_TIME_SLICING</code>启用。</li></ul></li><li><p><strong>主动触发</strong></p><ul><li>调用 <code>taskYIELD()</code>手动请求调度。</li><li>调用 <code>vTaskDelay()</code>、<code>xQueueSend()</code>等API导致任务状态变化。</li></ul></li><li><p><strong>中断触发</strong></p><ul><li>系统时钟中断（如SysTick）检查阻塞任务超时。</li><li>外设中断释放信号量&#x2F;队列时，调用 <code>xHigherPriorityTaskWoken</code>标记高优先级任务就绪。</li></ul></li><li><p><strong>PendSV 中断</strong></p><ul><li>实际任务切换在低优先级的 <code>PendSV_Handler</code>中完成，避免在外部中断中处理耗时操作。</li><li>通过设置 <code>ICSR.PENDSVSET</code>触发。</li></ul></li><li><p><strong>上下文切换</strong></p><ul><li>保存当前任务寄存器到栈（<code>vPortSVCHandler</code>）。</li><li>从新任务的栈恢复寄存器（<code>pxCurrentTCB</code>指向新任务TCB）。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简化版任务切换流程</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">xPortPendSVHandler</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>) &#123;<br>    <span class="hljs-title function_">save_current_task_context</span>();  <span class="hljs-comment">// 保存旧任务上下文</span><br>    pxCurrentTCB = <span class="hljs-title function_">get_highest_priority_task</span>(); <span class="hljs-comment">// 选择新任务</span><br>    <span class="hljs-title function_">restore_new_task_context</span>();   <span class="hljs-comment">// 恢复新任务上下文</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>静态优先级</strong>：任务创建时指定，运行时不可更改（除非手动修改TCB）。</li><li><strong>优先级继承</strong>：互斥量（<code>xSemaphoreCreateMutex()</code>）可防止优先级反转。</li></ul><ol><li>任务A调用 <code>vTaskDelay(100)</code>进入阻塞状态。</li><li>调度器从就绪列表选择最高优先级任务B运行。</li><li>SysTick 中断发现任务A阻塞到期，将其移回就绪列表。</li><li>若任务A优先级高于B，触发 <code>PendSV</code>切换回任务A。</li></ol><h5 id="5-怎么判断能驱动几路电机"><a href="#5-怎么判断能驱动几路电机" class="headerlink" title="5.怎么判断能驱动几路电机"></a>5.怎么判断能驱动几路电机</h5><ol><li><p>列出MCU的PWM&#x2F;GPIO资源（数据手册查定时器和引脚复用表）。</p></li><li><p>确认驱动芯片支持的路数（如DRV8833&#x3D;2路）。</p></li><li><p>计算电源总电流是否满足（电机峰值电流×路数）。</p></li><li><h5 id="评估软件任务调度能力（FreeRTOS任务数-中断频率）。"><a href="#评估软件任务调度能力（FreeRTOS任务数-中断频率）。" class="headerlink" title="评估软件任务调度能力（FreeRTOS任务数 + 中断频率）。"></a>评估软件任务调度能力（FreeRTOS任务数 + 中断频率）。</h5></li></ol><h5 id="6-如何判断主频能带动多少电机"><a href="#6-如何判断主频能带动多少电机" class="headerlink" title="6.如何判断主频能带动多少电机"></a>6.如何判断主频能带动多少电机</h5><ol><li>确定控制频率（如FOC需10kHz，步进电机需50kHz）。</li><li>计算单路耗时（算法+采样+通信）。</li><li>评估CPU利用率：<ul><li>实时严格模式：<code>N ≤ (控制周期时间 × 可用CPU比例) / 单路耗时</code></li><li>宽松模式：可降低频率或优化算法。</li></ul></li><li>硬件优化：使用FPU&#x2F;DMA&#x2F;多核分担负载。</li></ol><h5 id="7-摄像头驱动底层，如何检测驱动错误"><a href="#7-摄像头驱动底层，如何检测驱动错误" class="headerlink" title="7.摄像头驱动底层，如何检测驱动错误"></a>7.摄像头驱动底层，如何检测驱动错误</h5><h5 id="8-如果打印日志，如何根据日志排查12C驱动"><a href="#8-如果打印日志，如何根据日志排查12C驱动" class="headerlink" title="8.如果打印日志，如何根据日志排查12C驱动"></a>8.如果打印日志，如何根据日志排查12C驱动</h5><h5 id="9-12C驱动的时序"><a href="#9-12C驱动的时序" class="headerlink" title="9.12C驱动的时序"></a>9.12C驱动的时序</h5><h5 id="10-为什么需要头文件"><a href="#10-为什么需要头文件" class="headerlink" title="10.为什么需要头文件"></a>10.为什么需要头文件</h5><ul><li>声明与定义分离</li><li>编译效率优化</li><li>·可以通过头文件控制哪些符号对外可见</li></ul><h5 id="11-头文件分尖括号和双引号，应该如何写引入的顺序"><a href="#11-头文件分尖括号和双引号，应该如何写引入的顺序" class="headerlink" title="11.头文件分尖括号和双引号，应该如何写引入的顺序"></a>11.头文件分尖括号和双引号，应该如何写引入的顺序</h5><p>&lt;&gt;:编译器预设路径     系统库路径</p><p>“”：当前文件所在目录    编译器预设路径</p><h5 id="12-就是要先写双引号再写尖括号，为什么"><a href="#12-就是要先写双引号再写尖括号，为什么" class="headerlink" title="12.就是要先写双引号再写尖括号，为什么"></a>12.就是要先写双引号再写尖括号，为什么</h5><p>双引号一般是本地头文件，尖括号一般是系统&#x2F;第三方头文件</p><p>可以暴露本地头文件的依赖问题</p><p>避免宏污染和名称冲突</p><p>明确模块化设计责任</p><h5 id="13-float可以移位吗"><a href="#13-float可以移位吗" class="headerlink" title="13.float可以移位吗"></a>13.float可以移位吗</h5><p>正常来说不行。</p><h5 id="14-就是要float移位怎么办-可以用指针强转"><a href="#14-就是要float移位怎么办-可以用指针强转" class="headerlink" title="14.就是要float移位怎么办(可以用指针强转)"></a>14.就是要float移位怎么办(可以用指针强转)</h5><p>用数学等效操作；先分离符号，指数，尾数</p><h5 id="15-new和malloc"><a href="#15-new和malloc" class="headerlink" title="15.new和malloc"></a>15.new和malloc</h5><h5 id="16-FreeRTOS-任务调度的底层实现了解吗"><a href="#16-FreeRTOS-任务调度的底层实现了解吗" class="headerlink" title="16.FreeRTOS 任务调度的底层实现了解吗?"></a>16.FreeRTOS 任务调度的底层实现了解吗?</h5><h5 id="17-STM32-单片机项目，为什么要使用消息队列可以用其他方式代替吗"><a href="#17-STM32-单片机项目，为什么要使用消息队列可以用其他方式代替吗" class="headerlink" title="17.STM32 单片机项目，为什么要使用消息队列可以用其他方式代替吗?"></a>17.STM32 单片机项目，为什么要使用消息队列可以用其他方式代替吗?</h5><ol><li><strong>跨任务异步通信</strong></li></ol><ul><li><strong>典型场景</strong>：中断服务程序（ISR）与任务间传递数据</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell">// 中断中发送消息（非阻塞）<br><span class="hljs-title">void</span> <span class="hljs-type">HAL_GPIO_EXTI_Callback</span>(uint16_t <span class="hljs-type">GPIO_Pin</span>) &#123;<br>    uint8_t <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">READ_REG</span>(<span class="hljs-type">GPIO</span>-&gt;<span class="hljs-type">IDR</span>);</span><br>    xQueueSendFromISR(xQueue, &amp;<span class="hljs-class"><span class="hljs-keyword">data</span>, <span class="hljs-type">NULL</span>); </span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优势</strong>：避免全局变量共享带来的竞态风险。</p><ol start="2"><li><strong>数据缓冲与流量控制</strong></li></ol><ul><li><strong>硬件场景</strong>：UART接收不定长数据包</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 串口DMA接收完成后解析</span><br>void <span class="hljs-built_in">vUARTTask</span>(void *pvParameters) &#123;<br>    uint8_t buf<span class="hljs-selector-attr">[128]</span>;<br>    <span class="hljs-built_in">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">xQueueReceive</span>(xUARTQueue, buf, portMAX_DELAY);<br>        <span class="hljs-built_in">parse_packet</span>(buf); <span class="hljs-comment">// 安全处理数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优势</strong>：队列长度 (<code>uxQueueLength</code>) 天然实现背压机制。</p><ol start="3"><li><strong>优先级消息排序</strong></li></ol><p>FreeRTOS消息队列支持优先级插入：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">xQueueSendToFront</span>(xQueue, &amp;highPriorityMsg, <span class="hljs-number">0</span>); <span class="hljs-comment">// 紧急消息插队</span><br></code></pre></td></tr></table></figure><h5 id="18-多线程之间要传输大量的数据，如何实现"><a href="#18-多线程之间要传输大量的数据，如何实现" class="headerlink" title="18.多线程之间要传输大量的数据，如何实现?"></a>18.多线程之间要传输大量的数据，如何实现?</h5><h5 id="19-dma的架构"><a href="#19-dma的架构" class="headerlink" title="19.dma的架构"></a>19.dma的架构</h5><p>DMA根据工作模式分为普通DMA和SGDMA，普通DMA要求源地址和目标地址必须是连续的，而SGDMA则使用链表描述不连续的存储空间，从而提高传输效率。</p><p>DMA硬件上包括三个部分：DMA控制器（负责整个DMA传输过程的控制），主模式控制电路和从模式控制电路（分别控制DMA模块在不同总线系统下的工作状态），数据通道FIFOs（用于总线端和外设之间的速率匹配和缓冲）</p><p>DMA传输过程：CPU配置DMAC用于数据传输；CPU将源地址，目的地址和传输数据字节数写入DMAC；外设准备就绪并通知DMAC，DMAC向CPU发出HOLD信号请求占用总线；CPU响应DMAC的请求，并将总线控制移交给DMAC；DMA模块读端口从源地址读数据，写端口向目的地址写数据；传输完成时，DMA结束传输并向CPU发出中断请求；CPU响应DMA的中断请求，对传输的数据进行校验</p><h5 id="20-信号量和互斥锁的具体底层实现机制"><a href="#20-信号量和互斥锁的具体底层实现机制" class="headerlink" title="20.信号量和互斥锁的具体底层实现机制"></a>20.信号量和互斥锁的具体底层实现机制</h5><p>信号量严格意义上不算全局变量，但是信号量句柄（指针）是以全局变量定义的；</p><p>信号量分为二值信号量（任务同步），计数型信号量（多资源管理），互斥信号量（1个资源管理），递归信号量；</p><p>二值信号量：其实就可以当作一个flag信号，0就没空位，1就有空位，但是与互斥信号量不同的是二值信号量无法避免优先级翻转的问题；可以在中断中使用；</p><p>初始值为0      创建-&gt;释放-&gt;获取</p><p>互斥信号量：对一个资源进行管理，只要有一个任务在用这个资源，别的任务就不能用这个资源；不能在中断中使用；</p><p>初始值为1      创建-&gt;获取-&gt;释放</p><h5 id="21-堆-Heap-和栈-Stack-的概念"><a href="#21-堆-Heap-和栈-Stack-的概念" class="headerlink" title="21.堆(Heap)和栈(Stack)的概念"></a>21.堆(Heap)和栈(Stack)的概念</h5><p>栈是编译器或者操作系统自动管理的，而堆是开发者手动控制的；</p><p>栈分配内存采取线性连续内存（last in first out）堆则是随机内存块（由动态链表管理）；</p><p>栈分配速度快，只需移动栈指针即可，而堆需要搜索可用内存块，分配速度较慢；</p><p>栈无内存碎片，堆易产生碎片；</p><p>栈作用于函数局部变量，堆则是进程级全局访问；</p><p>栈主要应用于局部变量和函数调用中，堆主要用于动态对象和大型数据中；</p><h5 id="22-在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度-如何在实际运行一段时间后检查栈的使用量"><a href="#22-在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度-如何在实际运行一段时间后检查栈的使用量" class="headerlink" title="22.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度?如何在实际运行一段时间后检查栈的使用量?"></a>22.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度?如何在实际运行一段时间后检查栈的使用量?</h5><p>1.栈填充法：初始化时用特定模式填充栈空间，然后运行一段时间代码，检查栈指针位置，用栈空间大小减去栈指针位置就是这个任务栈的使用深度；</p><p>2.RTOS内置支持高水位线标记；</p><h5 id="23-在哪些情况下栈的内容会发生改变"><a href="#23-在哪些情况下栈的内容会发生改变" class="headerlink" title="23.在哪些情况下栈的内容会发生改变?"></a>23.在哪些情况下栈的内容会发生改变?</h5><p>局部变量改变；发生中断时为了保存完整上下文会将相关寄存器压入栈中；线程切换时也是同理；直接用指令push或pop；</p><h5 id="24-CPU在进行现场保存-如函数嵌套调用、中断发生时-时，具体保存哪些信息"><a href="#24-CPU在进行现场保存-如函数嵌套调用、中断发生时-时，具体保存哪些信息" class="headerlink" title="24.CPU在进行现场保存(如函数嵌套调用、中断发生时)时，具体保存哪些信息?"></a>24.CPU在进行现场保存(如函数嵌套调用、中断发生时)时，具体保存哪些信息?</h5><p>返回地址：存储下一条指令的地址，确保ret指令能正确返回到调用点；</p><p>帧指针：保存当前栈帧基址；</p><p>被调用者保存寄存器：根据调用约定保存易失性寄存器（R0-R3）；</p><h5 id="25-当系统发生异常-例如进入HardFault-时，如何定位问题的根源"><a href="#25-当系统发生异常-例如进入HardFault-时，如何定位问题的根源" class="headerlink" title="25.当系统发生异常(例如进入HardFault)时，如何定位问题的根源?"></a>25.当系统发生异常(例如进入HardFault)时，如何定位问题的根源?</h5><p>当发生hardfault时cpu会自动把R0，R1，R2，R3，R12，LR，PC，PSR寄存器压栈，可以从PC寄存器定位触发异常的指令地址，LR寄存器可以返回异常地址，从而确定用的是MSP还是PSP指针；</p><p>hardfault一般是四种原因：硬件异常；内存异常；总线异常；使用异常；</p><p>可以进debug，然后全速运行，在外设栏-&gt;内核外设-&gt;fault reports中看各种错误寄存器</p><img src="/2025/09/05/%E5%85%AB%E8%82%A1%E5%A4%A7%E6%9D%82%E7%83%A9/c857e20b-cd79-4edc-8051-2c6f6556bafa.png" class=""><p>如果产生了hardfault，相应的寄存器会打勾，这个时候（还是在debug里）打开view-&gt;call stack window就可以找到hardfault发生的地址，右键watch里的hardfault选择show caller code，就能直接跳转到错误代码行（注意此方法适用于非法读取异常错误，字节对齐异常，不适用于非精确异常）</p><h5 id="26-请描述MCU从通电启动到执行main函数的过程"><a href="#26-请描述MCU从通电启动到执行main函数的过程" class="headerlink" title="26.请描述MCU从通电启动到执行main函数的过程"></a>26.请描述MCU从通电启动到执行main函数的过程</h5><p>以cm3和cm4为例（cm7会有不同）</p><p>上电复位后硬件强制PC指向自举区的入口地址，先执行自举区代码（初始化基础时钟-&gt;通过boot引脚检测启动模式），如果（boot0&#x3D;0，boot1&#x3D;0）从主flash启动，那么就会将用户flash（0x08000000）重映射到0x00000000中，如果（boot0&#x3D;1，boot1&#x3D;0）从系统存储器启动，那么就会跳转到系统bootloader，如果（boot0&#x3D;1，boot1&#x3D;1）从SRAM启动           还有一种特殊情况就是使用了选项字节，这个时候就不看boot引脚状态</p><p>如果从主flash启动，就从0x00000000读MSP，0x00000000读PC（PC此时指向reset_handler地址，由于重映射关系，该地址一般是0x08000004之后的某一地址），读完地址就会跳转到该地址执行reset_handler（初始化.data,.bss,系统时钟……）最后执行main（）</p><p>如果从系统存储区启动，就会将系统存储器物理地址重映射到0x00000000上，然后跳转到系统bootloader（根据自举区固化好的代码，这个代码存储了系统bootloader的入口地址），bootloader会先初始化（初始化外设通信，配置外设时钟，初始化GPIO，初始化flash编程接口），然后bootloader会进入一个主循环（在这个循环中发送或等待特定协议用于监听主机发送命令），接收到主机各种命令后会进行处理（如擦除flash，接收bin&#x2F;hex文件数据写入用户flash地址里，读flash，……），最后会执行用户程序reset_handler（初始化.data,.bss,系统时钟……）最后执行main（）</p><p>如果从SRAM启动，其实就是debug过程会执行（）</p><p>在复位处理函数中，先初始化堆栈指针（将从向量表加载的初始SP值设置到硬件堆栈指针寄存器中），然后初始化.data段（存放已初始化的全局变量和静态变量）清零.bss段，再初始化系统时钟（调用systeminit函数）初始化浮点运算单元和MPU，最后跳转到main（）函数</p><h5 id="27-PendSV"><a href="#27-PendSV" class="headerlink" title="27.PendSV"></a>27.PendSV</h5><p>PendSV本质是cortex内核定义的一种系统异常，与其他异常不同的是，PendSV是为了处理可延迟的系统级服务请求</p><p>PendSV可以在NVIC中配置优先级，通常RTOS会将PendSV优先级设置为最低，这样就能确保PendSV异常只有在没有其他更高优先级的异常或中断需要执行时才会触发执行，避免了在中断上下文中进行复杂的任务切换操作</p><p>PendSV不会由硬件事件自动触发，只能通过软件显式地设置挂起位来请求</p><p>PendSV主要应用于RTOS中实现高效，安全的任务上下文切换（如果不用PendSV，系统就只能在systick定时器中断中进行任务切换，这样就会带来问题，比如在tick中断前被更高优先级中断抢占就会导致状态不一致，在tick中断里执行上下文切换会使中断延迟增加，并且使中断栈的使用变得很复杂）</p><p>具体实现过程：tick中断服务函数中会先更新系统时钟，再检查任务延时列表（延时列表+延时溢出列表+双指针），判断是否需要切换任务，如果需要切换则设置PendSV的挂起位，最后退出中断ISR；ISR退出后，如果没有其他更高优先级的中断需要处理，就会进入PendSV异常处理程序；在PendSV异常处理函数中，先保存当前任务上下文（将此时运行任务的寄存器R0-R3，R12，LR，PC，PSR压栈），再更新TCB（将此时SP指针保存到其TCB中），再从就绪队列中选择优先级最高的任务，然后从这个任务的TCB中取出SP栈指针，从该栈中弹出保存的寄存器值，最后执行异常返回（硬件执行从MSP切换到PSP）</p><p>补充：就绪队列是一个优先级对应一个队列，其中会涉及优先级位图（就绪队列非空设为1，为空设为0）</p><h5 id="28-串口，spi，i2c，can这些如何选择"><a href="#28-串口，spi，i2c，can这些如何选择" class="headerlink" title="28.串口，spi，i2c，can这些如何选择"></a>28.串口，spi，i2c，can这些如何选择</h5><p>串口用于点对点通信，通讯速率较低（&lt;4Mbps）硬件上只需两根线，需要约定波特率，硬件上没有错误校验，</p><p>一般用于简单传感器，短距离设备对接，bootloader固件升级；</p><p>SPI通讯速率较高（可达50Mbps），拓扑为一主多从（通过片选cs引脚选择从机），硬件上需要四根线，全双工同步通信，有主控时钟，无内置错误校验，一般用于高速数据流传输，ADC&#x2F;DAC，多传感器并行连接，实时性强的通讯；</p><p>I2C速率中低速，拓扑为多主多从，硬件上需要两根线和上拉电阻，半双工同步通信，有ACK、NACK应答机制，适用于板载传感器网络，EEPROM配置存储，多设备共享总线，引脚资源紧张的场景；</p><p>CAN通讯速率为中速（125kbps-1Mbps），拓扑为多主多从，硬件上由差分线can _H,can_L组成，抗干扰强，有基于消息ID的仲裁机制，使用优先级传输，有CRC校验，错误帧重发，故障节点隔离机制，可靠性高，适用于工业控，长距离通信，高噪声环境；</p><h5 id="29-当DMA传输全满中断-Ful-和串口空闲中断-ldle-的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗"><a href="#29-当DMA传输全满中断-Ful-和串口空闲中断-ldle-的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗" class="headerlink" title="29.当DMA传输全满中断(Ful)和串口空闲中断(ldle)的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗?"></a>29.当DMA传输全满中断(Ful)和串口空闲中断(ldle)的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗?</h5><p>当DMA传输完成时，硬件自动置位TCIF标志；</p><p>当串口接收线路持续空闲时，硬件自动置位IDLE标志；</p><p>正常应该是先满足DMA全满中断的触发条件，然后再满足串口空闲中断的触发条件，但是题目说同时满足，那么这个时候就要看哪个优先级更高了</p><p>一般而言，使用这种数据传输架构确实很高效，但是会引入一个问题：中断中处理的数据大概率不是完整数据，所以这个时候要引入状态标记+指针跟踪机制，用指针记录最后一次处理结束位置，并标记（半满，全满）中断是否触发；</p><p>如果想要对这种数据传输架构继续优化，那就可以用双缓冲乒乓操作（全满中断就切换缓冲区），再优化一下，在中断服务函数中只对要处理的数据进行标记，然后在主循环里处理（需要对数据结构进行设计）；</p><p>还想优化吗？直接用STM32H7 硬件加速+智能DMA；</p><h5 id="30-微秒级延时如何实现"><a href="#30-微秒级延时如何实现" class="headerlink" title="30.微秒级延时如何实现"></a>30.微秒级延时如何实现</h5><p>使用DWT内核调试单元，使能DWT单元的CYCCNT计数器；</p><p>配置定时器，预分频器和自动重载值设置产生1Mhz的计数频率，启动定时器，循环等待达到计数值；</p><p>使用sysTick定时器（可能会影响到操作系统或Hal库的毫秒延时）；</p><h5 id="31-在I2C通信中，时序所需的延时是如何保证的"><a href="#31-在I2C通信中，时序所需的延时是如何保证的" class="headerlink" title="31.在I2C通信中，时序所需的延时是如何保证的?"></a>31.在I2C通信中，时序所需的延时是如何保证的?</h5><p><strong>SPI</strong>: 你只需要配置好时钟频率（决定数据速率）、数据位宽、CPOL&#x2F;CPHA（时钟极性相位），然后向数据寄存器（DR）写入数据。<strong>硬件会自动在正确的时钟边沿发送和接收数据位，所有时序（时钟高&#x2F;低电平时间、数据建立时间、保持时间）都由硬件时钟电路精确产生</strong>，与CPU主频无关，精度极高。</p><p><strong>I2C</strong>: 硬件I2C外设会自动处理START条件、STOP条件、ACK位、以及SCL时钟。你只需要操作控制寄存器和数据寄存器。硬件会确保SCL低电平期间SDA才能变化（建立时间），SCL高电平期间数据稳定（保持时间），这一切都由硬件保证。</p><p><strong>UART</strong>: 硬件会根据你设置的波特率（如115200）自动生成精确的位时序（每个bit的时长）。</p><h5 id="32-static-const-volatile作用"><a href="#32-static-const-volatile作用" class="headerlink" title="32.static,const,volatile作用"></a>32.static,const,volatile作用</h5><p><strong>static：</strong></p><p>修饰局部变量时，会将局部变量存储在静态存储区（.bss或.data段），生命周期贯穿整个程序运行期间；一般用于计数；</p><p>修饰全局变量或者函数时，主要改变其作用域，无法被extern；</p><p><strong>const：</strong></p><p>定义一个常量，会将const修饰的全局变量存储在flash中，一般用在函数形参中（在函数中保护指针指向的数据不被函数内部修改）；</p><p><strong>volatile：</strong></p><p>防止编译器优化，每次都从内存中重新读取该变量的值，并且将修改后的值写回内存；一般用于在中断服务函数中修改的全局变量和RTOS多个任务共享的全局变量；</p><h5 id="33-软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗"><a href="#33-软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗" class="headerlink" title="33.软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗?"></a>33.软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗?</h5><p>肯定是有影响的，因为I2C是半双工同步通信，它就只有两条线，数据线和时钟线，协议建立与结束所需的起始条件，停止条件都对时钟有着很高的要求，包括协议建立后读取数据时SDA线上的数据必须在SCL的高电平期间保持稳定，只有在SCL为低电平时才允许变化，如果这个时候发生了中断滞后，就会导致从设备视为一个<strong>起始或停止条件</strong>，而不是一个数据位，从而彻底破坏整个通信过程。</p><p>而且I2C规定了主设备在发送完一个字节后，需要在第9个时钟脉冲释放SDA线并读取从设备的应答（ACK）信号（一个低电平）。如果读取ACK位的时序被中断延迟，主设备可能错过从设备拉低SDA的短暂窗口，误判为无应答（NACK），从而错误地终止传输。</p><h5 id="34-I2C的时钟信号-SCL-如果出现不均匀-占空比不一致或频率抖动-，会对通信造成影响吗"><a href="#34-I2C的时钟信号-SCL-如果出现不均匀-占空比不一致或频率抖动-，会对通信造成影响吗" class="headerlink" title="34.I2C的时钟信号(SCL)如果出现不均匀(占空比不一致或频率抖动)，会对通信造成影响吗?"></a>34.I2C的时钟信号(SCL)如果出现不均匀(占空比不一致或频率抖动)，会对通信造成影响吗?</h5><p>I2C协议规定，数据线（SDA）上的信号必须在时钟线（SCL）的高电平期间保持稳定。</p><p>**建立时间 **：SDA上的数据必须在SCL上升沿到来之前就已经保持稳定一段时间。</p><p>**保持时间 **：在SCL下降沿之后，SDA上的数据还必须继续稳定一段时间。</p><p><strong>SCL频率过低或停顿</strong>：如果SCL低电平时间过长，从设备可能会等待超时，认为主设备（Master）已经放弃通信，从而自动复位其内部状态机，导致后续发送的数据全部无效。</p><p><strong>SCL频率过高</strong>：如果SCL频率超过了从设备技术手册中规定的最大值，从设备可能无法正确识别信号，导致工作异常。</p><h5 id="35-请分享你使用cmbacktrace工具定位并解决实际问题的具体案例"><a href="#35-请分享你使用cmbacktrace工具定位并解决实际问题的具体案例" class="headerlink" title="35.请分享你使用cmbacktrace工具定位并解决实际问题的具体案例"></a>35.请分享你使用cmbacktrace工具定位并解决实际问题的具体案例</h5><p>主要用于检测hardfault发生的位置：移植cmbacktrace库，在四个hardfault中断服务函数中调用相关api，然后通过串口输出日志到电脑上；</p><h5 id="36-数组越界操作是否必然导致Hardfault异常-如果不引发Hardfault，可能会带来哪些其他不良后果"><a href="#36-数组越界操作是否必然导致Hardfault异常-如果不引发Hardfault，可能会带来哪些其他不良后果" class="headerlink" title="36.数组越界操作是否必然导致Hardfault异常?如果不引发Hardfault，可能会带来哪些其他不良后果?"></a>36.数组越界操作是否必然导致Hardfault异常?如果不引发Hardfault，可能会带来哪些其他不良后果?</h5><p>越界地址落在其他变量&#x2F;数组的合法范围内（被地址映射的区域也算），硬件无法区分是否越界;</p><p>若越界地址在无MPU保护的有效SRAM地址空间内（如<code>0x20000000~0x20020000</code>），不会触发总线错误；</p><h5 id="37-在Bootloader跳转到应用程序的过程中，需要关闭DMA吗"><a href="#37-在Bootloader跳转到应用程序的过程中，需要关闭DMA吗" class="headerlink" title="37.在Bootloader跳转到应用程序的过程中，需要关闭DMA吗?"></a>37.在Bootloader跳转到应用程序的过程中，需要关闭DMA吗?</h5><p>需要，防止外设总线冲突（触发busfault）避免内存覆盖风险（若DMA指向Bootloader与应用程序共享的内存区（如SRAM），跳转后可能覆盖应用程序关键数据）防止中断触发错乱（跳转后若DMA完成中断触发，但应用程序未注册其ISR → CPU执行非法地址 → HardFault）</p><p>步骤：禁用所有DMA传输通道；清除DMA传输完成标志位（防止残留中断）；复位DMA通道配置；关闭DMA时钟；继续标准跳转APP流程</p><p>tip：bootloader硬件状态清理清单：关闭所有外设；关闭DMA；清除中断标志；复位时钟树；关闭全局中断；</p><h5 id="38-标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS-CTS这两根流控线-它们是怎么解决问题的"><a href="#38-标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS-CTS这两根流控线-它们是怎么解决问题的" class="headerlink" title="38.标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS&#x2F;CTS这两根流控线?它们是怎么解决问题的?"></a>38.标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS&#x2F;CTS这两根流控线?它们是怎么解决问题的?</h5><p>RTS（request to send）由接收方发出，告诉发送方“我是否准备好接收数据“</p><p>CTS（clear to send）由发送方监测，根据CTS状态决定”我是否被允许发送数据“</p><p>RTS，CTS交叉连接，从根本上避免数据丢失</p><h5 id="39-SPI通信时主设备和从设备时钟极性配置反了会发生什么"><a href="#39-SPI通信时主设备和从设备时钟极性配置反了会发生什么" class="headerlink" title="39.SPI通信时主设备和从设备时钟极性配置反了会发生什么"></a>39.SPI通信时主设备和从设备时钟极性配置反了会发生什么</h5><p>SPI时钟配置涉及到两个关键参数时钟极性和时钟相位，正常来讲主设备和从设备这两个参数要完全相同，如果配置反了，则会导致通信失败</p><h5 id="40-中断中能否获取锁"><a href="#40-中断中能否获取锁" class="headerlink" title="40.中断中能否获取锁"></a>40.中断中能否获取锁</h5><p><strong>中断可以且只能获取自旋锁，并且在获取锁时通常需要配合禁用本地CPU中断来防止死锁。中断绝对禁止获取任何可能导致睡眠的锁。</strong></p><p>在某种条件下（在进程上下文的代码中，在获取锁之前先关闭本地CPU的中断）可以获取”自旋锁“，绝对不能获取互斥锁；</p><p>自旋锁的特性：当无法获取锁时，请求者会在一个紧凑的循环中“自旋”（忙等待），直到锁可用。它不会让出CPU。</p><p>中断上下文的特性：不能睡眠，需要快速执行完毕。</p><p>一致性：自旋锁的“忙等待”机制符合中断上下文不能睡眠的要求。在中断中获取自旋锁是为了保护中断处理程序和进程上下文代码共享的某些数据结构。</p><p>如果中断尝试获取互斥锁且该互斥锁已被占用，内核调度器会尝试将中断上下文睡眠，会导致整个系统内核崩溃；</p><p>得看这个自旋锁会被哪些对象获取，如果同时会被进程上下文获取，有可能会造成死锁，如果同时会被另一个中断获取，也会造成死锁</p><p>tip：<strong>临界区</strong>：具体来说，是程序中的一段访问共享资源（比如全局变量、硬件寄存器、链表、文件等）的代码。之所以“临界”，是因为如果多个执行流（线程、进程、中断）同时在这段代码里乱来，会破坏数据的一致性或程序的正确性。临界区这个概念本身并不提供保护机制，它只是定义了需要被保护的代码范围。你需要用锁（如自旋锁、互斥锁）或其它同步原语来“守卫”这段代码。</p><h5 id="41-stm32内部有哪些寄存器"><a href="#41-stm32内部有哪些寄存器" class="headerlink" title="41.stm32内部有哪些寄存器"></a>41.stm32内部有哪些寄存器</h5><p>通用寄存器（R0-R12）：用于数据处理和计算；</p><p>特殊寄存器：SP指向当前栈顶位置；LR指向函数返回地址；PC指向下一条要执行的指令地址；</p><p>程序寄存器（xPSR）</p><h5 id="42-结构体内存对齐-为什么有这种对齐方式"><a href="#42-结构体内存对齐-为什么有这种对齐方式" class="headerlink" title="42.结构体内存对齐 为什么有这种对齐方式"></a>42.结构体内存对齐 为什么有这种对齐方式</h5><p><code>struct MyStruct &#123;   </code></p><p>​       <code>  char c;  // 1 byte (对齐1)  // [编译器自动添加 3 个填充字节 (Padding) 使下一个 int 对齐到4] --&gt; 地址偏移：1 + 3 = 4 (对齐4) </code> </p><p>​      <code>   int i;       // 4 bytes (地址4, 对齐4) </code>  </p><p>​      <code>        short s;     // 2 bytes (地址8, 对齐2) -&gt; 不需要填充    // [编译器在末尾自动添加 2 个填充字节，使总大小是 4(最大对齐) 的倍数] --&gt; 总大小：1 + 3(pad) + 4 + 2 + 2(pad) = 12 bytes</code>  </p><p><code>&#125;;</code></p><p>对齐是一个典型的以空间换时间以及保证正确性和兼容性的优化策略</p><p>整个结构体的最终大小，必须是其成员中<strong>对齐要求最严格</strong>的那个对齐值的<strong>整数倍</strong>。如果不满足，编译器会在结构体的末尾添加填充字节。</p><h5 id="43-无锁操作-原子操作的底层"><a href="#43-无锁操作-原子操作的底层" class="headerlink" title="43.无锁操作 原子操作的底层"></a>43.无锁操作 原子操作的底层</h5><p>原子操作是构建无锁数据结构的基石。它指的是一个操作（如读、写、读-修改-写）作为一个单一的、不可分割的单元执行。在操作完成之前，任何其他执行单元都无法观察到操作的中间状态或干扰该操作。</p><p>底层硬件支持：</p><p><strong>原子读&#x2F;写:</strong></p><p>对齐访问： 硬件保证对自然对齐（地址是数据类型大小的整数倍）的基本数据类型（如32位系统上的int通常是4字节对齐）的读写操作本身就是原子的。CPU通过总线宽度和缓存行设计保证了这一点。例如，在x86上，对齐的32位读写是原子的。<br>非对齐访问： 通常不是原子的，可能需要多次总线操作，中间可能被中断。<br><strong>读-修改-写</strong> 操作：</p><p>这是无锁编程的核心。常见操作包括：<br>比较并交换 (Compare-and-Swap, CAS): CAS(ptr, expected, new)：如果<em>ptr &#x3D;&#x3D; expected，则将</em>ptr设置为new并返回true；否则返回false。<br>获取并增加 (Fetch-and-Add, FAA): FAA(ptr, value)：原子地将value加到<em>ptr上，并返回原来的值。<br>交换 (Swap): Swap(ptr, new)：原子地将</em>ptr设置为new，并返回原来的值。<br>硬件实现： CPU提供特殊的原子指令来实现这些操作。这些指令在执行期间会：<br>锁定缓存行 (Cache Locking): 现代CPU最常见的方式。执行RMW指令的CPU核心会锁定包含目标内存地址的缓存行。在锁定期间，其他核心对该缓存行的访问会被阻塞或延迟（通过缓存一致性协议，如MESI&#x2F;MOESI）。指令完成后解锁。<br>锁定总线 (Bus Locking - 较老&#x2F;特定场景)： 某些指令（如x86的LOCK前缀）或某些架构在特定情况下，会发出信号锁定整个内存总线。这期间其他核心无法访问内存，开销巨大，应尽量避免。</p><h5 id="44-什么情况下不能使用Cache-在使用DMA的情况下，Cache-flush和Cachelonq哪种方式运行效率更高，为什么"><a href="#44-什么情况下不能使用Cache-在使用DMA的情况下，Cache-flush和Cachelonq哪种方式运行效率更高，为什么" class="headerlink" title="44.什么情况下不能使用Cache?在使用DMA的情况下，Cache flush和Cachelonq哪种方式运行效率更高，为什么?"></a>44.什么情况下不能使用Cache?在使用DMA的情况下，Cache flush和Cachelonq哪种方式运行效率更高，为什么?</h5><p><strong>问题</strong>：外设寄存器（如UART数据寄存器、GPIO端口）的值由硬件实时改变，若开启Cache，CPU可能读取到Cache中的过期副本。</p><p><strong>解决方案</strong>：在MMU&#x2F;MPU配置中将外设寄存器区域标记为<strong>Non-Cacheable</strong>。</p><p><strong>问题</strong>：CPU写 → DMA读：CPU修改的缓存数据若未写回内存，DMA将读取到<strong>旧数据</strong>。</p><p><strong>DMA写 → CPU读</strong>：DMA写入的新数据若在Cache中有副本，CPU将读到<strong>脏数据</strong>。</p><p><strong>解决方案</strong>：将DMA缓冲区放在<strong>Non-Cacheable内存区</strong>（如SRAM4）。或<strong>手动维护Cache一致性</strong>（Flush&#x2F;Invalidate）。</p><p><strong>问题</strong>：多个处理器共享同一内存区，若开启Cache，各处理器无法实时感知对方的数据修改。</p><p><strong>解决方案</strong>：配置共享区为<strong>Non-Cacheable</strong>。•使用支持缓存一致性的总线协议（如ARM CCI）。</p><h5 id="45-如果用SPI往屏上刷一个像素点，怎么操作SPI"><a href="#45-如果用SPI往屏上刷一个像素点，怎么操作SPI" class="headerlink" title="45.如果用SPI往屏上刷一个像素点，怎么操作SPI?"></a>45.如果用SPI往屏上刷一个像素点，怎么操作SPI?</h5><p>首先对SPI初始化（启用SPI时钟，配置SPI寄存器和GPIO寄存器）</p><p>传输开始时拉低CS信号，传输结束后拉高CS信号</p><p>遵循显示器的命令格式发送数据包</p><h5 id="46-从机无响应的时候，如何做异常处理"><a href="#46-从机无响应的时候，如何做异常处理" class="headerlink" title="46.从机无响应的时候，如何做异常处理?"></a>46.从机无响应的时候，如何做异常处理?</h5><p>SPI通信的本质是交换主机和从机的移位寄存器里的数据，没有读写的说法</p><p>在发送数据后，主机等待从机响应时设置一个超时时间。如果超过这个时间还没有收到响应，则认为从机无响应。</p><p>当检测到超时后，主机可以尝试重新发送数据，进行有限次数的重试。如果重试多次后仍然失败，则放弃并报告错误。</p><p>主机在检测到通信失败后，应设置错误标志或通过其他方式（如串口打印错误信息、点亮错误指示灯等）报告错误状态。</p><h5 id="47-项目中DMA配合什么外设使用的-给一个不定长的数据怎么用USART配合DMA完成传输-怎么判断传输完成"><a href="#47-项目中DMA配合什么外设使用的-给一个不定长的数据怎么用USART配合DMA完成传输-怎么判断传输完成" class="headerlink" title="47.项目中DMA配合什么外设使用的?给一个不定长的数据怎么用USART配合DMA完成传输?怎么判断传输完成?"></a>47.项目中DMA配合什么外设使用的?给一个不定长的数据怎么用USART配合DMA完成传输?怎么判断传输完成?</h5><p>串口+DMA,ADC+DMA,SPI+DMA(使用SPI时要注意尽量不要使用hal库的DMA操作)</p><p>串口空闲中断+DMA循环接收可以实现不定长数据的接收</p><p>ADC连续转换模式+DMA循环接收</p><p>双缓冲或环形缓冲区，半满中断全满中断</p><p>缓冲区做数据对齐和cache保护</p><p>是否启用DMA突发传输</p><p>是否使用定时器或其他中断源触发</p><h5 id="48-中断栈和任务栈有什么区别-保存在哪里"><a href="#48-中断栈和任务栈有什么区别-保存在哪里" class="headerlink" title="48.中断栈和任务栈有什么区别?保存在哪里?"></a>48.中断栈和任务栈有什么区别?保存在哪里?</h5><p>中断栈：当中断发生时，处理器会切换到中断上下文。中断栈用于保存中断上下文中的局部变量、寄存器状态以及可能的中断服务程序调用栈。</p><p>特点：通常是一个全局的栈，被所有中断共享。大小固定，由系统配置决定。在中断服务程序执行期间使用。</p><p>保存在哪里：中断栈通常位于静态分配的内存区域，由链接脚本定义，一般在RAM的系统全局栈中。在系统启动时初始化。</p><p>任务栈：每个任务都有自己的栈，用于保存任务执行时的局部变量、函数调用返回地址、任务上下文（在任务切换时保存寄存器的状态）等。</p><p>特点：每个任务有自己的栈空间。栈大小在任务创建时指定，不同任务可以有不同的栈大小。在任务执行时使用，任务切换时保存当前任务的上下文到其栈中，并从下一个任务的栈中恢复上下文。</p><p>保存在哪里：任务栈通常位于动态分配的内存（如从堆中分配）或静态分配的内存（由用户定义的任务栈数组）。在任务创建时分配。</p><h5 id="49-要实现任务调度，可以只有systick中断，不用pensv吗-pensv有什么优势"><a href="#49-要实现任务调度，可以只有systick中断，不用pensv吗-pensv有什么优势" class="headerlink" title="49.要实现任务调度，可以只有systick中断，不用pensv吗?pensv有什么优势?"></a>49.要实现任务调度，可以只有systick中断，不用pensv吗?pensv有什么优势?</h5><p>把任务调度放到systick中断中执行会导致systick中断执行时间过长，会影响整个RTOS系统的时序问题。涉及到pendsv为什么要像任务一样设置一个挂起态，挂起态这个架构就很有意思。</p><h5 id="50-任务间通信方式"><a href="#50-任务间通信方式" class="headerlink" title="50.任务间通信方式?"></a>50.任务间通信方式?</h5><p>共享内存&#x2F;全局变量：需要手动实现调度避免竟态条件和数据损坏；</p><p>信号量：任务间的同步；(信号量是一种特殊的队列，通过源码得出)</p><p>消息队列：FIFO，消息队列用于任务间数据传输时，会使用内部锁比如用调度器锁或者内部互斥量确保操作的原子性，如果生产者任务调用 <code>send</code>时队列已满，且调用指定了阻塞等待时间（如 <code>portMAX_DELAY</code>或一个超时值），该任务会被内核挂起 (阻塞)，并放入该队列的生产者等待列表。当有消费者任务从队列中 <code>receive</code>走一条消息（使队列不再满）时，内核会唤醒在该队列上等待的一个生产者任务（通常是优先级最高的），使其可以发送消息。关键在于消息队列用于<strong>中断和任务间</strong>（使用fromISR后缀的API），这里应该如何处理数据来解决生产和消费的不平衡(解决方法我的大概思路是用非阻塞式将数据传到消息队列中)以及如何在临界区（中断服务函数的最后）中进行上下文切换（判断是切换到下一个中断还是切换到下一个任务）</p><p>互斥锁:解决优先级翻转问题；</p><p>事件标志组：一个任务等待一组事件组（多事件的或和与）</p><h5 id="51-IAP升级做了什么工作"><a href="#51-IAP升级做了什么工作" class="headerlink" title="51.IAP升级做了什么工作?"></a>51.IAP升级做了什么工作?</h5><h5 id="52-内存踩踏严重调用栈现场破坏严重的情况下如何定位问题"><a href="#52-内存踩踏严重调用栈现场破坏严重的情况下如何定位问题" class="headerlink" title="52.内存踩踏严重调用栈现场破坏严重的情况下如何定位问题?"></a>52.内存踩踏严重调用栈现场破坏严重的情况下如何定位问题?</h5><p>不能再使用常规的“复现问题-打断点-看调用栈”的调试流程</p><p>使用Canary Values（金丝雀值）：在重要的数据结构或栈帧之间插入一些特殊的、已知的标记值（例如 <code>0xDEADBEEF</code>）。定期或在崩溃时检查这些“金丝雀”是否被改变。如果改变了，说明发生了越界写，并且你知道了被破坏的范围。这可以帮你缩小嫌疑范围。</p><p>MPU（内存保护单元）：如果你的MCU有MPU，你可以将栈内存区域配置为只读。任何非法的写入操作都会触发一个MemManage故障，CPU会自动停在该条指令处。这是定位问题的终极利器之一。</p><p>分析崩溃瞬间的CPU寄存器：</p><p>PC (Program Counter)：程序计数器，指向导致崩溃的指令。但它可能指向一个非法地址，这本身就是一个线索。</p><p>LR (Link Register)：连接寄存器，通常保存着函数的返回地址。它的价值往往高于被破坏的栈。查看LR的值，可以知道在崩溃前程序是从哪个函数跳转过来的。</p><p>SP (Stack Pointer)：栈指针。如果SP本身被改得指向非法地址，那这就是一个强烈的信号。</p><p>其他寄存器：查看通用寄存器（R0-R12）的值。它们可能保存着导致错误操作的地址或索引。例如，如果R2的值是一个明显的非法地址，那么接下来查看是哪个指令把该值加载到R2的。</p><h5 id="53-互斥量，信号量，临界区有什么区别和应用场景"><a href="#53-互斥量，信号量，临界区有什么区别和应用场景" class="headerlink" title="53.互斥量，信号量，临界区有什么区别和应用场景?"></a>53.互斥量，信号量，临界区有什么区别和应用场景?</h5><h5 id="55-陀螺仪通信时碰到的问题"><a href="#55-陀螺仪通信时碰到的问题" class="headerlink" title="55.陀螺仪通信时碰到的问题?"></a>55.陀螺仪通信时碰到的问题?</h5><table><thead><tr><th><strong>数据有静态偏差</strong></th><th><strong>零偏（Bias）</strong> 未校准。</th><th>1. <strong>执行校准</strong>：将传感器静止水平放置一段时间，计算各轴数据的平均值，作为零偏Offset，在后续读数中减去。</th></tr></thead><tbody><tr><td><strong>数据随温度漂移</strong></td><td><strong>温漂</strong>：零偏和灵敏度会随温度变化。</td><td>1. 高端传感器内置温度传感器和补偿系数。需读取温度值，并根据公式或查找表进行补偿。</td></tr><tr><td><strong>角度积分发散</strong></td><td><strong>陀螺仪积分误差</strong>：即使很小的零偏，积分后也会随时间累积成巨大的角度误差。</td><td>1. <strong>使用融合算法</strong>：如<strong>互补滤波</strong>或<strong>卡尔曼滤波</strong>，结合加速度计（无累积误差但高频噪声大）和陀螺仪（无累积误差但会漂移）的数据，得到稳定的姿态角。</td></tr></tbody></table><table><thead><tr><th><strong>读写寄存器失败</strong></th><th><strong>时序问题</strong>：不满足协议时序要求</th><th>1. <strong>用逻辑分析仪抓取波形！</strong> 这是最强大的调试手段。对照数据手册检查： - <strong>SPI</strong>: 时钟极性和相位（CPOL&#x2F;CPHA）是否匹配。 - <strong>I2C</strong>: 启动&#x2F;停止条件、时钟速度（是否超传感器最高速率）、ACK&#x2F;NACK信号。 2. 检查代码中的延时，确保满足两次操作之间的<code>T_&#123;wait&#125;</code>时间。</th></tr></thead><tbody><tr><td></td><td><strong>寄存器操作顺序错误</strong>：</td><td>1. 某些传感器需要先解锁配置寄存器、或按特定顺序配置。仔细阅读数据手册的配置流程。</td></tr><tr><td><strong>数据值不变或为0</strong></td><td><strong>传感器未启动</strong>：未使能测量模式。</td><td>1. 检查配置寄存器（如PWR_MGMT_1, CTRL_REG1），确保传感器已从睡眠&#x2F;待机模式切换到正常工作模式。</td></tr><tr><td></td><td><strong>FIFO或数据路径配置错误</strong>：数据未被更新到输出寄存器。</td><td>1. 检查数据路径配置，确认数据是直接输出到寄存器，还是先进入FIFO。</td></tr><tr><td></td><td><strong>SPI模式下的字节序问题</strong>：</td><td>1. 某些传感器在SPI模式下传输数据时，字节序（MSB first或LSB first）可能与I2C模式不同。</td></tr><tr><td><strong>数据值跳变剧烈，噪声大</strong></td><td><strong>未启用内置滤波器</strong>或<strong>滤波器带宽设置过高</strong>。</td><td>1. 根据应用场景（如游戏、振动监测、无人机），配置合适的<strong>低通滤波器（DLPF）</strong> 带宽。带宽越低，数据越平滑，延迟越高。</td></tr><tr><td></td><td><strong>数据刷新率（ODR）设置不当</strong>。</td><td>1. 确保输出数据速率（ODR）与滤波器带宽匹配（ODR应 ≥ 2 * 带宽，遵循奈奎斯特采样定理）。</td></tr></tbody></table><h5 id="56-嵌入式中内存泄漏和内存碎片的区别是什么-如何预防"><a href="#56-嵌入式中内存泄漏和内存碎片的区别是什么-如何预防" class="headerlink" title="56.嵌入式中内存泄漏和内存碎片的区别是什么?如何预防?"></a>56.嵌入式中内存泄漏和内存碎片的区别是什么?如何预防?</h5><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>内存泄漏 (Memory Leak)</strong></th><th align="left"><strong>内存碎片 (Memory Fragmentation)</strong></th></tr></thead><tbody><tr><td align="left"><strong>定义</strong></td><td align="left">分配的内存<strong>未被释放</strong>，且程序永久失去对该内存的引用。</td><td align="left">空闲内存被分割成大量<strong>不连续的小块</strong>，无法满足大内存请求。</td></tr><tr><td align="left"><strong>根本原因</strong></td><td align="left"><strong>代码逻辑错误</strong>：忘记释放内存（如 <code>malloc</code>后无 <code>free</code>）。</td><td align="left"><strong>动态内存分配机制缺陷</strong>：频繁分配&#x2F;释放不同大小的内存块。</td></tr><tr><td align="left"><strong>内存状态</strong></td><td align="left">内存被占用且无法再利用（“永远丢失”）。</td><td align="left">内存物理存在且空闲，但<strong>无法合并成连续大块</strong>。</td></tr><tr><td align="left"><strong>问题表现</strong></td><td align="left"><strong>可用内存总量持续减少</strong>，直至耗尽。</td><td align="left"><strong>总空闲内存充足</strong>，但分配大块内存时失败（如 <code>malloc(1024)</code>失败）。</td></tr><tr><td align="left"><strong>崩溃原因</strong></td><td align="left"><code>malloc</code>返回 <code>NULL</code>（内存耗尽）。</td><td align="left"><code>malloc</code>返回 <code>NULL</code>（无足够连续空间）。</td></tr><tr><td align="left"><strong>是否可恢复</strong></td><td align="left">❌ 除非重启系统。</td><td align="left">⚠️ 可能通过内存整理恢复（如压缩算法），但嵌入式系统通常不支持。</td></tr><tr><td align="left"><strong>检测工具</strong></td><td align="left">内存泄漏检测工具（Valgrind, Heap Trackers）。</td><td align="left">内存碎片分析工具（可视化内存映射）。</td></tr></tbody></table><p>在程序初始化时，使用合适的内存分配方法去分配内存池，比如linux内核分配内存时会按2的幂次分割&#x2F;合并内存，并为频繁分配的对象缓存固定大小的内存块</p><h5 id="57-虚函数的实现原理是什么-RTOS中使用它有哪些开销"><a href="#57-虚函数的实现原理是什么-RTOS中使用它有哪些开销" class="headerlink" title="57.虚函数的实现原理是什么?RTOS中使用它有哪些开销?"></a>57.虚函数的实现原理是什么?RTOS中使用它有哪些开销?</h5><p>编译器为每个包含虚函数的类生成一个虚表，并隐式地添加一个虚表指针，当通过基类指针调用一个虚函数时，会通过虚表指针找到虚表，然后找到存储的函数指针进行调用，这种间接查找调用的过程就能有效地实现多态</p><p>开销：每个虚表和虚表指针都会占用可观的内存，执行时间上每次调用都需要额外的两次内存访问</p><h5 id="58-SPI和-12℃-的核心区别有哪些-云台-IMU-选哪种协议更合适"><a href="#58-SPI和-12℃-的核心区别有哪些-云台-IMU-选哪种协议更合适" class="headerlink" title="58.SPI和 12℃ 的核心区别有哪些?云台 IMU 选哪种协议更合适?"></a>58.SPI和 12℃ 的核心区别有哪些?云台 IMU 选哪种协议更合适?</h5><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>SPI (Serial Peripheral Interface)</strong></th><th align="left"><strong>I²C (Inter-Integrated Circuit)</strong></th></tr></thead><tbody><tr><td align="left"><strong>通信方式</strong></td><td align="left"><strong>全双工</strong> (同时收发)</td><td align="left"><strong>半双工</strong> (分时收发)</td></tr><tr><td align="left"><strong>线缆数量</strong></td><td align="left"><strong>4 线制</strong> (至少3线)： - SCLK (时钟) - MOSI (主出从入) - MISO (主入从出) - CS&#x2F;SS (片选)</td><td align="left"><strong>2 线制</strong>： - SCL (时钟) - SDA (数据)</td></tr><tr><td align="left"><strong>拓扑结构</strong></td><td align="left"><strong>主从设备 + 点对点</strong> 每个从机需要独立的片选线(CS)。 支持多从机，但线路复杂。</td><td align="left"><strong>多主多从 + 总线式</strong> 所有设备挂载到同一总线上，通过地址寻址。 布线简单，但需要上拉电阻。</td></tr><tr><td align="left"><strong>数据传输</strong></td><td align="left"><strong>无协议格式</strong>。 只是简单的移位寄存，数据长度和含义由用户定义。</td><td align="left"><strong>有固定协议格式</strong>。 包含<strong>起始位</strong>、<strong>设备地址</strong>+<strong>读写位</strong>、<strong>应答位(ACK&#x2F;NACK)</strong>、<strong>停止位</strong>。</td></tr><tr><td align="left"><strong>速度</strong></td><td align="left"><strong>非常高</strong> (通常 50+ Mbps)。 没有协议开销，时钟频率可以很高。</td><td align="left"><strong>较低</strong> (标准模式 100kbps，快速模式 400kbps，高速模式 3.4Mbps)。 有协议开销（地址、应答位等），且受限于物理总线电容。</td></tr><tr><td align="left"><strong>从机地址</strong></td><td align="left"><strong>硬件地址</strong> (由CS线决定)</td><td align="left"><strong>软件地址</strong> (通常7位或10位，在协议中传输)</td></tr><tr><td align="left"><strong>硬件复杂度</strong></td><td align="left"><strong>主设备简单，从设备简单</strong>。 但主设备需要多个GPIO作为CS线。</td><td align="left"><strong>主设备和从设备逻辑更复杂</strong>。 需要处理协议和仲裁。但主设备只需2个GPIO。</td></tr><tr><td align="left"><strong>软件复杂度</strong></td><td align="left"><strong>低</strong>。只需操作移位寄存器，逻辑简单。</td><td align="left"><strong>较高</strong>。需要处理完整的协议状态（起始、地址、应答、停止）。</td></tr><tr><td align="left"><strong>鲁棒性</strong></td><td align="left"><strong>高</strong>。点对点连接，受干扰影响小。</td><td align="left"><strong>较低</strong>。总线式结构，一个设备故障可能拖垮整个总线。</td></tr><tr><td align="left"><strong>功耗</strong></td><td align="left">相对较高（多根信号线活动）。</td><td align="left">相对较低（两线制，静态时上拉电阻耗电）。</td></tr></tbody></table><h5 id="59-如何通过示波器波形判断-12C-丢包是-SCL拉伸异常还是从设备响应延迟导致"><a href="#59-如何通过示波器波形判断-12C-丢包是-SCL拉伸异常还是从设备响应延迟导致" class="headerlink" title="59.如何通过示波器波形判断 12C 丢包是 SCL拉伸异常还是从设备响应延迟导致?"></a>59.如何通过示波器波形判断 12C 丢包是 SCL拉伸异常还是从设备响应延迟导致?</h5><p><strong>先检查NACK</strong>：首先检查地址字节后的ACK位。如果这里已经是NACK，那么问题极有可能是地址错误、设备损坏或电源问题，后续的SCL拉伸根本不会发生。</p><p><strong>再检查拉伸</strong>：如果通信始于地址ACK，但在后续数据字节传输中出现超时，再去仔细观察SCL线是否被异常拉伸。</p><h5 id="60-FreeRTOS-和-Linux-二者调度算法有何差异"><a href="#60-FreeRTOS-和-Linux-二者调度算法有何差异" class="headerlink" title="60.FreeRTOS 和 Linux 二者调度算法有何差异?"></a>60.FreeRTOS 和 Linux 二者调度算法有何差异?</h5><p>FreeRTOS是实时操作系统，强调确定性和可预测性，Linux是通用操作系统，强调公平性和整体吞吐量；</p><p><strong>完全公平调度器 (CFS)</strong></p><p>核心思想**：不是分配固定的时间片，而是根据进程的<strong>权重（由nice值决定）</strong> 来分配CPU时间的<strong>比例</strong>。</p><p><strong>实现机制</strong>：</p><p>CFS 维护一棵<strong>红黑树（red-black tree）</strong>，树中的键是进程的<strong>虚拟运行时（vruntime）</strong>。</p><p><code>vruntime = 实际运行时间 * (NICE_0_LOAD / 进程权重)</code></p><p>调度器总是选择 <code>vruntime</code><strong>最小</strong>的进程来运行（即最“吃亏”的进程）。这保证了所有进程在一段时间内能公平地获得其应得的CPU时间比例。</p><p><strong>动态交互</strong>：CFS 会根据进程是 <strong>I&#x2F;O 消耗型</strong>（如GUI，经常等待用户输入）还是 <strong>CPU 消耗型</strong>（如视频编码，一直计算）来动态调整其优先级，优先照顾交互式进程，以提升用户体验。</p><p><strong>实时调度策略</strong></p><p>为了满足实时需求，Linux 提供了两个高于 CFS 的实时调度策略：</p><p><strong><code>SCHED_FIFO</code></strong>：先进先出。相同优先级的实时进程先来先服务，直到它主动放弃（阻塞或调用<code>sched_yield()</code>）或被更高优先级的实时进程抢占。</p><p><strong><code>SCHED_RR</code></strong>：轮转。与 <code>SCHED_FIFO</code>类似，但相同优先级的进程会分配时间片，时间片用完后会排到同优先级队列的队尾。</p><h5 id="61-ARM-Cortex-M-内核中，如何通过栈回溯定位-HardFault-异常的根本原因"><a href="#61-ARM-Cortex-M-内核中，如何通过栈回溯定位-HardFault-异常的根本原因" class="headerlink" title="61.ARM Cortex-M 内核中，如何通过栈回溯定位 HardFault 异常的根本原因?"></a>61.ARM Cortex-M 内核中，如何通过栈回溯定位 HardFault 异常的根本原因?</h5><p>发生异常后处理器会将关键信息压入寄存器中</p><p>检查PC指向地址附近的代码（用adress to line工具）；</p><p>检查LR寄存器判断当前使用的是主栈指针还是从栈指针，如果是主栈指针的话说明问题大概率发生在内核或者中断上下文中，如果是从栈指针的话说明问题大概率发生在任务上下文中；</p><h5 id="62-Bootloader-双分区备份下，升级断电后如何判断加载原分区还是修复新分区"><a href="#62-Bootloader-双分区备份下，升级断电后如何判断加载原分区还是修复新分区" class="headerlink" title="62.Bootloader 双分区备份下，升级断电后如何判断加载原分区还是修复新分区?"></a>62.Bootloader 双分区备份下，升级断电后如何判断加载原分区还是修复新分区?</h5><h5 id="63-CAN总线仲裁原理"><a href="#63-CAN总线仲裁原理" class="headerlink" title="63.CAN总线仲裁原理"></a>63.CAN总线仲裁原理</h5><p>can总线使用差分信号，存在线与特性，0代表显性，1代表隐性</p><p>仲裁发生在消息的仲裁场期间，主要是标识符部分。标识符数值越小的节点，优先级越高。</p><p>这背后的核心逻辑正是CAN 总线仲裁的“显性位覆盖”机制和标识符从最高位（MSB）开始比较的规则。</p><h5 id="64-对于有多个核的MCU，内存屏障有了解过吗"><a href="#64-对于有多个核的MCU，内存屏障有了解过吗" class="headerlink" title="64.对于有多个核的MCU，内存屏障有了解过吗"></a>64.对于有多个核的MCU，内存屏障有了解过吗</h5><p><code>// 核A写入共享数据</code><br><code>shared_data = 42;           // 写共享变量</code><br><code>__DMB();                    // 写屏障：确保写入完成后再释放锁</code><br><code>lock_flag = 0;              // 释放锁</code></p><p><code>// 核B读取共享数据</code><br><code>while (lock_flag != 0);     // 等待锁</code><br><code>__DMB();                    // 读屏障：确保读取前缓存已更新</code><br><code>int value = shared_data;    // 读取共享变量</code></p><p>内存屏障是多核MCU开发的基石技术：</p><p>使用原则：</p><p>共享数据读写 → <code>DMB</code></p><p>关键外设操作 → <code>DSB</code></p><p>动态代码更新 → <code>ISB + DSB</code></p><h5 id="65-从源码到可执行文件的过程"><a href="#65-从源码到可执行文件的过程" class="headerlink" title="65.从源码到可执行文件的过程"></a>65.从源码到可执行文件的过程</h5><p>预处理：cpp对源代码预处理形成一个纯粹的.i文件</p><p>编译：gcc将.i文件翻译成汇编语言生成一个.s文件</p><p>汇编：汇编器将汇编代码翻译成机器可以执行的机器码并输出一个.o文件</p><p>链接：ld链接器将多个目标文件合并为一个可执行文件.elf并为每个数据段分配最终的内存地址</p><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>.bin 文件</strong></th><th align="left"><strong>.elf 文件</strong></th></tr></thead><tbody><tr><td align="left"><strong>格式类型</strong></td><td align="left"><strong>原始二进制映像</strong>（Raw Binary Image）</td><td align="left"><strong>结构化可执行文件</strong>（Executable and Linkable Format）</td></tr><tr><td align="left"><strong>内容</strong></td><td align="left">纯机器码指令 + 数据（无元数据）</td><td align="left">机器码 + 数据 + 丰富的元数据（符号表、调试信息等）</td></tr><tr><td align="left"><strong>地址信息</strong></td><td align="left"><strong>无地址信息</strong>，烧录时需指定基地址</td><td align="left"><strong>包含地址信息</strong>（代码&#x2F;数据&#x2F;栈的加载地址）</td></tr><tr><td align="left"><strong>调试支持</strong></td><td align="left">❌ 无调试信息</td><td align="left">✅ 包含符号表、源码行号等调试信息</td></tr><tr><td align="left"><strong>文件大小</strong></td><td align="left">通常较小（仅含必需代码&#x2F;数据）</td><td align="left">通常较大（含调试信息、符号表等）</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">最终固件烧录、Bootloader</td><td align="left">开发调试、动态链接、符号分析</td></tr></tbody></table><h5 id="66-并发与并行"><a href="#66-并发与并行" class="headerlink" title="66.并发与并行"></a>66.并发与并行</h5><p>单核cpu似乎无法做到并行，只能做到并发（就是RTOS的任务并发）</p><h5 id="67-代码架构"><a href="#67-代码架构" class="headerlink" title="67.代码架构"></a>67.代码架构</h5><p>工程机器人嵌入式软件系统架构分为 6 层。下面从顶层到底层分别介绍。</p><ol><li><p>应用层：包括 CAN 中断回调函数、 USB 回调函数、 UART 回调函数、定时器回调函数、主循环的具体实现。</p></li><li><p>功能模块层：用类的方式实现各个功能模块的参数和成员函数。包括底盘、机械臂。底盘包括麦轮速度解算等、轮速控制 PID 等。机械臂模块包括向 NUC 发送电机角度数据、接收来自 NUC 的电机目标角度，并将控制指令发送给电机。</p></li><li><p>硬件驱动层：用类的方式实现各个硬件的驱动。包括 A 板开关电源的驱动程序、 M3508电机的驱动程序、达妙 4310 电机驱动程序、遥控器驱动程序和裁判系统驱动程序。包含发送命令、接收反馈、数据处理、 PID 计算等功能。</p></li><li><p>中间件层：包含 PID 算法的功能包（类）以及自定义数学运算（如矩阵运算、限幅函数、大小端转换等）。</p></li><li><p>硬件抽象层：对 HAL 库中 CAN、 UART 等单片机外设库的重新封装。</p></li><li><p>HAL 库：由 stm32cubeMX 生成的开发者库</p></li></ol><p><a href="#####%E7%9B%AE%E5%BD%95">目录</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效减少莫名奇妙的bug的一些方法</title>
    <link href="/2025/08/31/%E6%9C%89%E6%95%88%E5%87%8F%E5%B0%91%E8%8E%AB%E5%90%8D%E5%A5%87%E5%A6%99%E7%9A%84bug%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/31/%E6%9C%89%E6%95%88%E5%87%8F%E5%B0%91%E8%8E%AB%E5%90%8D%E5%A5%87%E5%A6%99%E7%9A%84bug%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="有效减少莫名奇妙的bug的一些方法"><a href="#有效减少莫名奇妙的bug的一些方法" class="headerlink" title="有效减少莫名奇妙的bug的一些方法"></a>有效减少莫名奇妙的bug的一些方法</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 禁用DMA</span><br><span class="hljs-built_in">__HAL_DMA_DISABLE</span>(&amp;hdma_spi1_rx);<br><span class="hljs-comment">// 等待DMA被禁用（确保DMA已停止）</span><br><span class="hljs-built_in">while</span>(hdma_spi1_rx.Instance-&gt;CR &amp; DMA_SxCR_EN)<br>&#123;<br>    <span class="hljs-built_in">__HAL_DMA_DISABLE</span>(&amp;hdma_spi1_rx);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>禁用DMA后加上判断确保DMA已停止</p></li><li><p>直接使用HAL_DMA_Abort似乎能代替这一过程（待验证）</p><p>  uint8_t ist8310_init(void)<br>  {<br>  static const uint8_t wait_time &#x3D; 1;<br>  static const uint8_t sleepTime &#x3D; 50;<br>  uint8_t res &#x3D; 0;<br>  uint8_t writeNum &#x3D; 0;<br>  ist8310_GPIO_init();<br>  ist8310_com_init();<br><br>  ist8310_RST_L();<br>  ist8310_delay_ms(sleepTime);<br>  ist8310_RST_H();<br>  ist8310_delay_ms(sleepTime);<br><br>  &#x2F;&#x2F;下面为主要初始化代码<br>  ……<br>  }</p></li><li><p>在对有硬件电路的对象（如电机，传感器）初始化或复位时调用复位函数后要进行延时等待硬件电路初始化</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码优化策略</title>
    <link href="/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="代码优化策略"><a href="#代码优化策略" class="headerlink" title="代码优化策略"></a>代码优化策略</h1><blockquote><p>哪有什么代码优化，不过是空间和时间转化的策略罢了，实战当中要平衡好RAM空间与运行时间的关系</p></blockquote><p>首先得了解不同编译器的优化模式，以keil为例，优化等级分为-o0，-o1，-o2，-o3，额外独立配置：-Ospace，-Otime；</p><ul><li>-o0：不优化，优点是方便调试时变量查看，缺点是代码运行速度慢，占用内存大；（开发调试阶段）</li><li>-o1：受限优化，平衡优化，优化不涉及“空间-时间”权衡，只进行优化如删除未使用的函数，变量；（测试优化阶段）</li><li>-o2：高性能优化，执行包括指令调度在内的大量优化，包括展开小的循环，缺点是代码尺寸增加，变量可能被优化；（电机控制，数字信号处理，低端MCU）</li><li>-o3：极致性能优化，在-o2基础上采取更激进策略（大量循环展开，更激进的函数内联），代码体积急速膨胀；（核心算法循环）</li><li>-Ospace：偏向减小代码尺寸，比如-o2下选择不展开循环；（默认选项）</li><li>-Otime：偏向提高运行速度，比如-o1下尝试内联小函数；</li></ul><p>不同优化最容易出问题的地方：延迟类函数，for循环</p><p>keil中可以对不同文件夹设置不同优先级，这也是为什么要对架构进行设计，实战中可以试着逐步提高优化优先级，但有时候0级优化反而会出现问题</p><img src="/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/0d7110db-b55b-4d7b-b978-51d18a3e3591.png" class=""><ul><li>总结：当使用for多重嵌套且最内层for只进行少量操作时，for本体就会占用大部分MCU周期频率，与内核指令流水线操作有关；（tip：需强化相关汇编知识）</li></ul><img src="/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/9ca4347e-2caa-42bf-83d1-5c88dabaf46f.png" class=""><ul><li>总结：缓存区域越大命中率越高（tip：有空做个实验）</li></ul><img src="/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/6a76902b-5689-4c96-8ba0-4cf1587d809d.png" class=""><ul><li>总结：对于需要频繁调用且函数内部操作少的情况，可以考虑内联</li></ul><img src="/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/99677660-3675-40bb-a099-d37b594d94f0.png" class=""><ul><li>总结：单独对函数设置优化等级操作</li></ul><img src="/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/a7d4d9a5-3e54-4a56-a4a7-978dc52697f5.png" class=""><ul><li>总结：无法go to define的原因（如果是局部变量go to不到很正常）</li></ul><img src="/2025/08/20/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/e708b2c5-462b-4605-ad0f-6d783fd4492b.png" class=""><ul><li>总结：结构体成员对齐要看定义顺序，按成员大小降序排列可最小化填充！</li></ul><p><strong>简化数据结构</strong>：使用位域（bit-field）存储标志位，使用联合体（union）节省空间</p><p><strong>合理使用ITCM和DTCM也可以优化代码</strong></p><p>第一种方法：通过修改链接脚本的分配地址将中间件代码（RTOS调度算法，其他算法）分配到TCM上</p><p>第二种方法:</p><p><em>&#x2F;&#x2F; 在代码中</em> </p><p><code>__attribute__((section(&quot;.itcm_text&quot;))) void critical_motor_control_loop(void) &#123;    *// 这个函数会被编译到.itcm_text段*    *// ... 极其时间敏感的代码* &#125;</code></p><p><strong>NEON是ARM的SIMD技术，通过128位寄存器实现数据并行处理，显著提升多媒体、信号处理等场景的性能。</strong></p><p><strong>学习抢占优先级和响应优先级的设计架构</strong>（有效地拓展了优先级个数却不占用代码运行时间）</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器）</title>
    <link href="/2025/08/03/%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%EF%BC%8C%E7%83%A7%E5%BD%95%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/08/03/%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%EF%BC%8C%E7%83%A7%E5%BD%95%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器）"><a href="#一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器）" class="headerlink" title="一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器）"></a>一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器）</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>如果是科班出身的同学，那么应该学过代码从编译到烧录这一流程的原理，但是还有很多非科班并且初学stm32的同学应该都像我当时那样，觉得代码能跑就行，没必要了解这块方面的知识。事实上随着学习和实践的深入，有这一过程的清晰认知对于代码的调试，对于在脑子里搭建起整个嵌入式运行框架有非常大的作用。比如之后如果要看反汇编，那么肯定要对这个全过程有正确的理解。</p><p>其实我之前已经对这个全过程有自己的理解了，但记忆随着时间而丢失，导致现在又有点理不清了。所以我写这篇文章的目的，不仅仅是分享，也是一种再学习的过程（可以去搜一下费曼学习法）。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先先大致介绍一份代码文件在全过程下所需的各种子文件。</p><p>一份源代码文件通常包括</p><p>.c文件（C source文件，包含C语言编写的函数实现和程序逻辑，可被编译器编译为目标文件）</p><p>.h文件（header文件，包含函数声明，宏定义，类型定义等接口信息）</p><p>.s文件（汇编文件，包含汇编语言编写的低级代码，通常用于处理器启动，中断处理等底层操作）</p><p>.lib或.a文件(windows下为.lib,linux下为.a，涉及很多高级库玩法)</p><p>除了源代码文件外还需要有构建系统相关文件，比如</p><p>.ld文件或.sct文件（链接文件，控制链接过程的内存布局）</p><p>.mk文件或.cmake文件(makefile，构建系统的规则定义文件；cmake，CMake构建系统的配置文件)</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译是将高级编程语言（如C、C++）转换为目标机器可理解的低级语言（汇编语言或机器代码）的过程。这个过程由编译器完成，主要包括以下阶段：</p><p><strong>预处理 → 编译 → 转成.o目标文件</strong></p><p>预处理：展开头文件（<code>#include</code>）宏替换（<code>#define</code>）条件编译（<code>#ifdef</code>, <code>#ifndef</code>等）</p><p>编译：将预处理的代码转换成汇编代码</p><table><thead><tr><th align="left">编译器</th><th align="left">支持架构</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">GCC</td><td align="left">x86, ARM, RISC-V, MIPS</td><td align="left">开源、跨平台</td><td align="left">嵌入式Linux、通用嵌入式</td></tr><tr><td align="left">Clang&#x2F;LLVM</td><td align="left">x86, ARM, RISC-V</td><td align="left">编译速度快、错误信息友好</td><td align="left">iOS&#x2F;macOS开发、跨平台</td></tr><tr><td align="left">IAR</td><td align="left">ARM, RISC-V, 8051</td><td align="left">商业级、优化好</td><td align="left">工业控制、汽车电子</td></tr><tr><td align="left">Keil</td><td align="left">ARM Cortex-M</td><td align="left">集成开发环境</td><td align="left">STM32开发</td></tr><tr><td align="left">Xtensa GCC</td><td align="left">ESP32</td><td align="left">专用于Tensilica架构</td><td align="left">IoT设备</td></tr></tbody></table><p>这里着重介绍一下keil，keil针对不同类型的源文件会使用不同的工具处理，与GCC工具链有明显的区别</p><p>.c   →   armcc.exe     →   .o (目标文件)    </p><p>.s   →   armasm.exe    →   .o (目标文件)   </p><p>.lib&#x2F;.a   ←   armar.exe    ←   多个.o文件</p><p>这些可以在keil IDE中魔术棒的target里面做配置，这里不详细展开</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接器将多个目标文件（.o）和库文件（.lib）组合成单一的可执行文件(.axf或.elf或.out)，主要任务包括：</p><p><strong>地址分配</strong>：为代码和数据分配具体的内存地址</p><p><strong>符号解析</strong>：解决跨文件的函数和变量引用</p><p><strong>重定位</strong>：根据实际地址调整指令中的地址引用</p><p>不同芯片架构需要不同的链接脚本配置,GCC工具链使用.ld文件，Keil MDK使用.sct文件。</p><p><strong>链接脚本的作用</strong></p><ul><li><input disabled="" type="checkbox"> 内存分配：定义Flash和RAM的地址范围</li><li><input disabled="" type="checkbox"> 段(Section)布局：控制代码、数据在内存中的位置</li><li><input disabled="" type="checkbox"> 符号处理：定义特殊符号（如堆栈起始地址）</li><li><input disabled="" type="checkbox"> 启动配置：指定入口点和初始化顺序</li></ul><blockquote><p>如果想实现分散加载功能，就要自己写链接脚本</p><p>或者在多核系统下要对内存进行划分，或者带外部存储器时都要对链接脚本进行修改</p><p>ai还提到了一种玩法：安全与非安全区域划分</p></blockquote><p>链接过程最后得到的文件格式与使用工具链有关</p><table><thead><tr><th align="left">文件格式</th><th align="left">主要使用工具链</th><th align="left">文件性质</th><th align="left">典型扩展名</th></tr></thead><tbody><tr><td align="left">ELF</td><td align="left">GNU工具链</td><td align="left">标准格式</td><td align="left">.elf, .out</td></tr><tr><td align="left">AXF</td><td align="left">Keil MDK</td><td align="left">变种格式</td><td align="left">.axf</td></tr><tr><td align="left">OUT</td><td align="left">传统Unix格式</td><td align="left">遗留格式</td><td align="left">.out</td></tr></tbody></table><p>这里还是以axf为例，可以通过工具将其转成.bin，.hex，可以提取出.map,调试时可以很方便地查看代码或某个变量的内存位置</p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>烧录是将生成的可执行文件写入目标芯片的非易失性存储器（Flash）的过程。</p><h5 id="常见烧录接口"><a href="#常见烧录接口" class="headerlink" title="常见烧录接口"></a>常见烧录接口</h5><p>JTAG接口：</p><ul><li>标准化的调试和编程接口</li><li>支持边界扫描测试</li><li>需要4-5根信号线（TMS, TCK, TDI, TDO, TRST）</li></ul><p>SWD接口（Serial Wire Debug）：</p><ul><li>ARM架构专用，引脚更少（SWDIO, SWCLK）</li><li>适合引脚受限的Cortex-M系列</li></ul><p>UART Bootloader：</p><ul><li>通过串口进行固件更新</li><li>需要芯片内置bootloader支持</li><li>成本低，使用广泛</li></ul><h3 id="待更新部分"><a href="#待更新部分" class="headerlink" title="待更新部分"></a>待更新部分</h3><p>需要更新arduino或SOC工具链的全过程</p><p>需要更新交叉编译工具链</p><p>需要简单了解makefile写法</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAN系统性再学习</title>
    <link href="/2025/07/25/CAN%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%86%8D%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/07/25/CAN%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%86%8D%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>CAN学习</p><p>错误帧</p><p>过载帧</p><p>帧间隔：主动</p><p>​                被动</p><p>位填充（连续5个电平后自动发个一个相反电平）：防止波形长时间无变化</p><p>​               将正常数据流与错误帧和过载帧区分开</p><p>​               防止被误认为总线空闲</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>CAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用却不熟悉的编译器拓展学习</title>
    <link href="/2025/07/05/%E5%B8%B8%E7%94%A8%E4%BD%86%E4%B8%8D%E7%86%9F%E6%82%89%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/07/05/%E5%B8%B8%E7%94%A8%E4%BD%86%E4%B8%8D%E7%86%9F%E6%82%89%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E6%8B%93%E5%B1%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="常用却不熟悉的编译器拓展学习"><a href="#常用却不熟悉的编译器拓展学习" class="headerlink" title="常用却不熟悉的编译器拓展学习"></a>常用却不熟悉的编译器拓展学习</h1><blockquote><p>需要注意的是有些代码架构其实是ARM编译器或GCC&#x2F;CLANG特有的变量属性，如果高频使用的话可能会导致系统可移植性和鲁棒性变差，可读性也会变差，“在必要处使用，避免炫技”</p></blockquote><h3 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a><code>__attribute__</code></h3><p><code>__attribute__</code> ：它是 GNU C 编译器（GCC）提供的一种编译器指令（Compiler Directive） 或扩展语法。它允许开发者向编译器提供关于变量、函数、类型（结构体、联合体、枚举） 的额外信息或特殊要求，这些信息超出了标准 C 语言语法的范畴。</p><p>目的：</p><p>1.精细控制内存布局： 如对齐方式 (<code>aligned</code>)、打包方式 (<code>packed</code>)、指定存储段 (<code>section</code>)。</p><p>2.优化提示： 如内联行为 (<code>always_inline</code>, <code>noinline</code>)、分支预测 (<code>cold</code>, <code>hot</code>)。</p><p>3.函数行为控制： 如不返回 (<code>noreturn</code>)、纯函数 (<code>pure</code>)、弱符号 (<code>weak</code>)、裸函数 (<code>naked</code>)。</p><p>4.变量行为控制：如易变性 (<code>volatile</code> - 虽然 <code>volatile</code> 是关键字，但有时也用属性形式)、强制使用 (<code>used</code>)、未使用 (<code>unused</code>)。</p><p>5.代码生成控制： 如构造函数&#x2F;析构函数 (<code>constructor</code>, <code>destructor</code>)。</p><p>6.诊断控制：如弃用警告 (<code>deprecated</code>)、格式检查 (<code>format</code>)。</p><p>语法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">__attribute__</span>((attribute_name))         <span class="hljs-comment">// 单个属性</span><br><span class="hljs-built_in">__attribute__</span>((attribute_name(params))) <span class="hljs-comment">// 带参数的属性</span><br><span class="hljs-built_in">__attribute__</span>((attribute_name1, attribute_name2, ...)) <span class="hljs-comment">// 多个属性</span><br></code></pre></td></tr></table></figure><p>•它通常放在声明（变量、函数、类型）的末尾，在分号 <code>;</code> 之前。</p><p>•多个属性用逗号分隔，放在同一个双括号 <code>(( ... ))</code> 内。</p><p>可移植性：</p><p>•<code>__attribute__</code> 是GNU C 扩展，不是标准 C (ANSI C, ISO C) 的一部分。</p><p>•其他主流编译器（如 Clang、ARM Compiler 5&#x2F;6, IAR）通常也支持大部分常用的 <code>__attribute__</code> 语法，或者提供功能等效的替代方式（如 <code>#pragma</code>）。</p><p>•为了可移植性，有时会用宏来包装特定编译器的属性语法。</p><p><code>// 单个变量对齐 uint8_t dma_buffer[1024] __attribute__((aligned(32))); // 32 字节对齐 // 结构体类型对齐 struct __attribute__((aligned(16))) Vector4 {     float x, y, z, w; };</code></p><p><code>ALIGN_32BYTES(__attribute__((section (&quot;.RAM_D2&quot;))) uint8_t src_fifo[CH_NUM][FIFO_DBS_0]);</code> </p><ul><li>**<code>ALIGN_32BYTES</code>**这是一个宏，用于指定变量的对齐方式，表示变量按32字节对齐</li><li>**<code>__attribute__((section (&quot;.RAM_D2&quot;)))</code>**用于将变量放置于指定的段（section）中，这里段名为“.RAM_D2”</li><li>像 <code>section</code> 这样的属性需要与链接器脚本 (<code>.ld</code>, <code>.sct</code>) 配合使用，在链接脚本中定义对应的段并将其映射到特定的内存区域。</li></ul><p><code>__STATIC_INLINE void __set_MSP(uint32_t uint32_t topOfMainStack){ }</code></p><ul><li><code>__STATIC_INLINE</code>     内联，作用是将函数直接嵌入到调用此函数的代码中，从而降低调用此函数所占用的时间(MDK AC5使用此关键词，MDK AC6使用<code>__STATIC_FORCEINLINE</code> )</li></ul><p><code>#pragma pack(push, 1) // 保存当前对齐设置，并设置为 1 字节对齐 struct SensorData {     uint8_t id;     uint32_t value; }; #pragma pack(pop) // 恢复之前的对齐设置</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlignedMember</span> &#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> _Alignas(<span class="hljs-number">8</span>) b;  <span class="hljs-comment">// 强制b按8字节对齐</span><br>&#125;;                      <span class="hljs-comment">// 总大小=16（a后补7字节）</span><br></code></pre></td></tr></table></figure><p><code>uint8_t buffer[1024] __attribute__((aligned(32))); // 32字节对齐</code></p><p><code>// 在链接脚本中定义： _estack = ORIGIN(RAM) + LENGTH(RAM); // 在代码中声明并确保存在： extern uint32_t _estack; uint32_t * const __attribute__((used)) pStackTop = &amp;_estack; // 强制保留 pStackTop (&amp;_estack)</code></p><h3 id="builtin"><a href="#builtin" class="headerlink" title="__builtin"></a><code>__builtin</code></h3><p>内建函数，一般用于位操作和位扫描，字节序交换，分支预测提示(不建议使用)，内存屏障&#x2F;栅栏，原子操作（不建议使用，建议使用C11新版标准原子操作）</p><ul><li><p><code>int __builtin_clz(unsigned int x)</code>: 计算 <code>x</code> 的二进制表示中<strong>前导零 (Leading Zero)</strong> 的数量。<code>x=0</code> 是未定义行为 (UB)。<code>x=1</code> (0b…0001) 返回 31 (32位系统)。•<code>int __builtin_ctz(unsigned int x)</code>: 计算 <code>x</code> 的二进制表示中<strong>尾随零 (Trailing Zero)</strong> 的数量（即最低位的 1 的位置）。<code>x=0</code> 是 UB。<code>x=8</code> (0b…1000) 返回 3。•<code>int __builtin_popcount(unsigned int x)</code>: 计算 <code>x</code> 的二进制表示中 <strong>1 的个数 (Population Count)</strong>。•<code>int __builtin_ffs(int x)</code>: 查找 <code>x</code> 中<strong>最低位被置位 (First Set Bit)</strong> 的位置（从 1 开始计数）。<code>x=0</code> 返回 0。<code>x=8</code> 返回 4。</p></li><li><p><code>uint16_t __builtin_bswap16(uint16_t x)</code>: 反转 16 位整数的字节顺序。</p></li><li><p><code>uint32_t __builtin_bswap32(uint32_t x)</code>: 反转 32 位整数的字节顺序。</p></li><li><p><code>uint64_t __builtin_bswap64(uint64_t x)</code>: 反转 64 位整数的字节顺序。</p></li><li><p><code>#define likely(x)   __builtin_expect(!!(x), 1) // x 很可能为真</code></p></li><li><p><code>#define unlikely(x) __builtin_expect(!!(x), 0) // x 很可能为假</code></p></li><li><p>•<code>type __sync_fetch_and_add(type *ptr, type value)</code>: 原子地将 <code>value</code> 加到 <code>*ptr</code> 上，返回 <code>*ptr</code> 的<strong>旧值</strong>。</p></li><li><p>•<code>type __sync_add_and_fetch(type *ptr, type value)</code>: 原子地将 <code>value</code> 加到 <code>*ptr</code> 上，返回 <code>*ptr</code> 的<strong>新值</strong>。</p></li><li><p>•<code>type __sync_fetch_and_sub(type *ptr, type value)</code>: 类似 <code>fetch_and_add</code>，做减法。</p></li><li><p>•<code>type __sync_sub_and_fetch(type *ptr, type value)</code>: 类似 <code>add_and_fetch</code>，做减法。</p></li><li><p>•<code>type __sync_fetch_and_or(type *ptr, type value)</code>: 原子地 OR。</p></li><li><p>•<code>type __sync_fetch_and_and(type *ptr, type value)</code>: 原子地 AND。</p></li><li><p>•<code>type __sync_fetch_and_xor(type *ptr, type value)</code>: 原子地 XOR。</p></li><li><p>•<code>type __sync_lock_test_and_set(type *ptr, type value)</code>: 原子地将 <code>*ptr</code> 设置为 <code>value</code>，返回旧值（通常用于实现自旋锁）。</p></li><li><p>•<code>void __sync_lock_release(type *ptr)</code>: 释放由 <code>__sync_lock_test_and_set</code> 获取的锁（通常将 <code>*ptr</code> 设为 0）。</p></li><li><p>•<code>bool __sync_bool_compare_and_swap(type *ptr, type oldval, type newval)</code>: 如果 <code>*ptr == oldval</code>，则原子地将 <code>*ptr</code> 设置为 <code>newval</code>，返回 <code>true</code>；否则返回 <code>false</code>。</p></li><li><p>•<code>type __sync_val_compare_and_swap(type *ptr, type oldval, type newval)</code>: 如果 <code>*ptr == oldval</code>，则原子地将 <code>*ptr</code> 设置为 <code>newval</code>；总是返回 <code>*ptr</code> 的旧值。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>ARM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++系统性学习</title>
    <link href="/2025/07/02/C++%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/07/02/C++%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-系统性学习"><a href="#C-系统性学习" class="headerlink" title="C++系统性学习"></a>C++系统性学习</h1><p>C++系统过于庞大，待我消化一下再更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MDK应用</title>
    <link href="/2025/06/20/MDK%E5%BA%94%E7%94%A8/"/>
    <url>/2025/06/20/MDK%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>MDK应用</strong></p><p>JTAG(20PIN) SWD(5PIN)</p><p>可以在debug时看全局变量 局部变量 在memory里看数据</p><blockquote><p>Hardfault</p></blockquote><p>硬件异常 内存异常 总线异常 处理异常</p><p>触发不同异常进入的各种中断可以配置优先级（实战好像没什么用）</p><p>本质就是通过硬件寄存器检测数据对不对，不对就触发中断.</p><p>进入异常后，判断LR寄存器bit2，如果等于0就把MSP给R0，如果等于1就把PSP给R0，最后进入异常处理函数</p><p>总结：看PC指针</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现继承，封装，多态</title>
    <link href="/2025/05/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%B0%81%E8%A3%85%EF%BC%8C%E5%A4%9A%E6%80%81/"/>
    <url>/2025/05/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%B0%81%E8%A3%85%EF%BC%8C%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言实现继承，封装，多态"><a href="#C语言实现继承，封装，多态" class="headerlink" title="C语言实现继承，封装，多态"></a>C语言实现继承，封装，多态</h2><p>不透明指针实现封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// person.h （头文件）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> <span class="hljs-title">Person</span>;</span> <span class="hljs-comment">// 前向声明</span><br><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_destroy</span><span class="hljs-params">(Person* p)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_name</span><span class="hljs-params">(Person* p, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">person_get_name</span><span class="hljs-params">(<span class="hljs-type">const</span> Person* p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_set_age</span><span class="hljs-params">(Person* p, <span class="hljs-type">int</span> age)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">person_get_age</span><span class="hljs-params">(<span class="hljs-type">const</span> Person* p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">person_print_info</span><span class="hljs-params">(<span class="hljs-type">const</span> Person* p)</span>;<br><br><span class="hljs-comment">// person.c （实现文件）</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br>Person* <span class="hljs-title function_">person_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age)</span> &#123;<br>    Person* p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Person));<br>    p-&gt;name = strdup(name);<br>    p-&gt;age = age;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// 其他函数实现...</span><br><br></code></pre></td></tr></table></figure><p>结构体嵌套实现继承</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// base.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span>* type;<br>&#125; Base;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">base_init</span><span class="hljs-params">(Base* b, <span class="hljs-type">int</span> id, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* type)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">base_cleanup</span><span class="hljs-params">(Base* b)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">base_print</span><span class="hljs-params">(<span class="hljs-type">const</span> Base* b)</span>;<br><br><span class="hljs-comment">// derived.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Base base; <span class="hljs-comment">// 必须作为第一个成员</span><br>    <span class="hljs-type">double</span> value;<br>&#125; Derived;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">derived_init</span><span class="hljs-params">(Derived* d, <span class="hljs-type">int</span> id, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* type, <span class="hljs-type">double</span> value)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">derived_print</span><span class="hljs-params">(<span class="hljs-type">const</span> Derived* d)</span>;<br><br><span class="hljs-comment">// derived.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">derived_print</span><span class="hljs-params">(<span class="hljs-type">const</span> Derived* d)</span> &#123;<br>    base_print(&amp;d-&gt;base); <span class="hljs-comment">// 调用基类方法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value: %f\n&quot;</span>, d-&gt;value);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数指针实现多态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// shape.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> <span class="hljs-title">Shape</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shape</span> &#123;</span><br>    <span class="hljs-type">void</span> (*draw)(Shape*); <span class="hljs-comment">// 虚函数</span><br>    <span class="hljs-type">void</span> (*move)(Shape*, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br>    <span class="hljs-type">void</span> (*destroy)(Shape*);<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_draw</span><span class="hljs-params">(Shape* s)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_move</span><span class="hljs-params">(Shape* s, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">shape_destroy</span><span class="hljs-params">(Shape* s)</span>;<br><br><span class="hljs-comment">// circle.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Shape base; <span class="hljs-comment">// 必须作为第一个成员</span><br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> radius;<br>&#125; Circle;<br><br>Circle* <span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius)</span>;<br><br><span class="hljs-comment">// circle.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">circle_draw</span><span class="hljs-params">(Shape* s)</span> &#123;<br>    Circle* c = (Circle*)s;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Drawing circle at (%d,%d) radius %d\n&quot;</span>, c-&gt;x, c-&gt;y, c-&gt;radius);<br>&#125;<br><br>Circle* <span class="hljs-title function_">circle_create</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius)</span> &#123;<br>    Circle* c = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Circle));<br>    c-&gt;base.draw = circle_draw;<br>    c-&gt;base.move = circle_move;<br>    c-&gt;base.destroy = circle_destroy;<br>    c-&gt;x = x;<br>    c-&gt;y = y;<br>    c-&gt;radius = radius;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完整示例：动物类层次结构"><a href="#完整示例：动物类层次结构" class="headerlink" title="完整示例：动物类层次结构"></a>完整示例：动物类层次结构</h4><p>基类定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> <span class="hljs-title">Animal</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-type">void</span> (*speak)(Animal*);<br>    <span class="hljs-type">void</span> (*destroy)(Animal*);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">animal_speak</span><span class="hljs-params">(Animal* a)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">animal_destroy</span><span class="hljs-params">(Animal* a)</span>;<br></code></pre></td></tr></table></figure><p>派生类dog</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dog_speak</span><span class="hljs-params">(Animal* a)</span> &#123;<br>    Dog* d = (Dog*)a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s the dog says: Woof! (Breed: %d)\n&quot;</span>, d-&gt;base.name, d-&gt;breed);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dog_destroy</span><span class="hljs-params">(Animal* a)</span> &#123;<br>    Dog* d = (Dog*)a;<br>    <span class="hljs-built_in">free</span>((<span class="hljs-type">char</span>*)d-&gt;base.name);<br>    <span class="hljs-built_in">free</span>(d);<br>&#125;<br><br>Dog* <span class="hljs-title function_">dog_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> breed)</span> &#123;<br>    Dog* d = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Dog));<br>    d-&gt;base.speak = dog_speak;<br>    d-&gt;base.destroy = dog_destroy;<br>    d-&gt;base.name = strdup(name);<br>    d-&gt;breed = breed;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类cat</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Animal base;<br>    <span class="hljs-type">int</span> color;<br>&#125; Cat;<br><br>Cat* <span class="hljs-title function_">cat_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> color)</span>;<br></code></pre></td></tr></table></figure><p>使用多态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Animal* animals[<span class="hljs-number">3</span>];<br>    <br>    animals[<span class="hljs-number">0</span>] = (Animal*)dog_create(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">1</span>);<br>    animals[<span class="hljs-number">1</span>] = (Animal*)cat_create(<span class="hljs-string">&quot;Whiskers&quot;</span>, <span class="hljs-number">2</span>);<br>    animals[<span class="hljs-number">2</span>] = (Animal*)dog_create(<span class="hljs-string">&quot;Max&quot;</span>, <span class="hljs-number">3</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        animal_speak(animals[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        animal_destroy(animals[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚表实现多态"><a href="#虚表实现多态" class="headerlink" title="虚表实现多态"></a>虚表实现多态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vtable.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span> (*speak)(<span class="hljs-type">void</span>*);<br>    <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span>*);<br>&#125; AnimalVTable;<br><br><span class="hljs-comment">// animal.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Animal</span> &#123;</span><br>    <span class="hljs-type">const</span> AnimalVTable* vtable;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">animal_speak</span><span class="hljs-params">(Animal* a)</span> &#123;<br>    a-&gt;vtable-&gt;speak(a);<br>&#125;<br><br><span class="hljs-comment">// dog.c</span><br><span class="hljs-type">static</span> AnimalVTable dog_vtable = &#123;<br>    .speak = dog_speak,<br>    .destroy = dog_destroy<br>&#125;;<br><br>Dog* <span class="hljs-title function_">dog_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> breed)</span> &#123;<br>    Dog* d = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Dog));<br>    d-&gt;base.vtable = &amp;dog_vtable;<br>    d-&gt;base.name = strdup(name);<br>    d-&gt;breed = breed;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kalman滤波</title>
    <link href="/2025/04/01/Kalman%20%E6%BB%A4%E6%B3%A2/"/>
    <url>/2025/04/01/Kalman%20%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Kalman-滤波"><a href="#Kalman-滤波" class="headerlink" title="Kalman 滤波"></a>Kalman 滤波</h1><blockquote><p>怎么选择状态量和观测量</p><p>怎么建立状态方程和观测方程</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Kalman滤波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIPI协议</title>
    <link href="/2025/03/22/MIPI%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/03/22/MIPI%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>MIPI协议</strong></p><p>两种工作模式：</p><p>HS：主要用于高速的数据传输，功耗较大</p><p>LP：主要用于低速的一些控制信号，功耗较小</p><blockquote><p>数据处理</p></blockquote><p>字节对齐</p><p>lane对齐</p><p>数据解包</p><p>像素解包</p>]]></content>
    
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>音视频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS内核任务链表与状态切换(一)</title>
    <link href="/2025/03/05/FreeRTOS%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2(%E4%B8%80)/"/>
    <url>/2025/03/05/FreeRTOS%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeRTOS内核任务链表与状态切换-一"><a href="#FreeRTOS内核任务链表与状态切换-一" class="headerlink" title="FreeRTOS内核任务链表与状态切换(一)"></a><strong>FreeRTOS内核任务链表与状态切换(一)</strong></h1><p>首先创建(静态)任务会在SRAM里的.bss段的FreeRTOS_HEAP_SIZE里生成一个TCB块</p><img src="/2025/03/05/FreeRTOS%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2(%E4%B8%80)/1a23e6ef-621e-49d3-b9b3-37c3570516bb.png" class=""><p>TCB块里会有一个结构体，这个结构体存储了以下数据</p><img src="/2025/03/05/FreeRTOS%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2(%E4%B8%80)/808b660a-7f3d-4e6a-bf66-39a950f7707a.png" class=""><p>pxTopOfStack指向该任务的栈顶（通过PSP指针初始化栈寄存器）</p><p>*pxStack指向该任务的栈底</p><p>比较关键的是xStateListitem和xEventListitem这两个成员</p><p>xStateListitem主要挂载到os调度有关的链表（就绪，延迟，等待删除，挂起）</p><p>xEventListitem主要挂载到Queue相关的链表</p><img src="/2025/03/05/FreeRTOS%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2(%E4%B8%80)/d936a597-ac51-41fe-8867-a88924375b84.png" class=""><p>os链表如图所示，其中就绪链表的数量与任务优先级数量有关，每个优先级对应一个就绪链表（由uxPriority决定，优先级数字越大，越早进行调度）</p><p>所以内核调度（PendSV）时会有一个pxCurentTCB指针，这个指针先顺着链表找，当它找到想要的成员（xStateListitem或xEventListitem）时，它就会顺着指向这个任务的TCB块</p><p>但实际上如果按上图所说链表长这样，那肯定会有很多空间被浪费，所以实际上的架构如下图所示</p><img src="/2025/03/05/FreeRTOS%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E9%93%BE%E8%A1%A8%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2(%E4%B8%80)/00e8822f-7373-4d38-92ea-100e7e02ef36.png" class=""><p>当FreeRTOS被初始化完后，与os调度相关的链表（与xStateListitem有关）就作为全局静态变量存在os的堆栈空间里</p><p>而Queue链表则作为局部变量是在Queue初始化时创建</p><p>每个节点就是上图中的结构体Listitem_t，只和自己节点的上一个节点和下一个节点有关</p><p>xListEnd其实是链表里的一个哨兵节点</p>]]></content>
    
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootloader</title>
    <link href="/2025/03/05/bootloader/"/>
    <url>/2025/03/05/bootloader/</url>
    
    <content type="html"><![CDATA[<h1 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a><strong>bootloader</strong></h1><blockquote><p>单片机启动流程</p></blockquote><p>首地址是MSP</p><p>中断向量表</p><blockquote><p>跳转配置</p></blockquote><ul><li><p>将APP程序加载到支持运行程序的Flash或者RAM中</p></li><li><p>复位RCC时钟</p></li><li><p>复位所有开启的外设</p></li><li><p>关闭滴答</p></li><li><p>关闭所有中断</p></li><li><p>设置跳转PC，SP和Control寄存器</p></li><li><p>如果用了RTOS，则要设置为特权级模式，使用MSP指针</p></li></ul><blockquote><p>APP程序问题</p></blockquote><ul><li>APP程序入口依然是复位中断服务程序</li><li>注意设置APP的中断向量表地址</li><li>BOOT占用的RAM空间可以全部被APP使用</li><li>APP程序版本号和程序完整性问题（CRC或MD5校验）</li><li>固件加密</li><li>APP调回BOOT，使用NVIC_SystemReset软件复位</li></ul><blockquote><p>调试下载</p></blockquote><ul><li>将BOOT下载进去猴，就可以传统方式调试APP的程序</li><li>APP或BOOT程序排查问题</li></ul><blockquote><p>移植步骤</p></blockquote><ul><li><p>编译器生成.hex文件</p></li><li><p>移植output.hex和hex2bin文件</p><p><code>这块有些问题</code></p></li></ul><p>要确定下载媒介是什么（eMMC，SD卡，U盘）</p><blockquote><p>加密算法</p></blockquote><p>AES加密（密钥）</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FOC</title>
    <link href="/2025/02/05/FOC/"/>
    <url>/2025/02/05/FOC/</url>
    
    <content type="html"><![CDATA[<h1 id="FOC"><a href="#FOC" class="headerlink" title="FOC"></a>FOC</h1><p>实现效果</p><iframe   width="800"   height="450"   src='e1be5e4e059862398241510a987e935f.mp4'   frameborder="0"   allowfullscreen></iframe><h4 id="1-配置定时器输出三路PWM"><a href="#1-配置定时器输出三路PWM" class="headerlink" title="1.配置定时器输出三路PWM"></a>1.配置定时器输出三路PWM</h4><p>（这个方案基于驱动IC，驱动IC接收MCU3路PWM输入，转换成3对互补PWM输出，用于驱动三相桥的6个mosfet，并且驱动IC可以自动插入死区时间，如果选择不用驱动IC的方案则需手动配置6路互补PWM并且要考虑死区插入等一系列问题）</p><p>注意pwm的三个参数：频率，分辨率，占空比</p><h4 id="2-使电机转到固定电角度"><a href="#2-使电机转到固定电角度" class="headerlink" title="2.使电机转到固定电角度"></a>2.使电机转到固定电角度</h4><p>通过park反变换和clark反变换最终实现输入电角度和电压，输出合适的三相pwm</p><h4 id="3-开环速度"><a href="#3-开环速度" class="headerlink" title="3.开环速度"></a>3.开环速度</h4><p>根据时间生成一个逐渐增大的电角度并调用相关函数即可让电机持续转动  </p><p>这里要配置定时器并开启定时器中断</p><p>最终实现输入速度，只要让电角度按固定步长增长，就能实现电机开环控制，固定步长的计算为循环运行时间间隔*目标速度（需要注意单位一致）</p><h4 id="4-AS5600获取角度"><a href="#4-AS5600获取角度" class="headerlink" title="4.AS5600获取角度"></a>4.AS5600获取角度</h4><p>通过软件I2C与传感器通信</p><h4 id="5-电角度对齐"><a href="#5-电角度对齐" class="headerlink" title="5.电角度对齐"></a>5.电角度对齐</h4><p>将AS5600和电角度的量程尺度化为一致</p><h4 id="6-闭环位置"><a href="#6-闭环位置" class="headerlink" title="6.闭环位置"></a>6.闭环位置</h4><h4 id="7-AS5600获取速度（注意方向问题）"><a href="#7-AS5600获取速度（注意方向问题）" class="headerlink" title="7.AS5600获取速度（注意方向问题）"></a>7.AS5600获取速度（注意方向问题）</h4><p>传感器接收两次角度的差&#x2F;间隔时间&#x3D;角速度</p><h4 id="8-闭环速度"><a href="#8-闭环速度" class="headerlink" title="8.闭环速度"></a>8.闭环速度</h4><p>引入pid算法，输入期望速度，计算需要的合适的q轴电压值，然后调用函数生成pwm波控制</p><h4 id="9-闭环位置"><a href="#9-闭环位置" class="headerlink" title="9.闭环位置"></a>9.闭环位置</h4><h4 id="10-获取Iq电流"><a href="#10-获取Iq电流" class="headerlink" title="10.获取Iq电流"></a>10.获取Iq电流</h4><p>配置ADC+DMA用于读取采样电阻阻值（滤波），根据阻值算出电流</p><h4 id="11-Iq电流闭环"><a href="#11-Iq电流闭环" class="headerlink" title="11.Iq电流闭环"></a>11.Iq电流闭环</h4><p>输入期望速度，计算需要的合适的q轴电流值</p><h4 id="12-双闭环或者三闭环"><a href="#12-双闭环或者三闭环" class="headerlink" title="12.双闭环或者三闭环"></a>12.双闭环或者三闭环</h4><p>核心思想就是位置PID输出给速度环PID,速度环输出给电流环PID，在这个过程中可以限定输出范<br>围，如0.1A、速度。即限定力矩。  </p><h4 id="13-CAN通信"><a href="#13-CAN通信" class="headerlink" title="13.CAN通信"></a>13.CAN通信</h4><p>硬件加入can收发器，软件加入can通信</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>FOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分散加载</title>
    <link href="/2025/01/20/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD/"/>
    <url>/2025/01/20/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="分散加载"><a href="#分散加载" class="headerlink" title="分散加载"></a><strong>分散加载</strong></h1><img src="/2025/01/20/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD/image-20250811162225845.png" class=""><p>这块碰到再详细学一下</p><p><a href="https://www.bilibili.com/video/BV1MR4y157XS?t=2457.3">https://www.bilibili.com/video/BV1MR4y157XS?t=2457.3</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MCU启动流程</title>
    <link href="/2024/09/22/MCU%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/09/22/MCU%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="MCU启动流程"><a href="#MCU启动流程" class="headerlink" title="MCU启动流程"></a><strong>MCU启动流程</strong></h4><img src="/2024/09/22/MCU%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/e2939426-7334-437f-be36-495cb5ce0872.png" class=""><img src="/2024/09/22/MCU%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/f74c7b9f-0983-4b8b-8e20-6b6cb6c51d88.png" class=""><img src="/2024/09/22/MCU%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/a7146b0a-71c9-43e8-bb9c-c741b93c7b74.png" class=""><p>以cm3和cm4为例（cm7会有不同）</p><p>上电复位后硬件强制PC指向自举区的入口地址，先执行自举区代码（初始化基础时钟-&gt;通过boot引脚检测启动模式），如果（boot0&#x3D;0，boot1&#x3D;0）从主flash启动，那么就会将用户flash（0x08000000）重映射到0x00000000中，如果（boot0&#x3D;1，boot1&#x3D;0）从系统存储器启动，那么就会跳转到系统bootloader，如果（boot0&#x3D;1，boot1&#x3D;1）从SRAM启动           还有一种特殊情况就是使用了选项字节，这个时候就不看boot引脚状态</p><p>如果从主flash启动，就从0x00000000读MSP，0x00000000读PC（PC此时指向reset_handler地址，由于重映射关系，该地址一般是0x08000004之后的某一地址），读完地址就会跳转到该地址执行reset_handler（初始化.data,.bss,系统时钟……）最后执行main（）</p><p>如果从系统存储区启动，就会将系统存储器物理地址重映射到0x00000000上，然后跳转到系统bootloader（根据自举区固化好的代码，这个代码存储了系统bootloader的入口地址），bootloader会先初始化（初始化外设通信，配置外设时钟，初始化GPIO，初始化flash编程接口），然后bootloader会进入一个主循环（在这个循环中发送或等待特定协议用于监听主机发送命令），接收到主机各种命令后会进行处理（如擦除flash，接收bin&#x2F;hex文件数据写入用户flash地址里，读flash，……），最后会执行用户程序reset_handler（初始化.data,.bss,系统时钟……）最后执行main（）</p><p>如果从SRAM启动，其实就是debug过程会执行（）</p><p>在复位处理函数中，先初始化堆栈指针（将从向量表加载的初始SP值设置到硬件堆栈指针寄存器中），然后初始化.data段（存放已初始化的全局变量和静态变量）清零.bss段，再初始化系统时钟（调用systeminit函数）初始化浮点运算单元和MPU，最后跳转到main（）函数</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPU和cache</title>
    <link href="/2024/09/20/MPU%E5%92%8Ccache/"/>
    <url>/2024/09/20/MPU%E5%92%8Ccache/</url>
    
    <content type="html"><![CDATA[<h1 id="MPU和cache"><a href="#MPU和cache" class="headerlink" title="MPU和cache"></a><strong>MPU和cache</strong></h1><p>为什么要有MPU：阻止用户应用破坏关键任务；阻止代码注入攻击；改变内存访问属性；</p><p>cache的作用：以H7为例，内核480M，RAM只有240M，通过cache就能实现类似倍频的效果；</p><p>MPU一般有16个域，每个域配置8个等大小的子域（子域最小大小受cache line影响，禁止子域就是禁止该子域的MPU配置）优先级值越大，优先级越高，当域存在重叠时，以优先级高的域的配置为主；</p><p>内存类型分为下面三种类型</p><p>Normal memory：由DRAM，SRAM，FLASH等通用存储介质组成，支持cache缓存，预取，允许乱序访问，缓冲合并，充分发挥了各种机制，所以性能最强；</p><p>Device memory：内存映射外部寄存器，不可缓存，不可预取，严格顺序访问，禁止写合并，性能稍差；</p><p>Strongly-ordered Memory：系统关键组件，不可缓存，不可预取，绝对顺序执行(严格按照指令顺序执行)，禁止任何缓冲，所有访问全局可观察，性能最差，访问延迟最长；</p><p><strong>MPU配置：</strong>  </p><p>内存属性</p><p>XN：执行禁止，标记内存区域是否允许执行指令，默认使能即可；</p><p>AP：访问权限，决定CPU特权级和用户级的读写权限；</p><p>TEX:拓展内存类型；</p><p>S：是否支持多核&#x2F;总线主设备共享；</p><p>C：数据是否可缓存；</p><p>B：写操作是否允许缓冲；</p><img src="/2024/09/20/MPU%E5%92%8Ccache/0592f54a-de70-4e12-95e2-cc8cfc6e6b74.png" class=""><p><img src="/2024/09/20/MPU%E5%92%8Ccache/0592f54a-de70-4e12-95e2-cc8cfc6e6b74.png"></p><p>配置为1011（normal   not shareable）时性能最强</p><h5 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h5><ul><li><p>为什么要有cache？</p><p>根据局部性原理，如果某个数据被访问了，那个它自身以及临近的数据都很有可能在不久的将来被访问，所以计算机决定把这些数据从慢速的主存放到快速且小的存储单元中，这个单元就是cache</p></li><li><p>cache是如何工作的</p><p>当CPU需要读取数据时，先会查询要访问的内存地址，cache控制器检查这个地址的数据是否已经在cache中，如果检查到存在则直接从cache中将数据返回给CPU，如果检查到不存在触发cache miss，具体步骤为CPU先从主内存DRAM读取包含目标地址的整个数据块（为什么这样读取涉及映射策略），将数据块载入cache，并且用替换算法淘汰cache的旧块，淘汰旧块时检测旧块是否被CPU修改过（dirty bit&#x3D;1），若被修改过则需执行write back操作</p><p>通过这一系列的操作将数据从cache返回至CPU中</p></li></ul><p>内部FLASH仅需开启指令cache即可达到最高性能；</p><p>外部QSPI FLASH开启读cache和写cache即可达到最高性能；</p><p>DTCM和ITCM主频和CPU一样，无需配置MPU和cache；</p><p>涉及到ADC+DMA读取或串口+DMA收发，在开启DMA前先clean，在读取DMA后invalidate；</p><p>涉及到DMA的数据一致性问题解决思路：在输出层调用SCB_CleanInvalidateDCache（）；(一般不建议用这个函数，因为会带来性能损失的问题)</p><p>SCB_InvalidateDCache_by_Addr：将指定地址与指定大小的Ram的内容同步到Cache中，典型使用场景为DMA接收。<br>SCB_CleanDCache_by_Addr：将指定地址与指定大小的Cache的内容同步到Ram中，典型使用场景为DMA发送。</p><p><strong>使用函数SCB_InvalidateDCache_by_Addr，SCB_CleanDCache_by_Addr等函数注意事项</strong></p><p><strong>addr ： 操作的地址一定要是32字节对齐的。</strong></p><p><strong>dsize ：一定要是32字节的整数倍</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>STM32H7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32H750VBT6学习</title>
    <link href="/2024/08/20/STM32H750VBT6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/08/20/STM32H750VBT6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32H750VBT6学习"><a href="#STM32H750VBT6学习" class="headerlink" title="STM32H750VBT6学习"></a>STM32H750VBT6学习</h1><h3 id="1-Cache（缓存）"><a href="#1-Cache（缓存）" class="headerlink" title="1.Cache（缓存）"></a>1.Cache（缓存）</h3><p>Cache是跟Flash和SRAM同一级别的存在，是一种高速小容量存储器，主要作为高速缓冲区</p><p><strong>CPU &lt;-&gt; Cache &lt;-&gt; 主存（DRAM） &lt;-&gt; 外部存储（Flash&#x2F;HDD）</strong></p><p>Cache带来了性能提升，但也引入了数据一致性问题：</p><ul><li><strong>DMA操作：</strong> 当DMA控制器（如MDMA, BDMA）直接修改了主存（SRAM）中的数据时，如果这部分数据已经被缓存在CPU的D-Cache中，那么Cache里的数据就是旧的、不一致的。CPU读到的是旧数据。</li><li><strong>外设寄存器访问：</strong> 外设寄存器通常映射到内存地址（称为内存映射I&#x2F;O）。如果CPU缓存了某个外设寄存器的值，而外设实际状态已经改变（例如中断标志置位），CPU读到的可能是缓存中的旧值，错过状态变化。</li></ul><p>暂时的解决方法：在DMA传输前后或访问关键外设寄存器前后，使用CMSIS或HAL库提供的函数（如<code>SCB_CleanDCache</code>, <code>SCB_InvalidateDCache</code>, <code>SCB_CleanInvalidateDCache</code>）来清理（将Cache数据写回内存）或无效化（丢弃Cache数据，下次从内存读）特定的Cache区域。</p><p>进阶解决方法：可以配置MPU将特定的内存区域（如SRAM区域、外设寄存器区域）标记为<code>Non-cacheable</code>（不可缓存）或<code>Write-through</code>（透写）等属性，让硬件自动处理一致性。<strong>强烈建议在使用DMA或频繁访问外设寄存器的区域配置MPU。</strong></p><h3 id="2-MDMA-master-DMA"><a href="#2-MDMA-master-DMA" class="headerlink" title="2.MDMA(master DMA)"></a>2.MDMA(master DMA)</h3><p>更强大的DMA，可以直接控制系统总线，可以访问芯片上所有的内存和外设，带宽更高，内核低功耗模式下仍能工作，支持链表传输；<strong>唯一可以访问TCM的外设</strong></p><p>MDMA控制器的工作机制克服了传统DMA控制器固有的“通道瓶颈”问题，它不再依赖于数量有限且可能被独占的物理通道，而是采用了一种基于请求优先级进行动态调度的架构（取消了通道这个概念，但是保留了优先级机制）；</p><p>链表传输：普通的DMA只能传输连续的内存区域的数据，MDMA通过硬件自动遍历链表结构实现链表传输，典型应用场景为处理非连续数据时，比如多个Packet Buffer，多帧数据，非连续的磁盘扇区；</p><p>提供 5 个事件标志（ MDMA 通道传输完成、 MDMA 块传输完成、 MDMA 块重复传输完成、 MDMA 缓冲区传输完成、 MDMA 传输出错），且这些标志可生成中断。  </p><h3 id="3-BDMA（basic-DMA）"><a href="#3-BDMA（basic-DMA）" class="headerlink" title="3.BDMA（basic DMA）"></a>3.BDMA（basic DMA）</h3><p>专注于低功耗的DMA，位于低功耗域，在standby模式下仍能使用，功能较少，通道数少，只能访问低功耗域范围的SRAM和外设数据</p><h3 id="4-FDCAN"><a href="#4-FDCAN" class="headerlink" title="4.FDCAN"></a>4.FDCAN</h3><p>CAN升级版，最高速率可达5Mbps，相比于CAN只有8字节的数据场，支持最多64字节的数据场，显著提高有效数据吞吐量，同时支持经典CAN帧格式；</p><p>FDCAN帧可以灵活地在仲裁段使用较低速率（保证兼容性和抗干扰性），在数据段切换到高速率（提高传输效率）</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>STM32H7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPIO进阶学习 非阻塞式编程思想</title>
    <link href="/2024/07/25/GPIO%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%20%20%20%20%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/07/25/GPIO%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%20%20%20%20%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="GPIO进阶学习"><a href="#GPIO进阶学习" class="headerlink" title="GPIO进阶学习"></a><strong>GPIO进阶学习</strong></h4><p>输出状态：推挽PV 开漏OD 支持复用 </p><p>可以支持速度选择（干扰较多就把速度调低）</p><p>输入状态：上拉 下拉 模拟（主要用于ADC） 浮空    支持复用</p><p> 可以从手册中看上拉下拉电阻的阻值</p><p>当配置为复用模式时，输入寄存器IDR可以正常读取，输出寄存器无法正常读取（由手册读出）</p><p>模拟输入寄存器可以直接读ADC（注意寄存器是否受基准电压影响）</p><p>备份域（RTC）</p><p>拉电流 灌电流 注入电流</p><h4 id="非阻塞式编程"><a href="#非阻塞式编程" class="headerlink" title="非阻塞式编程"></a><strong>非阻塞式编程</strong></h4><p>按键：  用循环队列fifo存储按键状态（按下 松开 长按），然后定时器每过固定时间检测fifo值，可以避免delay  </p><p>蜂鸣器：</p><p><strong>Event Recorder狂暴模式</strong></p><p>需要单独设置ram，然后用分散加载</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
      <tag>STM32H7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>芯片启动到运行流程（以stm32H7为例）</title>
    <link href="/2024/04/25/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E5%88%B0%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5stm32H7%E7%B3%BB%E5%88%97%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/2024/04/25/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E5%88%B0%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5stm32H7%E7%B3%BB%E5%88%97%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="芯片启动到运行流程（以stm32H7系列为例）"><a href="#芯片启动到运行流程（以stm32H7系列为例）" class="headerlink" title="芯片启动到运行流程（以stm32H7系列为例）"></a><strong>芯片启动到运行流程（以stm32H7系列为例）</strong></h1><p>1.芯片供电域（看芯片手册）</p><p>2.上电启动流程（从硬件上看）</p><p>上电复位和手动复位都是操作电容</p><img src="/2024/04/25/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E5%88%B0%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5stm32H7%E7%B3%BB%E5%88%97%E4%B8%BA%E4%BE%8B%EF%BC%89/image-20250811130212246.png" class=""><img src="/2024/04/25/%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E5%88%B0%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5stm32H7%E7%B3%BB%E5%88%97%E4%B8%BA%E4%BE%8B%EF%BC%89/image-20250811130619576.png" class=""><p>从图上看感觉就是各种时钟的初始化</p><p>3.软件启动流程</p><p>启动文件路径（Drivers-&gt;CMSIS-&gt;Device-&gt;ST-&gt;STM32H7xx-&gt;Source-&gt;Templates-&gt;各种种类启动文件如iar mdk gcc）</p><p>中断向量表（重点）</p><p>4.整个工程启动流程</p><p>5.加载域 运行域     .map文件   .html文件</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NVIC中断管理和优先级动态分配</title>
    <link href="/2024/04/20/NVIC%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"/>
    <url>/2024/04/20/NVIC%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p><strong>NVIC中断管理和优先级动态分配</strong></p><p>抢占优先级（可以抢占）</p><p>子优先级（不能抢占，只能优先）</p><p>数值越小越优先；</p><p>在debug中可以看NVIC(路径是debug中全速运行，然后打开外设栏，内核外设栏，NVIC)</p><p>（此处缺少一张截图）</p><p>E指enable，P指挂起，A指active；</p><p>尽量多用局部中断少用全局中断（以串口FIFO为例，用到哪个外设就调用那个外设的中断而非全局中断）；</p><p>中断中不要做64倍除法，不要调用c库函数；</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宇树GO8010电机断联问题寄录</title>
    <link href="/2024/01/05/%E5%AE%87%E6%A0%91GO8010%E7%94%B5%E6%9C%BA%E6%96%AD%E8%81%94%E9%97%AE%E9%A2%98%E5%AF%84%E5%BD%95/"/>
    <url>/2024/01/05/%E5%AE%87%E6%A0%91GO8010%E7%94%B5%E6%9C%BA%E6%96%AD%E8%81%94%E9%97%AE%E9%A2%98%E5%AF%84%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="宇树GO8010电机断联问题寄录"><a href="#宇树GO8010电机断联问题寄录" class="headerlink" title="宇树GO8010电机断联问题寄录"></a>宇树GO8010电机断联问题寄录</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>电机在发一个跳变比较大但是恒定的T或者W的时候电机会突然失联，但是如果给这个T或者W上一个随机的大小0.01左右的抖动，让发送到电机的控制报实时变化，电机又可以正常控制</p><h2 id="原因排查过程"><a href="#原因排查过程" class="headerlink" title="原因排查过程"></a>原因排查过程</h2><p>一开始的想法觉得是电机驱动板可能开启了内置看门狗，且喂狗逻辑是前后接收两个不同的报文触发。但这个想法很快就排除了，因为软件逻辑不符合常理，宇树的驱动板应该不会犯这种错误。</p><p>然后试了一下发小力矩和小速度的情况，然后给一个突变的小力矩，发现电机未故障。于是猜测是大跳变导致电机触发了某种保护，从而进入了锁死或故障状态，然后后续发的小抖动包刚好解除了这个故障状态，并恰好以一种安全的方式重新启动了电机。</p><h2 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h2><p>使用RS485转usb模块将电机与电脑上位机连接，然后重现问题，读取上位机的电机错误码，验证猜想成功</p><img src="/2024/01/05/%E5%AE%87%E6%A0%91GO8010%E7%94%B5%E6%9C%BA%E6%96%AD%E8%81%94%E9%97%AE%E9%A2%98%E5%AF%84%E5%BD%95/1.png" class=""><img src="/2024/01/05/%E5%AE%87%E6%A0%91GO8010%E7%94%B5%E6%9C%BA%E6%96%AD%E8%81%94%E9%97%AE%E9%A2%98%E5%AF%84%E5%BD%95/2.png" class=""><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>软件加入斜坡控制</p>]]></content>
    
    
    
    <tags>
      
      <tag>motor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DJI robomaster C板陀螺仪驱动调试寄录</title>
    <link href="/2023/11/08/DJI%20robomaster%20C%E6%9D%BF%E9%99%80%E8%9E%BA%E4%BB%AA%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E5%AF%84%E5%BD%95/"/>
    <url>/2023/11/08/DJI%20robomaster%20C%E6%9D%BF%E9%99%80%E8%9E%BA%E4%BB%AA%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E5%AF%84%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="robomaster-C板陀螺仪驱动调试寄录"><a href="#robomaster-C板陀螺仪驱动调试寄录" class="headerlink" title="robomaster C板陀螺仪驱动调试寄录"></a>robomaster C板陀螺仪驱动调试寄录</h1><p>首先robomaster官方C板用户手册有关于陀螺仪的使用说明和例程，但是细看会发现很多代码只是勉强能跑，只能用于学习，想要有良好的性能实现比赛场上的高强度运行，必须重新编写自己的驱动。队内上一届表现最好的全向移植的是南航开源的IMU驱动版本，但是我对其代码风格不太感冒，所以打算自己移植BMI088官方的驱动库然后再加上自己从南航的版本中学到的一些小技巧。从结果上看，我只能说相比于MPU6050，BMI088在性能上完爆但是开发体验并不是很好</p><h2 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h2><p>首先根据README给出的指引，我们只需要编写读写SPI的函数与微秒延时函数即可。微秒级延时可以直接用Systick当计数器完成（后面了解到其实最好用DWT），而SPI通信的移植就比较复杂了</p><h3 id="SPI通信"><a href="#SPI通信" class="headerlink" title="SPI通信"></a>SPI通信</h3><p>C板参考例程内CubeMX的SPI速率配置为300k，根据测试和计算，这个速率肯定是太慢了。按照每次只读取6个字节（三轴加速度计与三轴角速度计数据都是2Byte，实际只会更多）共48bit来算，至少0.2ms的时间耗费在SPI通信上。但是根据官方数据手册上给出的SPI参数，最大速率能达到到10Mhz，再根据在<a href="https://www.bosch-sensortec.com/media/boschsensortec/downloads/application_notes_1/bst-mis-an006.pdf">Application Note</a>内提到推荐2Mhz以上的通信速率。最终通过计算应用层的数据链路传输频率，我将SPI速率配置为2.625Mbps，后续经过测试，基本能实现生产和消费之间的平衡（其实不需要这么精确，只是我对于性能有强迫症）</p><img src="/2023/11/08/DJI%20robomaster%20C%E6%9D%BF%E9%99%80%E8%9E%BA%E4%BB%AA%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E5%AF%84%E5%BD%95/spi-speed.png" class=""><p>接下来就是软件方面上我从南航的代码中学到的小技巧了，SPI的读写如果使用HAL库的spi函数进行一次传输，传输速度是慢于直接用寄存器完成传输的，对于像BMI088这样对实时性要求极强的IMU，应该直接对寄存器操作来减小开销</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">uint8_t</span> <span class="hljs-title">spi_rw_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> <span class="hljs-type">byte</span>)</span></span>&#123;<br><span class="hljs-built_in">SET_BIT</span>(BMI088_SPI-&gt;CR1, SPI_CR1_SPE);<br>    <span class="hljs-keyword">while</span>((BMI088_SPI-&gt;SR &amp; SPI_SR_TXE) == RESET);<br>BMI088_SPI-&gt;DR = <span class="hljs-type">byte</span>;<br>    <span class="hljs-keyword">while</span>((BMI088_SPI-&gt;SR &amp; SPI_SR_RXNE) == RESET);<br>    <span class="hljs-keyword">return</span> BMI088_SPI-&gt;DR;<br>&#125;<br></code></pre></td></tr></table></figure><p>IMU加速度计与角速度计在同一个SPI总线上通过不同CS引脚选中，对应到BMI088官方库的移植函数则是通过传入的<code>intf_ptr</code>指明，其值是初始化中的<code>intf_ptr_accel</code>或<code>intf_ptr_gyro</code>，这里只需要判断传入参数拉低对应的片选脚即可</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">BMI08X_INTF_RET_TYPE bmi08x_spi_read(<span class="hljs-built_in">uint8</span>_t reg_addr, <span class="hljs-built_in">uint8</span>_t *reg_data, <span class="hljs-built_in">uint32</span>_t len, <span class="hljs-built_in">void</span> *<span class="hljs-built_in">int</span>f_ptr);<br>BMI08X_INTF_RET_TYPE bmi08x_spi_write(<span class="hljs-built_in">uint8</span>_t reg_addr, <span class="hljs-keyword">const</span> <span class="hljs-built_in">uint8</span>_t *reg_data, <span class="hljs-built_in">uint32</span>_t len, <span class="hljs-built_in">void</span> *<span class="hljs-built_in">int</span>f_ptr);<br></code></pre></td></tr></table></figure><p>还有一个我遇到的SPI通信中比较特殊的问题是，在每次与<strong>加速度计</strong>通信时不论是读单个寄存器还是连续读都需要先接收一个Dummy Byte，这个东西实际上是没有意义的内容。DJI C板手册中似乎没有写对这个问题的处理，但是看了一下BMI088官方的驱动是有相关的处理方式的</p><img src="/2023/11/08/DJI%20robomaster%20C%E6%9D%BF%E9%99%80%E8%9E%BA%E4%BB%AA%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E5%AF%84%E5%BD%95/spi-comm.png" class=""><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>我认为不管哪款IMU，初始化都是最难且最有可能出问题的那一步。作为MEMS器件，在上电之后需要静置稳定，不论是等待加速度计的数据稳定还是角速度计元件的起振，并且BMI088没有任何办法告诉主机它是否已经完全就绪。</p><p>通过手册得知，IMU内部也有电源管理，其数字接口与模拟部分可以分别供电且电源模式分为Suspend Mode和Normal Mode，电源模式之间的切换也需要等待稳定。了解这个是非常重要的，因为从寄存器的初始值来看，BMI088经过上电复位后加速度计是处于Suspend Mode，而角速度计是处于Normal Mode</p><p>总之按照数据手册的说法和我实际不加延时的测试，BMI088的初始化的等待至少需要</p><ul><li>加速度计上电等待1ms，切换电源模式进入Normal Mode后等待50ms</li><li>角速度计上电或切换电源模式都需要等待30ms</li><li>SPI两次写入间至少需要有2us</li></ul><p>于是我们可以分析一下，一个完整的初始化流程应该是这样的</p><ul><li>上电复位，等待30ms至IMU完全就绪</li><li>分别切换角速度计和加速度计的电源模式，每次切换等待30ms或50ms</li><li>写入输出速率，量程大小等配置，每次写入需要确保间隔2us以上（写间隔可在移植的SPI读写函数内完成）</li><li>等待数据采集</li></ul><p>其实在各种电源模式下读写寄存器的时序连官方自己都搞不太清，在移植驱动的过程中官方的仓库一直在更新，但是好在目前我移植过程还算顺利</p><p>（2024.6.18更新）我发现了一个很有意思的点，博世的官方驱动在初始化程序里给BM088上传一个类似通过软件更新固件一样的包，通过调用<code>bmi08a_load_config_file</code>函数。我在逛博世论坛时发现有人提出了这个问题并做了解释，这个东西没什么用处除非你要使用数据同步的特性（这个功能C板没戏，硬件连线都没有引出来），所以最好不要加这个以免出现不必要的初始化错误。</p><p>最后放一下我的参考资料，希望我的踩坑寄录能帮助到后续开发的同学</p><p><a href="https://github.com/RoboMaster/DevelopmentBoard-Examples">C板官方例程</a></p><p><a href="https://github.com/BoschSensortec">BoschSensortec</a>&#x2F;<a href="https://github.com/BoschSensortec/BMI08x-Sensor-API">BMI08x-Sensor-API</a></p><p><a href="https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmi088-ds001.pdf">BMI088 DataSheet</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>robomaster</tag>
      
      <tag>IMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HAL库和LL库整体框架学习</title>
    <link href="/2023/11/05/HAL%E5%BA%93%E5%92%8CLL%E5%BA%93%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/05/HAL%E5%BA%93%E5%92%8CLL%E5%BA%93%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>HAL库和LL库</strong>（可以混合使用）</p><p>hal库：函数复杂，但是直接对寄存器调用，移植方便</p><p>LL库：使用很多内联函数（省去进入和退出函数的时间）高效速度快</p><p><strong>hal库：</strong></p><p>以_IT为后缀结尾表示中断方式</p><p>用cubemx配高速时钟注意检查晶振大小要相同</p><p> HAL_Init:配置NVIC 更新全局变量SystemCoreClock（此时用的还是内部HSI48M时钟）</p><p>SystemClock_Config:配置时钟电压范围（不同电压对应不同主频）配置时钟结构体</p><p>​                                     更新时钟HAL_InitTick(此时用的是更新后时钟)</p><p>学习这些库的目的也是为了方便调用，比如用hal库初始化，然后自己写寄存器操作代码造点轮子，最后就能很快地搭建起整个代码框架</p>]]></content>
    
    
    
    <tags>
      
      <tag>MCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
