---
title: 关于一些特殊中断的思考
date: 2025-09-12 02:11:54
tags: [MCU,RTOS]
index_img: /img/avatar.png

---

# 关于一些特殊中断的思考

### 引言

​    最近有一起实习的同学问我PendSV中断在FreeRTOS运行过程中是否会“堆积”导致任务调度失败，答案当然是不会。

{% asset_img 8489ad8d-8788-4bee-99c0-343256293873.png %}

​    这是因为当有任务需要调度时，PendSV中断并不会直接抢占，而是先被systick挂起，由于PendSV中断通常设置为最低优先级，所以在systick中断结束后还需要看是否有其他高优先级的中断需要执行，然后最后才会在空闲时轮到PendSV中断。那么这个期间PendSV可能会被多次触发，也就会做多次标记挂起操作，而这其实跟一次标记挂起没什么区别，并不会多次入栈。而执行PendSV时只执行一次上下文切换，合并所有待处理调度请求。

​    所以我们可以看出这套PendSV中断的架构精髓其实在于挂起这个操作，于是我突发奇想，还有没有中断也是像PendSV中断一样先挂起后执行的。然后我找了一下相关资料发现，**有的兄弟，有的**，像PendSV这样的中断还有很多。

### 通信协议相关的中断

- ###### DMA完成中断

  DMA传输完成时产生中断，但可能被配置为批量处理，多个DMA完成中断合并为一个延迟处理，减少中断开销，提高吞吐量

- ###### 以太网MAC的RX/TX中断

  使用NAPI机制，中断被挂起，切换到轮询模式处理多个数据包，减少中断频率，提高网络性能

### 可挂起的系统异常

- ###### SVCall（SV异常）

  超级用户调用，是ARM Cortex-M的一个架构，通常设计为在特定条件下才立即响应，用于实现系统调用。它是在用户态（非特权级）的应用程序代码请求内核态（特权级）操作系统服务的标准机制。通过SVC指令（汇编）配合立即数触发具体的系统服务，然后CPU会完成压栈，更新寄存器，取向量，跳转执行SVC异常处理程序等一系列操作

- ###### UsageFault，MemManage，BusFault

  这些故障异常通常优先级很高，但是如果使能了“延迟故障处理”特性时，某些内存访问故障可能被挂起

### 外部中断的特殊模式

- ###### 电平触发中断

  中断信号必须保持有效直到ISR开始执行，如果中断被屏蔽，请求会持续挂起，直到解除屏蔽

- ###### 后期到达中断

  这个是ARM Cortex-M的一个特性，当处理器正在处理中断入口时，新到达的更高优先级中断会被记录但延迟处理，直到当前中断入口序列完成后再评估抢占

### 处理器特定的挂起机制

- ###### x86的APIC

  支持中断优先级和重定向；低优先级中断可能被挂起，直到高优先级任务完成；TPR可动态屏蔽特定优先级范围的中断；

- ###### RISC-V的CLIC

  支持中断挂起和优先级阈值配置；可配置某些中断为非抢占模式；





其实写到这里我就发现挂起作为中断的一种状态，其实先挂起后运行并不是一种特殊现象，而是中断的一种常规用法，哈哈，写都写了，先这样吧。







### 额外思考

- ###### 像PendSV中断这样的挂起和OS任务的挂起有什么区别？

  PendSV的挂起操作属于硬件中断层，是通过设置SCB->ICSR寄存器的PENDSVSET位实现的，目的就是为了延迟上下文切换，确保高优先级中断能及时响应。而OS任务挂起操作属于任务管理层，是通过OS提供的API为了任务管理而实现的，调用后任务会临时停止直到调用API恢复，这种任务状态的迁移不参与任务的调度。

- ###### freertos中中断优先级肯定比任务优先级高吗？

  针对这个问题，首先得知道freertos的一个概念：中断屏蔽范围。这个是freertos的一个可设置项，用于定义可屏蔽的中断优先级范围。为了不搞混中断优先级和任务优先级，先说明中断优先级0-15，优先级数值越大，优先级越低，而任务优先级0-15，优先级数值越大，优先级越高。中断屏蔽范围通常从0开始，到设定值例如5，那么0-5优先级的中断都会直接被OS屏蔽。

  现在有两个问题：

  1.被屏蔽的中断在任务运行时能进行抢占吗；

  2.为什么不屏蔽低优先级中断反而屏蔽高优先级中断；

  针对第一个问题，首先答案是不能。从字面意思上看，中断都被os屏蔽了，那肯定影响不到os的任务啊。具体来讲，被屏蔽的中断触发时，中断信号会被CPU接收，但不会立即执行，CPU会将中断请求挂起，直到屏蔽解除（RTOS退出临界区或离开调度器锁定的代码段），CPU开始从被挂起的最高优先级中断开始执行。为什么os要这么设计呢，其实是考虑到为了平衡实时性和安全性，因为0-5优先级的中断通常仅处理硬件紧急事件（比如NMI和HardFault），不能依赖RTOS，而6-15优先级的中断一般与外设有关，并且需要与OS交互，所以不能屏蔽，这也解释了第二个问题。未被屏蔽的中断抢占权高于所有OS任务（中断硬件优先级需高于CPU优先级）。

  通过这个问题我们也发现了，如果用了freertos，那么0-5中断就不要用于外设了。