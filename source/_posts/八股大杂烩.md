---
title: 八股大杂烩
date: 2025-09-05 13:45:13
tags: [嵌入式八股]
index_img: /img/avatar.png
---

## 八股大杂烩

#### 目录

##### [1.裸机和RTOS如何选择](#####1.裸机和RTOS如何选择)

[2.RTOS如何保证实时性](#####2.RTOS如何保证实时性)

[3.FreeRTOS源码如何实现任务调度](#####3.FreeRTOS源码如何实现任务调度)

[4.FreeRTOS如何实现任务切换](#####4.FreeRTOS如何实现任务切换)

[5.怎么判断能驱动几路电机](#####5.怎么判断能驱动几路电机)

[6.如何判断主频能带动多少电机](#####6.如何判断主频能带动多少电机)

[7.摄像头驱动底层，如何检测驱动错误](#####7.摄像头驱动底层，如何检测驱动错误)

[8.如果打印日志，如何根据日志排查12C驱动](#####8.如果打印日志，如何根据日志排查12C驱动)

[9.12C驱动的时序](#####9.12C驱动的时序)

[10.为什么需要头文件](#####10.为什么需要头文件)

[11.头文件分尖括号和双引号，应该如何写引入的顺序](#####11.头文件分尖括号和双引号，应该如何写引入的顺序)

[12.就是要先写双引号再写尖括号，为什么](#####12.就是要先写双引号再写尖括号，为什么)

[13.float可以移位吗](#####13.float可以移位吗)

[14.就是要float移位怎么办(可以用指针强转)](#####14.就是要float移位怎么办(可以用指针强转))

[15.new和malloc](#####15.new和malloc)

[16.FreeRTOS 任务调度的底层实现了解吗?](#####16.FreeRTOS 任务调度的底层实现了解吗?)

[17.STM32 单片机项目，为什么要使用消息队列可以用其他方式代替吗?](#####17.STM32 单片机项目，为什么要使用消息队列可以用其他方式代替吗?)

[18.多线程之间要传输大量的数据，如何实现?](#####18.多线程之间要传输大量的数据，如何实现?)

[19.dma的架构?](#####19.dma的架构)

[20.信号量和互斥锁的具体底层实现机制](#####20.信号量和互斥锁的具体底层实现机制)

[21.堆(Heap)和栈(Stack)的概念](#####21.堆(Heap)和栈(Stack)的概念)

[22.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度?如何在实际运行一段时间后检查栈的使用量?](#####22.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度?如何在实际运行一段时间后检查栈的使用量?)

[23.在哪些情况下栈的内容会发生改变?](#####23.在哪些情况下栈的内容会发生改变?)

[24.CPU在进行现场保存(如函数嵌套调用、中断发生时)时，具体保存哪些信息?](#####24.CPU在进行现场保存(如函数嵌套调用、中断发生时)时，具体保存哪些信息?)

[25.当系统发生异常(例如进入HardFault)时，如何定位问题的根源?](#####25.当系统发生异常(例如进入HardFault)时，如何定位问题的根源??)

[26.请描述MCU从通电启动到执行main函数的过程](#####26.请描述MCU从通电启动到执行main函数的过程)

[27.PendSV](#####27.PendSV)

[28.串口，spi，i2c，can这些如何选择](#####28.串口，spi，i2c，can这些如何选择)

[29.当DMA传输全满中断(Ful)和串口空闲中断(ldle)的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗?](#####29.当DMA传输全满中断(Ful)和串口空闲中断(ldle)的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗?)

[30.微秒级延时如何实现](#####30.微秒级延时如何实现)

[31.在I2C通信中，时序所需的延时是如何保证的?](#####31.在I2C通信中，时序所需的延时是如何保证的?)

[32.static,const,volatile作用](#####32.static,const,volatile作用)

[33.软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗?](#####33.软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗?)

[34.I2C的时钟信号(SCL)如果出现不均匀(占空比不一致或频率抖动)，会对通信造成影响吗?](#####34.I2C的时钟信号(SCL)如果出现不均匀(占空比不一致或频率抖动)，会对通信造成影响吗?)

[35.请分享你使用cmbacktrace工具定位并解决实际问题的具体案例](#####35.请分享你使用cmbacktrace工具定位并解决实际问题的具体案例)

[36.数组越界操作是否必然导致Hardfault异常?如果不引发Hardfault，可能会带来哪些其他不良后果?](#####36.数组越界操作是否必然导致Hardfault异常?如果不引发Hardfault，可能会带来哪些其他不良后果?)

[37.在Bootloader跳转到应用程序的过程中，需要关闭DMA吗?](#####37.在Bootloader跳转到应用程序的过程中，需要关闭DMA吗?)

[38.标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS/CTS这两根流控线?它们是怎么解决问题的?](#####38.标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS/CTS这两根流控线?它们是怎么解决问题的?)

[39.SPI通信时主设备和从设备时钟极性配置反了会发生什么](#####39.SPI通信时主设备和从设备时钟极性配置反了会发生什么)

[40.中断中能否获取锁](#####40.中断中能否获取锁)

[41.stm32内部有哪些寄存器](#####41.stm32内部有哪些寄存器)

[42.结构体内存对齐 为什么有这种对齐方式](#####42.结构体内存对齐 为什么有这种对齐方式)

[43.无锁操作 原子操作的底层](#####43.无锁操作 原子操作的底层)

[44.什么情况下不能使用Cache?在使用DMA的情况下，Cache flush和Cachelonq哪种方式运行效率更高，为什么?](#####44.什么情况下不能使用Cache?在使用DMA的情况下，Cache flush和Cachelonq哪种方式运行效率更高，为什么?)

[45.如果用SPI往屏上刷一个像素点，怎么操作SPI?](#####45.如果用SPI往屏上刷一个像素点，怎么操作SPI?)

[46.从机无响应的时候，如何做异常处理?](#####46.从机无响应的时候，如何做异常处理?)

[47.项目中DMA配合什么外设使用的?给一个不定长的数据怎么用USART配合DMA完成传输?怎么判断传输完成?](#####47.项目中DMA配合什么外设使用的?给一个不定长的数据怎么用USART配合DMA完成传输?怎么判断传输完成?)

[48.中断栈和任务栈有什么区别?保存在哪里?](#####48.中断栈和任务栈有什么区别?保存在哪里?)

[49.要实现任务调度，可以只有systick中断，不用pensv吗?pensv有什么优势?](#####49.要实现任务调度，可以只有systick中断，不用pensv吗?pensv有什么优势?)

[50.任务间通信方式?](#####50.任务间通信方式?)

[51.IAP升级做了什么工作?](#####51.IAP升级做了什么工作?)

[52.内存踩踏严重调用栈现场破坏严重的情况下如何定位问题?](#####52.内存踩踏严重调用栈现场破坏严重的情况下如何定位问题?)

[53.互斥量，信号量，临界区有什么区别和应用场景?](#####53.互斥量，信号量，临界区有什么区别和应用场景?)

[55.陀螺仪通信时碰到的问题?](#####55.陀螺仪通信时碰到的问题?)

[56.嵌入式中内存泄漏和内存碎片的区别是什么?如何预防?](#####56.嵌入式中内存泄漏和内存碎片的区别是什么?如何预防?)

[57.虚函数的实现原理是什么?RTOS中使用它有哪些开销?](#####57.虚函数的实现原理是什么?RTOS中使用它有哪些开销?)

[58.SPI和 12℃ 的核心区别有哪些?云台 IMU 选哪种协议更合适?](#####58.SPI和 12℃ 的核心区别有哪些?云台 IMU 选哪种协议更合适?)

[59.如何通过示波器波形判断 12C 丢包是 SCL拉伸异常还是从设备响应延迟导致?](#####59.如何通过示波器波形判断 12C 丢包是 SCL拉伸异常还是从设备响应延迟导致?)

[60.FreeRTOS 和 Linux 二者调度算法有何差异?](#####60.FreeRTOS 和 Linux 二者调度算法有何差异?)

[61.ARM Cortex-M 内核中，如何通过栈回溯定位 HardFault 异常的根本原因?](#####61.ARM Cortex-M 内核中，如何通过栈回溯定位 HardFault 异常的根本原因?)

[62.Bootloader 双分区备份下，升级断电后如何判断加载原分区还是修复新分区?](#####62.Bootloader 双分区备份下，升级断电后如何判断加载原分区还是修复新分区?)

[63.CAN总线仲裁原理](#####63.CAN总线仲裁原理)

[64..对于有多个核的MCU，内存屏障有了解过吗](#####64.对于有多个核的MCU，内存屏障有了解过吗)

[65.从源码到可执行文件的过程](#####65.从源码到可执行文件的过程)

[66.并发与并行](#####66.并发与并行)

[67.代码架构](#####67.代码架构)











##### 1.裸机和RTOS如何选择

裸机开发：要避免用延时函数，多用时间触发调度器

优势：无任务切换开销；无RTOS内核，资源占用低；直接运行main，启动速度快；

RTOS：多任务独立运行；互斥锁/信号量安全访问共享资源；动态优先级，紧急任务可抢占；开发效率高

RTOS实现了高内聚，低耦合

##### 2.RTOS如何保证实时性

- 抢占式调度：高优先级任务可立即抢占低优先级任务的cpu使用权
- 优先级翻转与继承
- 中断控制器优化：NVIC嵌套中断支持0延迟抢占，
- 使用了精确时钟源       

##### 3.FreeRTOS源码如何实现任务调度

每个任务对应一个 `Task Control Block`结构体，存储：

- 任务栈指针（`pxStack`）
- 任务状态（就绪/阻塞/挂起）
- 优先级（`uxPriority`）
- 任务函数指针（`pxTaskFunction`）
- 任务列表节点（`xStateListItem`和 `xEventListItem`）

1. **就绪列表（Ready List）**
   - 按优先级组织的链表数组 `pxReadyTasksLists[configMAX_PRIORITIES]`，每个优先级一个链表。
   - 任务创建时根据优先级插入对应链表。
2. **阻塞状态**
   - 任务因延时或等待资源时，从就绪列表移至阻塞列表（`xDelayedTaskList1/xDelayedTaskList2`）。
   - 通过 `vTaskDelay()`或信号量/队列等API触发。
3. **挂起状态**
   - 调用 `vTaskSuspend()`将任务移至挂起列表（`xSuspendedTaskList`），不参与调度。

1. **抢占式调度（Preemptive）**
   - 高优先级任务就绪时立即抢占当前任务（通过 `taskYIELD()`或中断中调用 `portYIELD_FROM_ISR()`）。
   - 依赖硬件定时器中断（如SysTick）触发 `xPortSysTickHandler()`。
2. **时间片调度（Round-Robin）**
   - 同优先级任务共享CPU时间，通过 `configUSE_TIME_SLICING`启用。

1. **主动触发**
   - 调用 `taskYIELD()`手动请求调度。
   - 调用 `vTaskDelay()`、`xQueueSend()`等API导致任务状态变化。
2. **中断触发**
   - 系统时钟中断（如SysTick）检查阻塞任务超时。
   - 外设中断释放信号量/队列时，调用 `xHigherPriorityTaskWoken`标记高优先级任务就绪。

1. **PendSV 中断**
   - 实际任务切换在低优先级的 `PendSV_Handler`中完成，避免在外部中断中处理耗时操作。
   - 通过设置 `ICSR.PENDSVSET`触发。
2. **上下文切换**
   - 保存当前任务寄存器到栈（`vPortSVCHandler`）。
   - 从新任务的栈恢复寄存器（`pxCurrentTCB`指向新任务TCB）。

```
// 简化版任务切换流程
void xPortPendSVHandler(void) {
    save_current_task_context();  // 保存旧任务上下文
    pxCurrentTCB = get_highest_priority_task(); // 选择新任务
    restore_new_task_context();   // 恢复新任务上下文
}
```

- **静态优先级**：任务创建时指定，运行时不可更改（除非手动修改TCB）。
- **优先级继承**：互斥量（`xSemaphoreCreateMutex()`）可防止优先级反转。

1. 任务A调用 `vTaskDelay(100)`进入阻塞状态。
2. 调度器从就绪列表选择最高优先级任务B运行。
3. SysTick 中断发现任务A阻塞到期，将其移回就绪列表。
4. 若任务A优先级高于B，触发 `PendSV`切换回任务A。

##### 5.怎么判断能驱动几路电机

1. 列出MCU的PWM/GPIO资源（数据手册查定时器和引脚复用表）。

2. 确认驱动芯片支持的路数（如DRV8833=2路）。

3. 计算电源总电流是否满足（电机峰值电流×路数）。

4. ##### 评估软件任务调度能力（FreeRTOS任务数 + 中断频率）。

##### 6.如何判断主频能带动多少电机

1. 确定控制频率（如FOC需10kHz，步进电机需50kHz）。
2. 计算单路耗时（算法+采样+通信）。
3. 评估CPU利用率：
   - 实时严格模式：`N ≤ (控制周期时间 × 可用CPU比例) / 单路耗时`
   - 宽松模式：可降低频率或优化算法。
4. 硬件优化：使用FPU/DMA/多核分担负载。

##### 7.摄像头驱动底层，如何检测驱动错误

##### 8.如果打印日志，如何根据日志排查12C驱动

##### 9.12C驱动的时序

##### 10.为什么需要头文件

- 声明与定义分离
- 编译效率优化
- ·可以通过头文件控制哪些符号对外可见

##### 11.头文件分尖括号和双引号，应该如何写引入的顺序

<>:编译器预设路径     系统库路径

“”：当前文件所在目录    编译器预设路径

##### 12.就是要先写双引号再写尖括号，为什么

双引号一般是本地头文件，尖括号一般是系统/第三方头文件

可以暴露本地头文件的依赖问题

避免宏污染和名称冲突

明确模块化设计责任

##### 13.float可以移位吗

正常来说不行。

##### 14.就是要float移位怎么办(可以用指针强转)

用数学等效操作；先分离符号，指数，尾数

##### 15.new和malloc

##### 16.FreeRTOS 任务调度的底层实现了解吗?

##### 17.STM32 单片机项目，为什么要使用消息队列可以用其他方式代替吗?

1. **跨任务异步通信**

- **典型场景**：中断服务程序（ISR）与任务间传递数据

```
// 中断中发送消息（非阻塞）
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    uint8_t data = READ_REG(GPIO->IDR);
    xQueueSendFromISR(xQueue, &data, NULL); 
}
```

**优势**：避免全局变量共享带来的竞态风险。

2. **数据缓冲与流量控制**

- **硬件场景**：UART接收不定长数据包

```
// 串口DMA接收完成后解析
void vUARTTask(void *pvParameters) {
    uint8_t buf[128];
    while(1) {
        xQueueReceive(xUARTQueue, buf, portMAX_DELAY);
        parse_packet(buf); // 安全处理数据
    }
}
```

**优势**：队列长度 (`uxQueueLength`) 天然实现背压机制。

3. **优先级消息排序**

FreeRTOS消息队列支持优先级插入：

```
xQueueSendToFront(xQueue, &highPriorityMsg, 0); // 紧急消息插队
```

##### 18.多线程之间要传输大量的数据，如何实现?

##### 19.dma的架构

DMA根据工作模式分为普通DMA和SGDMA，普通DMA要求源地址和目标地址必须是连续的，而SGDMA则使用链表描述不连续的存储空间，从而提高传输效率。

DMA硬件上包括三个部分：DMA控制器（负责整个DMA传输过程的控制），主模式控制电路和从模式控制电路（分别控制DMA模块在不同总线系统下的工作状态），数据通道FIFOs（用于总线端和外设之间的速率匹配和缓冲）

DMA传输过程：CPU配置DMAC用于数据传输；CPU将源地址，目的地址和传输数据字节数写入DMAC；外设准备就绪并通知DMAC，DMAC向CPU发出HOLD信号请求占用总线；CPU响应DMAC的请求，并将总线控制移交给DMAC；DMA模块读端口从源地址读数据，写端口向目的地址写数据；传输完成时，DMA结束传输并向CPU发出中断请求；CPU响应DMA的中断请求，对传输的数据进行校验

##### 20.信号量和互斥锁的具体底层实现机制

信号量严格意义上不算全局变量，但是信号量句柄（指针）是以全局变量定义的；

信号量分为二值信号量（任务同步），计数型信号量（多资源管理），互斥信号量（1个资源管理），递归信号量；

二值信号量：其实就可以当作一个flag信号，0就没空位，1就有空位，但是与互斥信号量不同的是二值信号量无法避免优先级翻转的问题；可以在中断中使用；

初始值为0      创建->释放->获取

互斥信号量：对一个资源进行管理，只要有一个任务在用这个资源，别的任务就不能用这个资源；不能在中断中使用；

初始值为1      创建->获取->释放

##### 21.堆(Heap)和栈(Stack)的概念

栈是编译器或者操作系统自动管理的，而堆是开发者手动控制的；

栈分配内存采取线性连续内存（last in first out）堆则是随机内存块（由动态链表管理）；

栈分配速度快，只需移动栈指针即可，而堆需要搜索可用内存块，分配速度较慢；

栈无内存碎片，堆易产生碎片；

栈作用于函数局部变量，堆则是进程级全局访问；

栈主要应用于局部变量和函数调用中，堆主要用于动态对象和大型数据中；

##### 22.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度?如何在实际运行一段时间后检查栈的使用量?

1.栈填充法：初始化时用特定模式填充栈空间，然后运行一段时间代码，检查栈指针位置，用栈空间大小减去栈指针位置就是这个任务栈的使用深度；

2.RTOS内置支持高水位线标记；

##### 23.在哪些情况下栈的内容会发生改变?

局部变量改变；发生中断时为了保存完整上下文会将相关寄存器压入栈中；线程切换时也是同理；直接用指令push或pop；

##### 24.CPU在进行现场保存(如函数嵌套调用、中断发生时)时，具体保存哪些信息?

返回地址：存储下一条指令的地址，确保ret指令能正确返回到调用点；

帧指针：保存当前栈帧基址；

被调用者保存寄存器：根据调用约定保存易失性寄存器（R0-R3）；

##### 25.当系统发生异常(例如进入HardFault)时，如何定位问题的根源?

当发生hardfault时cpu会自动把R0，R1，R2，R3，R12，LR，PC，PSR寄存器压栈，可以从PC寄存器定位触发异常的指令地址，LR寄存器可以返回异常地址，从而确定用的是MSP还是PSP指针；

hardfault一般是四种原因：硬件异常；内存异常；总线异常；使用异常；

可以进debug，然后全速运行，在外设栏->内核外设->fault reports中看各种错误寄存器

{% asset_img c857e20b-cd79-4edc-8051-2c6f6556bafa.png  %}

如果产生了hardfault，相应的寄存器会打勾，这个时候（还是在debug里）打开view->call stack window就可以找到hardfault发生的地址，右键watch里的hardfault选择show caller code，就能直接跳转到错误代码行（注意此方法适用于非法读取异常错误，字节对齐异常，不适用于非精确异常）

##### 26.请描述MCU从通电启动到执行main函数的过程

以cm3和cm4为例（cm7会有不同）

上电复位后硬件强制PC指向自举区的入口地址，先执行自举区代码（初始化基础时钟->通过boot引脚检测启动模式），如果（boot0=0，boot1=0）从主flash启动，那么就会将用户flash（0x08000000）重映射到0x00000000中，如果（boot0=1，boot1=0）从系统存储器启动，那么就会跳转到系统bootloader，如果（boot0=1，boot1=1）从SRAM启动           还有一种特殊情况就是使用了选项字节，这个时候就不看boot引脚状态

如果从主flash启动，就从0x00000000读MSP，0x00000000读PC（PC此时指向reset_handler地址，由于重映射关系，该地址一般是0x08000004之后的某一地址），读完地址就会跳转到该地址执行reset_handler（初始化.data,.bss,系统时钟......）最后执行main（）

如果从系统存储区启动，就会将系统存储器物理地址重映射到0x00000000上，然后跳转到系统bootloader（根据自举区固化好的代码，这个代码存储了系统bootloader的入口地址），bootloader会先初始化（初始化外设通信，配置外设时钟，初始化GPIO，初始化flash编程接口），然后bootloader会进入一个主循环（在这个循环中发送或等待特定协议用于监听主机发送命令），接收到主机各种命令后会进行处理（如擦除flash，接收bin/hex文件数据写入用户flash地址里，读flash，......），最后会执行用户程序reset_handler（初始化.data,.bss,系统时钟......）最后执行main（）

如果从SRAM启动，其实就是debug过程会执行（）

在复位处理函数中，先初始化堆栈指针（将从向量表加载的初始SP值设置到硬件堆栈指针寄存器中），然后初始化.data段（存放已初始化的全局变量和静态变量）清零.bss段，再初始化系统时钟（调用systeminit函数）初始化浮点运算单元和MPU，最后跳转到main（）函数

##### 27.PendSV

PendSV本质是cortex内核定义的一种系统异常，与其他异常不同的是，PendSV是为了处理可延迟的系统级服务请求

PendSV可以在NVIC中配置优先级，通常RTOS会将PendSV优先级设置为最低，这样就能确保PendSV异常只有在没有其他更高优先级的异常或中断需要执行时才会触发执行，避免了在中断上下文中进行复杂的任务切换操作

PendSV不会由硬件事件自动触发，只能通过软件显式地设置挂起位来请求

PendSV主要应用于RTOS中实现高效，安全的任务上下文切换（如果不用PendSV，系统就只能在systick定时器中断中进行任务切换，这样就会带来问题，比如在tick中断前被更高优先级中断抢占就会导致状态不一致，在tick中断里执行上下文切换会使中断延迟增加，并且使中断栈的使用变得很复杂）

具体实现过程：tick中断服务函数中会先更新系统时钟，再检查任务延时列表（延时列表+延时溢出列表+双指针），判断是否需要切换任务，如果需要切换则设置PendSV的挂起位，最后退出中断ISR；ISR退出后，如果没有其他更高优先级的中断需要处理，就会进入PendSV异常处理程序；在PendSV异常处理函数中，先保存当前任务上下文（将此时运行任务的寄存器R0-R3，R12，LR，PC，PSR压栈），再更新TCB（将此时SP指针保存到其TCB中），再从就绪队列中选择优先级最高的任务，然后从这个任务的TCB中取出SP栈指针，从该栈中弹出保存的寄存器值，最后执行异常返回（硬件执行从MSP切换到PSP）

补充：就绪队列是一个优先级对应一个队列，其中会涉及优先级位图（就绪队列非空设为1，为空设为0）

##### 28.串口，spi，i2c，can这些如何选择

串口用于点对点通信，通讯速率较低（<4Mbps）硬件上只需两根线，需要约定波特率，硬件上没有错误校验，

一般用于简单传感器，短距离设备对接，bootloader固件升级；

SPI通讯速率较高（可达50Mbps），拓扑为一主多从（通过片选cs引脚选择从机），硬件上需要四根线，全双工同步通信，有主控时钟，无内置错误校验，一般用于高速数据流传输，ADC/DAC，多传感器并行连接，实时性强的通讯；

I2C速率中低速，拓扑为多主多从，硬件上需要两根线和上拉电阻，半双工同步通信，有ACK、NACK应答机制，适用于板载传感器网络，EEPROM配置存储，多设备共享总线，引脚资源紧张的场景；

CAN通讯速率为中速（125kbps-1Mbps），拓扑为多主多从，硬件上由差分线can _H,can_L组成，抗干扰强，有基于消息ID的仲裁机制，使用优先级传输，有CRC校验，错误帧重发，故障节点隔离机制，可靠性高，适用于工业控，长距离通信，高噪声环境；

##### 29.当DMA传输全满中断(Ful)和串口空闲中断(ldle)的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗?

当DMA传输完成时，硬件自动置位TCIF标志；

当串口接收线路持续空闲时，硬件自动置位IDLE标志；

正常应该是先满足DMA全满中断的触发条件，然后再满足串口空闲中断的触发条件，但是题目说同时满足，那么这个时候就要看哪个优先级更高了

一般而言，使用这种数据传输架构确实很高效，但是会引入一个问题：中断中处理的数据大概率不是完整数据，所以这个时候要引入状态标记+指针跟踪机制，用指针记录最后一次处理结束位置，并标记（半满，全满）中断是否触发；

如果想要对这种数据传输架构继续优化，那就可以用双缓冲乒乓操作（全满中断就切换缓冲区），再优化一下，在中断服务函数中只对要处理的数据进行标记，然后在主循环里处理（需要对数据结构进行设计）；

还想优化吗？直接用STM32H7 硬件加速+智能DMA；

##### 30.微秒级延时如何实现

使用DWT内核调试单元，使能DWT单元的CYCCNT计数器；

配置定时器，预分频器和自动重载值设置产生1Mhz的计数频率，启动定时器，循环等待达到计数值；

使用sysTick定时器（可能会影响到操作系统或Hal库的毫秒延时）；

##### 31.在I2C通信中，时序所需的延时是如何保证的?

**SPI**: 你只需要配置好时钟频率（决定数据速率）、数据位宽、CPOL/CPHA（时钟极性相位），然后向数据寄存器（DR）写入数据。**硬件会自动在正确的时钟边沿发送和接收数据位，所有时序（时钟高/低电平时间、数据建立时间、保持时间）都由硬件时钟电路精确产生**，与CPU主频无关，精度极高。

**I2C**: 硬件I2C外设会自动处理START条件、STOP条件、ACK位、以及SCL时钟。你只需要操作控制寄存器和数据寄存器。硬件会确保SCL低电平期间SDA才能变化（建立时间），SCL高电平期间数据稳定（保持时间），这一切都由硬件保证。

**UART**: 硬件会根据你设置的波特率（如115200）自动生成精确的位时序（每个bit的时长）。

##### 32.static,const,volatile作用

**static：**

修饰局部变量时，会将局部变量存储在静态存储区（.bss或.data段），生命周期贯穿整个程序运行期间；一般用于计数；

修饰全局变量或者函数时，主要改变其作用域，无法被extern；

**const：**

定义一个常量，会将const修饰的全局变量存储在flash中，一般用在函数形参中（在函数中保护指针指向的数据不被函数内部修改）；

**volatile：**

防止编译器优化，每次都从内存中重新读取该变量的值，并且将修改后的值写回内存；一般用于在中断服务函数中修改的全局变量和RTOS多个任务共享的全局变量；

##### 33.软件模拟I2C时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后。这种滞后对I2C的数据读取会产生影响吗?

肯定是有影响的，因为I2C是半双工同步通信，它就只有两条线，数据线和时钟线，协议建立与结束所需的起始条件，停止条件都对时钟有着很高的要求，包括协议建立后读取数据时SDA线上的数据必须在SCL的高电平期间保持稳定，只有在SCL为低电平时才允许变化，如果这个时候发生了中断滞后，就会导致从设备视为一个**起始或停止条件**，而不是一个数据位，从而彻底破坏整个通信过程。

而且I2C规定了主设备在发送完一个字节后，需要在第9个时钟脉冲释放SDA线并读取从设备的应答（ACK）信号（一个低电平）。如果读取ACK位的时序被中断延迟，主设备可能错过从设备拉低SDA的短暂窗口，误判为无应答（NACK），从而错误地终止传输。

##### 34.I2C的时钟信号(SCL)如果出现不均匀(占空比不一致或频率抖动)，会对通信造成影响吗?

I2C协议规定，数据线（SDA）上的信号必须在时钟线（SCL）的高电平期间保持稳定。

**建立时间 **：SDA上的数据必须在SCL上升沿到来之前就已经保持稳定一段时间。

**保持时间 **：在SCL下降沿之后，SDA上的数据还必须继续稳定一段时间。

**SCL频率过低或停顿**：如果SCL低电平时间过长，从设备可能会等待超时，认为主设备（Master）已经放弃通信，从而自动复位其内部状态机，导致后续发送的数据全部无效。

**SCL频率过高**：如果SCL频率超过了从设备技术手册中规定的最大值，从设备可能无法正确识别信号，导致工作异常。

##### 35.请分享你使用cmbacktrace工具定位并解决实际问题的具体案例

主要用于检测hardfault发生的位置：移植cmbacktrace库，在四个hardfault中断服务函数中调用相关api，然后通过串口输出日志到电脑上；

##### 36.数组越界操作是否必然导致Hardfault异常?如果不引发Hardfault，可能会带来哪些其他不良后果?

越界地址落在其他变量/数组的合法范围内（被地址映射的区域也算），硬件无法区分是否越界;

若越界地址在无MPU保护的有效SRAM地址空间内（如`0x20000000~0x20020000`），不会触发总线错误；

##### 37.在Bootloader跳转到应用程序的过程中，需要关闭DMA吗?

需要，防止外设总线冲突（触发busfault）避免内存覆盖风险（若DMA指向Bootloader与应用程序共享的内存区（如SRAM），跳转后可能覆盖应用程序关键数据）防止中断触发错乱（跳转后若DMA完成中断触发，但应用程序未注册其ISR → CPU执行非法地址 → HardFault）

步骤：禁用所有DMA传输通道；清除DMA传输完成标志位（防止残留中断）；复位DMA通道配置；关闭DMA时钟；继续标准跳转APP流程

tip：bootloader硬件状态清理清单：关闭所有外设；关闭DMA；清除中断标志；复位时钟树；关闭全局中断；

##### 38.标准的UART通信只需要TX、RX两根线就够了。但在一些高速传输的场景，为什么还需要RTS/CTS这两根流控线?它们是怎么解决问题的?

RTS（request to send）由接收方发出，告诉发送方“我是否准备好接收数据“

CTS（clear to send）由发送方监测，根据CTS状态决定”我是否被允许发送数据“

RTS，CTS交叉连接，从根本上避免数据丢失

##### 39.SPI通信时主设备和从设备时钟极性配置反了会发生什么

SPI时钟配置涉及到两个关键参数时钟极性和时钟相位，正常来讲主设备和从设备这两个参数要完全相同，如果配置反了，则会导致通信失败

##### 40.中断中能否获取锁

**中断可以且只能获取自旋锁，并且在获取锁时通常需要配合禁用本地CPU中断来防止死锁。中断绝对禁止获取任何可能导致睡眠的锁。**

在某种条件下（在进程上下文的代码中，在获取锁之前先关闭本地CPU的中断）可以获取”自旋锁“，绝对不能获取互斥锁；

自旋锁的特性：当无法获取锁时，请求者会在一个紧凑的循环中“自旋”（忙等待），直到锁可用。它不会让出CPU。

中断上下文的特性：不能睡眠，需要快速执行完毕。

一致性：自旋锁的“忙等待”机制符合中断上下文不能睡眠的要求。在中断中获取自旋锁是为了保护中断处理程序和进程上下文代码共享的某些数据结构。

如果中断尝试获取互斥锁且该互斥锁已被占用，内核调度器会尝试将中断上下文睡眠，会导致整个系统内核崩溃；

得看这个自旋锁会被哪些对象获取，如果同时会被进程上下文获取，有可能会造成死锁，如果同时会被另一个中断获取，也会造成死锁

tip：**临界区**：具体来说，是程序中的一段访问共享资源（比如全局变量、硬件寄存器、链表、文件等）的代码。之所以“临界”，是因为如果多个执行流（线程、进程、中断）同时在这段代码里乱来，会破坏数据的一致性或程序的正确性。临界区这个概念本身并不提供保护机制，它只是定义了需要被保护的代码范围。你需要用锁（如自旋锁、互斥锁）或其它同步原语来“守卫”这段代码。

##### 41.stm32内部有哪些寄存器

通用寄存器（R0-R12）：用于数据处理和计算；

特殊寄存器：SP指向当前栈顶位置；LR指向函数返回地址；PC指向下一条要执行的指令地址；

程序寄存器（xPSR）

##### 42.结构体内存对齐 为什么有这种对齐方式

`struct MyStruct {   `

​       `   char c;  // 1 byte (对齐1)  // [编译器自动添加 3 个填充字节 (Padding) 使下一个 int 对齐到4] --> 地址偏移：1 + 3 = 4 (对齐4)  ` 

​      `    int i;       // 4 bytes (地址4, 对齐4)  `  

​      `         short s;     // 2 bytes (地址8, 对齐2) -> 不需要填充    // [编译器在末尾自动添加 2 个填充字节，使总大小是 4(最大对齐) 的倍数] --> 总大小：1 + 3(pad) + 4 + 2 + 2(pad) = 12 bytes `  

`};`

对齐是一个典型的以空间换时间以及保证正确性和兼容性的优化策略

整个结构体的最终大小，必须是其成员中**对齐要求最严格**的那个对齐值的**整数倍**。如果不满足，编译器会在结构体的末尾添加填充字节。

##### 43.无锁操作 原子操作的底层

原子操作是构建无锁数据结构的基石。它指的是一个操作（如读、写、读-修改-写）作为一个单一的、不可分割的单元执行。在操作完成之前，任何其他执行单元都无法观察到操作的中间状态或干扰该操作。

底层硬件支持：

**原子读/写:**

对齐访问： 硬件保证对自然对齐（地址是数据类型大小的整数倍）的基本数据类型（如32位系统上的int通常是4字节对齐）的读写操作本身就是原子的。CPU通过总线宽度和缓存行设计保证了这一点。例如，在x86上，对齐的32位读写是原子的。
非对齐访问： 通常不是原子的，可能需要多次总线操作，中间可能被中断。
**读-修改-写** 操作：

这是无锁编程的核心。常见操作包括：
比较并交换 (Compare-and-Swap, CAS): CAS(ptr, expected, new)：如果*ptr == expected，则将*ptr设置为new并返回true；否则返回false。
获取并增加 (Fetch-and-Add, FAA): FAA(ptr, value)：原子地将value加到*ptr上，并返回原来的值。
交换 (Swap): Swap(ptr, new)：原子地将*ptr设置为new，并返回原来的值。
硬件实现： CPU提供特殊的原子指令来实现这些操作。这些指令在执行期间会：
锁定缓存行 (Cache Locking): 现代CPU最常见的方式。执行RMW指令的CPU核心会锁定包含目标内存地址的缓存行。在锁定期间，其他核心对该缓存行的访问会被阻塞或延迟（通过缓存一致性协议，如MESI/MOESI）。指令完成后解锁。
锁定总线 (Bus Locking - 较老/特定场景)： 某些指令（如x86的LOCK前缀）或某些架构在特定情况下，会发出信号锁定整个内存总线。这期间其他核心无法访问内存，开销巨大，应尽量避免。

##### 44.什么情况下不能使用Cache?在使用DMA的情况下，Cache flush和Cachelonq哪种方式运行效率更高，为什么?

**问题**：外设寄存器（如UART数据寄存器、GPIO端口）的值由硬件实时改变，若开启Cache，CPU可能读取到Cache中的过期副本。

**解决方案**：在MMU/MPU配置中将外设寄存器区域标记为**Non-Cacheable**。

**问题**：CPU写 → DMA读：CPU修改的缓存数据若未写回内存，DMA将读取到**旧数据**。

**DMA写 → CPU读**：DMA写入的新数据若在Cache中有副本，CPU将读到**脏数据**。

**解决方案**：将DMA缓冲区放在**Non-Cacheable内存区**（如SRAM4）。或**手动维护Cache一致性**（Flush/Invalidate）。

**问题**：多个处理器共享同一内存区，若开启Cache，各处理器无法实时感知对方的数据修改。

**解决方案**：配置共享区为**Non-Cacheable**。•使用支持缓存一致性的总线协议（如ARM CCI）。

##### 45.如果用SPI往屏上刷一个像素点，怎么操作SPI?

首先对SPI初始化（启用SPI时钟，配置SPI寄存器和GPIO寄存器）

传输开始时拉低CS信号，传输结束后拉高CS信号

遵循显示器的命令格式发送数据包

##### 46.从机无响应的时候，如何做异常处理?

SPI通信的本质是交换主机和从机的移位寄存器里的数据，没有读写的说法

在发送数据后，主机等待从机响应时设置一个超时时间。如果超过这个时间还没有收到响应，则认为从机无响应。

当检测到超时后，主机可以尝试重新发送数据，进行有限次数的重试。如果重试多次后仍然失败，则放弃并报告错误。

主机在检测到通信失败后，应设置错误标志或通过其他方式（如串口打印错误信息、点亮错误指示灯等）报告错误状态。

##### 47.项目中DMA配合什么外设使用的?给一个不定长的数据怎么用USART配合DMA完成传输?怎么判断传输完成?

串口+DMA,ADC+DMA,SPI+DMA(使用SPI时要注意尽量不要使用hal库的DMA操作)

串口空闲中断+DMA循环接收可以实现不定长数据的接收

ADC连续转换模式+DMA循环接收

双缓冲或环形缓冲区，半满中断全满中断

缓冲区做数据对齐和cache保护

是否启用DMA突发传输

是否使用定时器或其他中断源触发

##### 48.中断栈和任务栈有什么区别?保存在哪里?

中断栈：当中断发生时，处理器会切换到中断上下文。中断栈用于保存中断上下文中的局部变量、寄存器状态以及可能的中断服务程序调用栈。

特点：通常是一个全局的栈，被所有中断共享。大小固定，由系统配置决定。在中断服务程序执行期间使用。

保存在哪里：中断栈通常位于静态分配的内存区域，由链接脚本定义，一般在RAM的系统全局栈中。在系统启动时初始化。

任务栈：每个任务都有自己的栈，用于保存任务执行时的局部变量、函数调用返回地址、任务上下文（在任务切换时保存寄存器的状态）等。

特点：每个任务有自己的栈空间。栈大小在任务创建时指定，不同任务可以有不同的栈大小。在任务执行时使用，任务切换时保存当前任务的上下文到其栈中，并从下一个任务的栈中恢复上下文。

保存在哪里：任务栈通常位于动态分配的内存（如从堆中分配）或静态分配的内存（由用户定义的任务栈数组）。在任务创建时分配。

##### 49.要实现任务调度，可以只有systick中断，不用pensv吗?pensv有什么优势?

把任务调度放到systick中断中执行会导致systick中断执行时间过长，会影响整个RTOS系统的时序问题。涉及到pendsv为什么要像任务一样设置一个挂起态，挂起态这个架构就很有意思。

##### 50.任务间通信方式?

共享内存/全局变量：需要手动实现调度避免竟态条件和数据损坏；

信号量：任务间的同步；(信号量是一种特殊的队列，通过源码得出)

消息队列：FIFO，消息队列用于任务间数据传输时，会使用内部锁比如用调度器锁或者内部互斥量确保操作的原子性，如果生产者任务调用 `send`时队列已满，且调用指定了阻塞等待时间（如 `portMAX_DELAY`或一个超时值），该任务会被内核挂起 (阻塞)，并放入该队列的生产者等待列表。当有消费者任务从队列中 `receive`走一条消息（使队列不再满）时，内核会唤醒在该队列上等待的一个生产者任务（通常是优先级最高的），使其可以发送消息。关键在于消息队列用于**中断和任务间**（使用fromISR后缀的API），这里应该如何处理数据来解决生产和消费的不平衡(解决方法我的大概思路是用非阻塞式将数据传到消息队列中)以及如何在临界区（中断服务函数的最后）中进行上下文切换（判断是切换到下一个中断还是切换到下一个任务）

互斥锁:解决优先级翻转问题；

事件标志组：一个任务等待一组事件组（多事件的或和与）

##### 51.IAP升级做了什么工作?

##### 52.内存踩踏严重调用栈现场破坏严重的情况下如何定位问题?

不能再使用常规的“复现问题-打断点-看调用栈”的调试流程

使用Canary Values（金丝雀值）：在重要的数据结构或栈帧之间插入一些特殊的、已知的标记值（例如 `0xDEADBEEF`）。定期或在崩溃时检查这些“金丝雀”是否被改变。如果改变了，说明发生了越界写，并且你知道了被破坏的范围。这可以帮你缩小嫌疑范围。

MPU（内存保护单元）：如果你的MCU有MPU，你可以将栈内存区域配置为只读。任何非法的写入操作都会触发一个MemManage故障，CPU会自动停在该条指令处。这是定位问题的终极利器之一。

分析崩溃瞬间的CPU寄存器：

PC (Program Counter)：程序计数器，指向导致崩溃的指令。但它可能指向一个非法地址，这本身就是一个线索。

LR (Link Register)：连接寄存器，通常保存着函数的返回地址。它的价值往往高于被破坏的栈。查看LR的值，可以知道在崩溃前程序是从哪个函数跳转过来的。

SP (Stack Pointer)：栈指针。如果SP本身被改得指向非法地址，那这就是一个强烈的信号。

其他寄存器：查看通用寄存器（R0-R12）的值。它们可能保存着导致错误操作的地址或索引。例如，如果R2的值是一个明显的非法地址，那么接下来查看是哪个指令把该值加载到R2的。

##### 53.互斥量，信号量，临界区有什么区别和应用场景?

##### 55.陀螺仪通信时碰到的问题?

| **数据有静态偏差** | **零偏（Bias）** 未校准。                                    | 1. **执行校准**：将传感器静止水平放置一段时间，计算各轴数据的平均值，作为零偏Offset，在后续读数中减去。 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **数据随温度漂移** | **温漂**：零偏和灵敏度会随温度变化。                         | 1. 高端传感器内置温度传感器和补偿系数。需读取温度值，并根据公式或查找表进行补偿。 |
| **角度积分发散**   | **陀螺仪积分误差**：即使很小的零偏，积分后也会随时间累积成巨大的角度误差。 | 1. **使用融合算法**：如**互补滤波**或**卡尔曼滤波**，结合加速度计（无累积误差但高频噪声大）和陀螺仪（无累积误差但会漂移）的数据，得到稳定的姿态角。 |

| **读写寄存器失败**         | **时序问题**：不满足协议时序要求                       | 1. **用逻辑分析仪抓取波形！** 这是最强大的调试手段。对照数据手册检查： - **SPI**: 时钟极性和相位（CPOL/CPHA）是否匹配。 - **I2C**: 启动/停止条件、时钟速度（是否超传感器最高速率）、ACK/NACK信号。 2. 检查代码中的延时，确保满足两次操作之间的`T_{wait}`时间。 |
| -------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
|                            | **寄存器操作顺序错误**：                               | 1. 某些传感器需要先解锁配置寄存器、或按特定顺序配置。仔细阅读数据手册的配置流程。 |
| **数据值不变或为0**        | **传感器未启动**：未使能测量模式。                     | 1. 检查配置寄存器（如PWR_MGMT_1, CTRL_REG1），确保传感器已从睡眠/待机模式切换到正常工作模式。 |
|                            | **FIFO或数据路径配置错误**：数据未被更新到输出寄存器。 | 1. 检查数据路径配置，确认数据是直接输出到寄存器，还是先进入FIFO。 |
|                            | **SPI模式下的字节序问题**：                            | 1. 某些传感器在SPI模式下传输数据时，字节序（MSB first或LSB first）可能与I2C模式不同。 |
| **数据值跳变剧烈，噪声大** | **未启用内置滤波器**或**滤波器带宽设置过高**。         | 1. 根据应用场景（如游戏、振动监测、无人机），配置合适的**低通滤波器（DLPF）** 带宽。带宽越低，数据越平滑，延迟越高。 |
|                            | **数据刷新率（ODR）设置不当**。                        | 1. 确保输出数据速率（ODR）与滤波器带宽匹配（ODR应 ≥ 2 * 带宽，遵循奈奎斯特采样定理）。 |

##### 56.嵌入式中内存泄漏和内存碎片的区别是什么?如何预防?

| **特性**       | **内存泄漏 (Memory Leak)**                                 | **内存碎片 (Memory Fragmentation)**                          |
| :------------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| **定义**       | 分配的内存**未被释放**，且程序永久失去对该内存的引用。     | 空闲内存被分割成大量**不连续的小块**，无法满足大内存请求。   |
| **根本原因**   | **代码逻辑错误**：忘记释放内存（如 `malloc`后无 `free`）。 | **动态内存分配机制缺陷**：频繁分配/释放不同大小的内存块。    |
| **内存状态**   | 内存被占用且无法再利用（“永远丢失”）。                     | 内存物理存在且空闲，但**无法合并成连续大块**。               |
| **问题表现**   | **可用内存总量持续减少**，直至耗尽。                       | **总空闲内存充足**，但分配大块内存时失败（如 `malloc(1024)`失败）。 |
| **崩溃原因**   | `malloc`返回 `NULL`（内存耗尽）。                          | `malloc`返回 `NULL`（无足够连续空间）。                      |
| **是否可恢复** | ❌ 除非重启系统。                                           | ⚠️ 可能通过内存整理恢复（如压缩算法），但嵌入式系统通常不支持。 |
| **检测工具**   | 内存泄漏检测工具（Valgrind, Heap Trackers）。              | 内存碎片分析工具（可视化内存映射）。                         |

在程序初始化时，使用合适的内存分配方法去分配内存池，比如linux内核分配内存时会按2的幂次分割/合并内存，并为频繁分配的对象缓存固定大小的内存块

##### 57.虚函数的实现原理是什么?RTOS中使用它有哪些开销?

编译器为每个包含虚函数的类生成一个虚表，并隐式地添加一个虚表指针，当通过基类指针调用一个虚函数时，会通过虚表指针找到虚表，然后找到存储的函数指针进行调用，这种间接查找调用的过程就能有效地实现多态

开销：每个虚表和虚表指针都会占用可观的内存，执行时间上每次调用都需要额外的两次内存访问

##### 58.SPI和 12℃ 的核心区别有哪些?云台 IMU 选哪种协议更合适?

| **特性**       | **SPI (Serial Peripheral Interface)**                        | **I²C (Inter-Integrated Circuit)**                           |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **通信方式**   | **全双工** (同时收发)                                        | **半双工** (分时收发)                                        |
| **线缆数量**   | **4 线制** (至少3线)： - SCLK (时钟) - MOSI (主出从入) - MISO (主入从出) - CS/SS (片选) | **2 线制**： - SCL (时钟) - SDA (数据)                       |
| **拓扑结构**   | **主从设备 + 点对点** 每个从机需要独立的片选线(CS)。 支持多从机，但线路复杂。 | **多主多从 + 总线式** 所有设备挂载到同一总线上，通过地址寻址。 布线简单，但需要上拉电阻。 |
| **数据传输**   | **无协议格式**。 只是简单的移位寄存，数据长度和含义由用户定义。 | **有固定协议格式**。 包含**起始位**、**设备地址**+**读写位**、**应答位(ACK/NACK)**、**停止位**。 |
| **速度**       | **非常高** (通常 50+ Mbps)。 没有协议开销，时钟频率可以很高。 | **较低** (标准模式 100kbps，快速模式 400kbps，高速模式 3.4Mbps)。 有协议开销（地址、应答位等），且受限于物理总线电容。 |
| **从机地址**   | **硬件地址** (由CS线决定)                                    | **软件地址** (通常7位或10位，在协议中传输)                   |
| **硬件复杂度** | **主设备简单，从设备简单**。 但主设备需要多个GPIO作为CS线。  | **主设备和从设备逻辑更复杂**。 需要处理协议和仲裁。但主设备只需2个GPIO。 |
| **软件复杂度** | **低**。只需操作移位寄存器，逻辑简单。                       | **较高**。需要处理完整的协议状态（起始、地址、应答、停止）。 |
| **鲁棒性**     | **高**。点对点连接，受干扰影响小。                           | **较低**。总线式结构，一个设备故障可能拖垮整个总线。         |
| **功耗**       | 相对较高（多根信号线活动）。                                 | 相对较低（两线制，静态时上拉电阻耗电）。                     |

##### 59.如何通过示波器波形判断 12C 丢包是 SCL拉伸异常还是从设备响应延迟导致?

**先检查NACK**：首先检查地址字节后的ACK位。如果这里已经是NACK，那么问题极有可能是地址错误、设备损坏或电源问题，后续的SCL拉伸根本不会发生。

**再检查拉伸**：如果通信始于地址ACK，但在后续数据字节传输中出现超时，再去仔细观察SCL线是否被异常拉伸。

##### 60.FreeRTOS 和 Linux 二者调度算法有何差异?

FreeRTOS是实时操作系统，强调确定性和可预测性，Linux是通用操作系统，强调公平性和整体吞吐量；

**完全公平调度器 (CFS)**

核心思想**：不是分配固定的时间片，而是根据进程的**权重（由nice值决定）** 来分配CPU时间的**比例**。

**实现机制**：

CFS 维护一棵**红黑树（red-black tree）**，树中的键是进程的**虚拟运行时（vruntime）**。

`vruntime = 实际运行时间 * (NICE_0_LOAD / 进程权重)`

调度器总是选择 `vruntime`**最小**的进程来运行（即最“吃亏”的进程）。这保证了所有进程在一段时间内能公平地获得其应得的CPU时间比例。

**动态交互**：CFS 会根据进程是 **I/O 消耗型**（如GUI，经常等待用户输入）还是 **CPU 消耗型**（如视频编码，一直计算）来动态调整其优先级，优先照顾交互式进程，以提升用户体验。

**实时调度策略**

为了满足实时需求，Linux 提供了两个高于 CFS 的实时调度策略：

**`SCHED_FIFO`**：先进先出。相同优先级的实时进程先来先服务，直到它主动放弃（阻塞或调用`sched_yield()`）或被更高优先级的实时进程抢占。

**`SCHED_RR`**：轮转。与 `SCHED_FIFO`类似，但相同优先级的进程会分配时间片，时间片用完后会排到同优先级队列的队尾。

##### 61.ARM Cortex-M 内核中，如何通过栈回溯定位 HardFault 异常的根本原因?

发生异常后处理器会将关键信息压入寄存器中

检查PC指向地址附近的代码（用adress to line工具）；

检查LR寄存器判断当前使用的是主栈指针还是从栈指针，如果是主栈指针的话说明问题大概率发生在内核或者中断上下文中，如果是从栈指针的话说明问题大概率发生在任务上下文中；

##### 62.Bootloader 双分区备份下，升级断电后如何判断加载原分区还是修复新分区?

##### 63.CAN总线仲裁原理

can总线使用差分信号，存在线与特性，0代表显性，1代表隐性

仲裁发生在消息的仲裁场期间，主要是标识符部分。标识符数值越小的节点，优先级越高。

这背后的核心逻辑正是CAN 总线仲裁的“显性位覆盖”机制和标识符从最高位（MSB）开始比较的规则。

##### 64.对于有多个核的MCU，内存屏障有了解过吗

`// 核A写入共享数据`
`shared_data = 42;           // 写共享变量`
`__DMB();                    // 写屏障：确保写入完成后再释放锁`
`lock_flag = 0;              // 释放锁`

`// 核B读取共享数据`
`while (lock_flag != 0);     // 等待锁`
`__DMB();                    // 读屏障：确保读取前缓存已更新`
`int value = shared_data;    // 读取共享变量`

内存屏障是多核MCU开发的基石技术：

使用原则：

共享数据读写 → `DMB`

关键外设操作 → `DSB`

动态代码更新 → `ISB + DSB`

##### 65.从源码到可执行文件的过程

预处理：cpp对源代码预处理形成一个纯粹的.i文件

编译：gcc将.i文件翻译成汇编语言生成一个.s文件

汇编：汇编器将汇编代码翻译成机器可以执行的机器码并输出一个.o文件

链接：ld链接器将多个目标文件合并为一个可执行文件.elf并为每个数据段分配最终的内存地址

| **特性**     | **.bin 文件**                          | **.elf 文件**                                          |
| :----------- | :------------------------------------- | :----------------------------------------------------- |
| **格式类型** | **原始二进制映像**（Raw Binary Image） | **结构化可执行文件**（Executable and Linkable Format） |
| **内容**     | 纯机器码指令 + 数据（无元数据）        | 机器码 + 数据 + 丰富的元数据（符号表、调试信息等）     |
| **地址信息** | **无地址信息**，烧录时需指定基地址     | **包含地址信息**（代码/数据/栈的加载地址）             |
| **调试支持** | ❌ 无调试信息                           | ✅ 包含符号表、源码行号等调试信息                       |
| **文件大小** | 通常较小（仅含必需代码/数据）          | 通常较大（含调试信息、符号表等）                       |
| **适用场景** | 最终固件烧录、Bootloader               | 开发调试、动态链接、符号分析                           |

##### 66.并发与并行

单核cpu似乎无法做到并行，只能做到并发（就是RTOS的任务并发）

##### 67.代码架构

工程机器人嵌入式软件系统架构分为 6 层。下面从顶层到底层分别介绍。

1. 应用层：包括 CAN 中断回调函数、 USB 回调函数、 UART 回调函数、定时器回调函数、主循环的具体实现。

2. 功能模块层：用类的方式实现各个功能模块的参数和成员函数。包括底盘、机械臂。底盘包括麦轮速度解算等、轮速控制 PID 等。机械臂模块包括向 NUC 发送电机角度数据、接收来自 NUC 的电机目标角度，并将控制指令发送给电机。

3. 硬件驱动层：用类的方式实现各个硬件的驱动。包括 A 板开关电源的驱动程序、 M3508电机的驱动程序、达妙 4310 电机驱动程序、遥控器驱动程序和裁判系统驱动程序。包含发送命令、接收反馈、数据处理、 PID 计算等功能。

4. 中间件层：包含 PID 算法的功能包（类）以及自定义数学运算（如矩阵运算、限幅函数、大小端转换等）。

5. 硬件抽象层：对 HAL 库中 CAN、 UART 等单片机外设库的重新封装。
6. HAL 库：由 stm32cubeMX 生成的开发者库  











[目录](#####目录)









