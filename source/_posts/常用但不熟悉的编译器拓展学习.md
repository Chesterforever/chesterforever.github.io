---
title: 常用却不熟悉的编译器拓展学习
date: 2025-07-05 02:20:25
tags: [MCU,ARM]
index_img: /img/avatar.png

---

# 常用却不熟悉的编译器拓展学习

> 需要注意的是有些代码架构其实是ARM编译器或GCC/CLANG特有的变量属性，如果高频使用的话可能会导致系统可移植性和鲁棒性变差，可读性也会变差，“在必要处使用，避免炫技”

### `__attribute__` 

`__attribute__` ：它是 GNU C 编译器（GCC）提供的一种编译器指令（Compiler Directive） 或扩展语法。它允许开发者向编译器提供关于变量、函数、类型（结构体、联合体、枚举） 的额外信息或特殊要求，这些信息超出了标准 C 语言语法的范畴。

目的：

1.精细控制内存布局： 如对齐方式 (`aligned`)、打包方式 (`packed`)、指定存储段 (`section`)。

2.优化提示： 如内联行为 (`always_inline`, `noinline`)、分支预测 (`cold`, `hot`)。

3.函数行为控制： 如不返回 (`noreturn`)、纯函数 (`pure`)、弱符号 (`weak`)、裸函数 (`naked`)。

4.变量行为控制：如易变性 (`volatile` - 虽然 `volatile` 是关键字，但有时也用属性形式)、强制使用 (`used`)、未使用 (`unused`)。

5.代码生成控制： 如构造函数/析构函数 (`constructor`, `destructor`)。

6.诊断控制：如弃用警告 (`deprecated`)、格式检查 (`format`)。

语法：

```
__attribute__((attribute_name))         // 单个属性
__attribute__((attribute_name(params))) // 带参数的属性
__attribute__((attribute_name1, attribute_name2, ...)) // 多个属性
```

•它通常放在声明（变量、函数、类型）的末尾，在分号 `;` 之前。

•多个属性用逗号分隔，放在同一个双括号 `(( ... ))` 内。

可移植性：

•`__attribute__` 是GNU C 扩展，不是标准 C (ANSI C, ISO C) 的一部分。

•其他主流编译器（如 Clang、ARM Compiler 5/6, IAR）通常也支持大部分常用的 `__attribute__` 语法，或者提供功能等效的替代方式（如 `#pragma`）。

•为了可移植性，有时会用宏来包装特定编译器的属性语法。



`// 单个变量对齐
uint8_t dma_buffer[1024] __attribute__((aligned(32))); // 32 字节对齐
// 结构体类型对齐
struct __attribute__((aligned(16))) Vector4 {
    float x, y, z, w;
};`



`ALIGN_32BYTES(__attribute__((section (".RAM_D2"))) uint8_t src_fifo[CH_NUM][FIFO_DBS_0]);` 

- **`ALIGN_32BYTES`**这是一个宏，用于指定变量的对齐方式，表示变量按32字节对齐
- **`__attribute__((section (".RAM_D2")))`**用于将变量放置于指定的段（section）中，这里段名为“.RAM_D2”
- 像 `section` 这样的属性需要与链接器脚本 (`.ld`, `.sct`) 配合使用，在链接脚本中定义对应的段并将其映射到特定的内存区域。



`__STATIC_INLINE void __set_MSP(uint32_t uint32_t topOfMainStack){ }`

- `__STATIC_INLINE`     内联，作用是将函数直接嵌入到调用此函数的代码中，从而降低调用此函数所占用的时间(MDK AC5使用此关键词，MDK AC6使用`__STATIC_FORCEINLINE` )



`#pragma pack(push, 1) // 保存当前对齐设置，并设置为 1 字节对齐
struct SensorData {
    uint8_t id;
    uint32_t value;
};
#pragma pack(pop) // 恢复之前的对齐设置`



```
struct AlignedMember {
    char a;
    int _Alignas(8) b;  // 强制b按8字节对齐
};                      // 总大小=16（a后补7字节）
```



`uint8_t buffer[1024] __attribute__((aligned(32))); // 32字节对齐`



`// 在链接脚本中定义： _estack = ORIGIN(RAM) + LENGTH(RAM);
// 在代码中声明并确保存在：
extern uint32_t _estack;
uint32_t * const __attribute__((used)) pStackTop = &_estack; // 强制保留 pStackTop (&_estack)`



### `__builtin`

内建函数，一般用于位操作和位扫描，字节序交换，分支预测提示(不建议使用)，内存屏障/栅栏，原子操作（不建议使用，建议使用C11新版标准原子操作）

- `int __builtin_clz(unsigned int x)`: 计算 `x` 的二进制表示中**前导零 (Leading Zero)** 的数量。`x=0` 是未定义行为 (UB)。`x=1` (0b...0001) 返回 31 (32位系统)。•`int __builtin_ctz(unsigned int x)`: 计算 `x` 的二进制表示中**尾随零 (Trailing Zero)** 的数量（即最低位的 1 的位置）。`x=0` 是 UB。`x=8` (0b...1000) 返回 3。•`int __builtin_popcount(unsigned int x)`: 计算 `x` 的二进制表示中 **1 的个数 (Population Count)**。•`int __builtin_ffs(int x)`: 查找 `x` 中**最低位被置位 (First Set Bit)** 的位置（从 1 开始计数）。`x=0` 返回 0。`x=8` 返回 4。

- `uint16_t __builtin_bswap16(uint16_t x)`: 反转 16 位整数的字节顺序。
- `uint32_t __builtin_bswap32(uint32_t x)`: 反转 32 位整数的字节顺序。
- `uint64_t __builtin_bswap64(uint64_t x)`: 反转 64 位整数的字节顺序。

- `#define likely(x)   __builtin_expect(!!(x), 1) // x 很可能为真`
- `#define unlikely(x) __builtin_expect(!!(x), 0) // x 很可能为假`

- •`type __sync_fetch_and_add(type *ptr, type value)`: 原子地将 `value` 加到 `*ptr` 上，返回 `*ptr` 的**旧值**。
- •`type __sync_add_and_fetch(type *ptr, type value)`: 原子地将 `value` 加到 `*ptr` 上，返回 `*ptr` 的**新值**。
- •`type __sync_fetch_and_sub(type *ptr, type value)`: 类似 `fetch_and_add`，做减法。
- •`type __sync_sub_and_fetch(type *ptr, type value)`: 类似 `add_and_fetch`，做减法。
- •`type __sync_fetch_and_or(type *ptr, type value)`: 原子地 OR。
- •`type __sync_fetch_and_and(type *ptr, type value)`: 原子地 AND。
- •`type __sync_fetch_and_xor(type *ptr, type value)`: 原子地 XOR。
- •`type __sync_lock_test_and_set(type *ptr, type value)`: 原子地将 `*ptr` 设置为 `value`，返回旧值（通常用于实现自旋锁）。
- •`void __sync_lock_release(type *ptr)`: 释放由 `__sync_lock_test_and_set` 获取的锁（通常将 `*ptr` 设为 0）。
- •`bool __sync_bool_compare_and_swap(type *ptr, type oldval, type newval)`: 如果 `*ptr == oldval`，则原子地将 `*ptr` 设置为 `newval`，返回 `true`；否则返回 `false`。
- •`type __sync_val_compare_and_swap(type *ptr, type oldval, type newval)`: 如果 `*ptr == oldval`，则原子地将 `*ptr` 设置为 `newval`；总是返回 `*ptr` 的旧值。