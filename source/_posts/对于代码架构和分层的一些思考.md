---
title: 对于代码架构和分层的一些思考
date: 2025-09-19 00:33:14
tags: [MCU]
index_img: /img/avatar.png

---

# 对于嵌入式代码架构和分层的一些思考

## 引言

在我刚接触嵌入式软件的时候，其实就对这个问题非常感兴趣，所以在之后的学习中，比如在打rm的时候有时候看到别的战队的源码或者实习时拿到一份新的需要交接的源码，我都会先分析整个代码文件的架构并画图记录，这也极大地帮助我快速上手理解代码。所以这篇文章，我会从个人开发和企业开发两个角度，去讨论嵌入式代码架构和分层，以及介绍一些我目前接触学习到的架构，最后介绍一下如何用draw.io或配合cursor ai去画架构图或UML图。

## 正文

### 一、为什么要对代码进行架构设计

这个重要性不言而喻，这里用了ai回答这个问题，比我自己总结的更全面一些

1. **可维护性**：清晰的层次使得定位问题、修改功能、增加新特性变得容易。新人也能更快上手。
2. **可移植性**：将硬件相关的代码与业务逻辑分离。当更换MCU（如从STM32换成ESP32）时，只需重写底层驱动，核心业务代码几乎不用动。
3. **可测试性**：分层后，可以对每一层进行独立的单元测试。例如，可以在PC上模拟硬件层，直接测试业务逻辑，而不需要每次都烧录到硬件上。
4. **可扩展性**：良好的架构便于功能模块的添加和删除，遵循“开闭原则”。
5. **团队协作**：不同的工程师可以并行开发不同的层（如驱动工程师和应用工程师），只要定义好清晰的接口即可。

### 二、经典的分层架构模型

**分层是手段，不是目的。** 最适合项目的架构，是能够以可接受的复杂度，清晰地表达当前系统、并能较好地适应未来变化的那一个。从三层开始，当遇到痛点（如测试难、移植麻烦、业务逻辑混乱）时，再考虑引入更多层次来解决特定问题。层级分的太多，隔离的太彻底，有时候反而增加了无谓的损耗。很多厂家其实都是直接分3层，底层，中间层，应用层，简单粗暴。

一般来说，个人总结有几个原则：

> 1. **接口是上下级调用，很少跨层调用**。即第4层的代码一般不会直接去第1/2层调用接口，非要用的话，就从第3层透传封装一下。（5层架构的应用层同时依赖3，4层）
> 2. **同层级的模块间尽量避免相互调用**，需要的数据都是通过高一层的接口获取再下传

#### 1.三层架构

##### a. 硬件层

直接与MCU外设（GPIO, UART, SPI, I2C, ADC等）寄存器打交道的代码。负责最底层的初始化、读写操作。

封装硬件差异，向上提供统一的、硬件无关的操作接口。

##### b. 中间件层

在硬件抽象层之上，实现具体的、可复用的功能模块和服务。它不关心具体的业务逻辑，而是提供“工具”。将通用的、复杂的操作封装成更高级、更易用的API。

**操作系统**：如FreeRTOS, Zephyr的任务、信号量、队列等抽象。

**协议栈**：如TCP/IP, USB, 文件系统FatFS。

**算法库**：如PID控制器、滤波器、数学库。

**设备驱动**：针对具体外围芯片（如传感器BME280、显示屏SSD1306）的驱动。这部分有时也会被归入硬件抽象层，但更倾向于放在这一层，因为它依赖底层的SPI/I2C HAL。

##### c. 应用层

实现产品的核心功能和业务流程。它协调下层各个模块来完成最终的用户需求。

这一层代码应该完全不包含任何硬件特性（如寄存器地址、延时函数 `HAL_Delay`）。它只调用下层提供的服务接口。

#### 2.四层架构

在业务逻辑复杂后，三层架构会遇到一个问题：中间件层既包含通用服务，又包含针对具体硬件的驱动实现，导致应用层仍然对具体设备有依赖。

四层架构通常通过拆分中间件层来解决这个问题，引入一个专门负责抽象接口和适配的层次。

##### a. 硬件驱动层

最底层的芯片寄存器操作

##### b. 硬件抽象层

抽象操作系统和核心外设。定义接口，并提供具体设备的适配器

> **硬件抽象层和硬件驱动层的主要区别**
> 硬件抽象层使用的芯片内本身的资源（芯片手册都有介绍），而硬件驱动层使用的是芯片本身不存在的资源，而且需要编写相应代码才能实现的资源。
>
> 比如正点原子STM32中CAN使用的TJA1050芯片，CAN属于STM32的片内资源，TJA1050属于片外资源，但由于TJA1050不需要额外的代码就能通过STM32中CAN本身提供API函数正常 工作；因此可以认为TJA1050不属于硬件驱动层，而若使用TJA1041，则需要编写额外代码才能使正常工作才能使STM32中CAN本身提供API函数正常工作，因此可以将TJA1041归为硬件驱动层。

##### c. 功能模块层

实现具体、可复用的功能

##### d. 应用层

纯业务逻辑，协调下层服务

#### 3.五层架构

当业务逻辑变得极其复杂，包含大量的状态、规则和核心算法时，我们会发现应用层变得过于臃肿。这时，我们需要将核心的、与外部完全无关的业务规则独立出来，形成一个新的层次——**领域模型层**。

##### a. 硬件驱动层

##### b. 硬件抽象层

##### c. 功能模块层

提供基础服务，如传感器数据融合、GPS解析、RC指令解码等。

##### d. 领域模型层

系统的核心。包含核心业务实体、状态机和算法。这一层应该是纯的、平台无关的，可以被任何语言（C/C++/Python）实现。

#####  e.应用协调层

协调任务，处理外部事件。如接收遥控器信号、处理地面站指令、触发飞行模式切换。它不包含核心飞行规则。

#### 4.六层架构

六层架构通常出现在大型系统或需要提供明确API给第三方开发的场景中。它通过在应用层之上再抽象一层，提供一个清晰的、稳定的、版本化的接口。

##### a. 硬件驱动层

##### b. 硬件抽象层

##### c. 功能模块层

##### d. 领域模型层

##### e.应用协调层

##### f.API层

对外提供统一的访问接口。可以是RESTful API、gRPC、MQTT主题，或者简单的函数库接口。负责协议转换、版本管理、权限校验。

#### 5.本人rm时期的工程机器人的架构（仅作参考）

工程机器人嵌入式软件系统架构分为 6 层。下面从顶层到底层分别介绍。

1. 应用层：包括 CAN 中断回调函数、 USB 回调函数、 UART 回调函数、定时器回调函数、主循环的具体实现。

2. 功能模块层：用类的方式实现各个功能模块的参数和成员函数。包括底盘、云台、机械臂。底盘包括麦轮速度解算等、轮速控制 PID 等。云台包括控制图传模块航向和俯仰的相关成员函数。

3. 硬件驱动层：用类的方式实现各个硬件的驱动。包括 A 板开关电源的驱动程序、 M3508电机的驱动程序、达妙 4310 电机驱动程序、遥控器驱动程序和裁判系统驱动程序。包含发送命令、接收反馈、数据处理、 PID 计算等功能。

4. 中间件层：包含 PID 算法的功能包（类）以及自定义数学运算（如矩阵运算、限幅函数、大小端转换等）。

5. 硬件抽象层：对 HAL 库中 CAN、 UART 等单片机外设库的重新封装。
6. HAL 库：由 stm32cubeMX 生成的开发者库。  

### 三、层级之间的“连接”架构模型

#### 1.生产者-消费者模型（数据流控制）

硬件层提供生产者ISR负责数据采集，中间件层提供消息队列负责数据协调，应用层提供消费者任务负责数据处理，这样分层实现了

- 解耦：生产者和消费者可以独立变化
- 并发：生产和消费可以并行执行
- 流量控制：缓冲区满时生产者阻塞，空时消费者阻塞

#### 2.工厂模式（对象生命周期管理）

工厂模型多了一个工厂层，通过创建函数类很方便地实现了C语言下的多态的实现（个人简单的理解，不知道准不准确，因为我没用过）

```
实际案例：智能家居设备管理
// device_manager.c (应用层)
void manage_devices(void) {
    device_factory_t factories[] = {
        &sensor_factory,      // 中间件层工厂
        &actuator_factory,    // 中间件层工厂
        &display_factory      // HAL层工厂
    };
    
    for (int i = 0; i < 3; i++) {
        device_t* dev = factories[i]->create();
        dev->init();
        registered_devices[i] = dev;
    }
}

// HAL层具体工厂
device_t* display_factory_create(void) {
    static display_device_t disp_dev;
    oled_init(&disp_dev);  // 硬件层初始化
    return &disp_dev.base;
}
```

通过这种分层工厂设计，系统获得以下特性：

- 硬件更换只需修改工厂实现
- 新增设备类型只需扩展工厂接口
- 各层级之间的依赖关系清晰可见
- 运行时动态检测硬件成为可能

#### 3.发布-订阅模型

硬件层提供发布者，中间件层提供事件总线，应用层提供订阅者

- **动态响应**：订阅者可随时注册/注销
- **广播通信**：一个事件可触发多个处理流程
- **松耦合**：发布者无需知道订阅者存在

#### 4. 代理模式

硬件层提供实际服务，中间件层提供代理接口，应用层提供客户端

```c
// 中间件层：网络代理接口
typedef struct {
    bool (*send)(const uint8_t* data, uint16_t len);
    bool (*receive)(uint8_t* buf, uint16_t* len);
} network_proxy_t;

// 硬件层：实际实现（WiFi驱动）
bool wifi_send(const uint8_t* data, uint16_t len) {
    return WiFi_Transmit(data, len);
}

// 应用层：客户端
void send_telemetry(network_proxy_t* proxy) {
    uint8_t data[] = {0x01, 0x02};
    proxy->send(data, sizeof(data)); // 通过代理发送
}
```

- **访问控制**：代理可添加权限检查
- **延迟初始化**：实际硬件按需初始化
- **远程访问**：代理可跨处理器通信（如协处理器）

#### 5. 门面模式

- 统一接口（门面）
- 子系统集合（各硬件模块）

```c
// 中间件层：系统门面
typedef struct {
    void (*power_on)(void);
    void (*enter_low_power)(void);
    void (*get_sensor_data)(sensor_data_t*);
} system_facade_t;

// 子系统整合
void system_power_on(void) {
    PMIC_Enable();
    Sensor_Init();
    Wireless_Start();
}

// 应用层：通过门面操作
void app_main(void) {
    system_facade_t sys = {
        .power_on = system_power_on,
        // ...其他操作
    };
    sys.power_on();
}
```

- **简化接口**：隐藏子系统的复杂性
- **降低依赖**：应用层只依赖门面接口
- **集中管理**：子系统变化不影响上层

#### 6. 管道-过滤器模式

- 数据源（硬件层）
- 过滤器链（中间件层）
- 数据接收端（应用层）

```
// 中间件层：过滤器接口
typedef void (*data_filter_t)(float* data);

// 过滤器链
data_filter_t filters[] = {
    moving_average_filter,
    temperature_compensate,
    scale_to_engineering_units
};

// 应用层：处理流水线
void process_pipeline(float raw_data) {
    for(int i=0; i<3; i++) {
        filters[i](&raw_data); // 数据依次通过各过滤器
    }
    display_data(raw_data);
}
```

- **模块化处理**：每个过滤器独立可替换
- **灵活重组**：可动态调整过滤器顺序
- **并行处理**：不同过滤器可运行在不同核上

#### 7. 适配器模式

- 目标接口（应用层期望的）
- 适配器（中间件层）
- 被适配者（硬件层）

```
// 应用层：期望的通用传感器接口
typedef struct {
    float (*read)(void);
} sensor_t;

// 硬件层：特定传感器（不兼容接口）
float DS18B20_ReadTemp(void) {
    // 返回原始整型温度值
    return (float)DS18B20_Read_Raw();
}

// 中间件层：适配器
float ds18b20_adapter(void) {
    float temp = DS18B20_ReadTemp();
    return temp / 16.0f; // 转换为实际温度值
}

// 使用适配器
sensor_t temp_sensor = {
    .read = ds18b20_adapter
};
```

- **接口转换**：使不兼容的接口能协同工作
- **遗留代码复用**：适配旧硬件驱动
- **多平台支持**：同一接口适配不同实现

### 四、使用draw.io或配合cursor ai画架构图或UML图

#### draw.io的下载

draw.io有网页端，桌面端，也可以在vscode这样的开发工具中通过插件方式使用

draw.io桌面端是开源免费的，这里给出下载网址[Releases · jgraph/drawio-desktop](https://github.com/jgraph/drawio-desktop/releases)

根据电脑自身系统下载对应的最新版本，我是windows系统，直接点击windows installer下载或下载如下图所示的文件

{% asset_img 2ff7c3c44b16d3895549a51466c6f193.png  %}

下载过程没什么坑，改下安装路径即可，如果需要桌面上的快捷方式需要手动创建

#### 在vscode中通过插件方式配合cursor使用（无需下载draw.io本体）

在vscode中的拓展安装Draw.io Integration插件

在vscode中新建.drawio文件，然后最好改一下颜色主题，深色完全看不清

向Cursor描述你的需求：

```
请帮我生成一个微服务架构图，包含：
- API网关
- 用户服务
- 订单服务
- 支付服务
- 数据库集群
使用Mermaid语法
```

然后将得到的代码按如下图方式插入到draw.io中

{% asset_img 64c62b5b-66ce-433a-a970-ef3fc867a339.png  %}

最终结果

{% asset_img e82700be-d5ed-49e4-a5d3-92a74bbb795e.png  %}