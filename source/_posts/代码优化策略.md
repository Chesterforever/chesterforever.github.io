---
title: 代码优化策略
date: 2025-08-20 03:45:04
tags: [MCU]
index_img: /img/avatar.png
---

# 代码优化策略

> 哪有什么代码优化，不过是空间和时间转化的策略罢了，实战当中要平衡好RAM空间与运行时间的关系

首先得了解不同编译器的优化模式，以keil为例，优化等级分为-o0，-o1，-o2，-o3，额外独立配置：-Ospace，-Otime；

- -o0：不优化，优点是方便调试时变量查看，缺点是代码运行速度慢，占用内存大；（开发调试阶段）
- -o1：受限优化，平衡优化，优化不涉及“空间-时间”权衡，只进行优化如删除未使用的函数，变量；（测试优化阶段）
- -o2：高性能优化，执行包括指令调度在内的大量优化，包括展开小的循环，缺点是代码尺寸增加，变量可能被优化；（电机控制，数字信号处理，低端MCU）
- -o3：极致性能优化，在-o2基础上采取更激进策略（大量循环展开，更激进的函数内联），代码体积急速膨胀；（核心算法循环）
- -Ospace：偏向减小代码尺寸，比如-o2下选择不展开循环；（默认选项）
- -Otime：偏向提高运行速度，比如-o1下尝试内联小函数；

不同优化最容易出问题的地方：延迟类函数，for循环

keil中可以对不同文件夹设置不同优先级，这也是为什么要对架构进行设计，实战中可以试着逐步提高优化优先级，但有时候0级优化反而会出现问题



{% asset_img 0d7110db-b55b-4d7b-b978-51d18a3e3591.png  %}

- 总结：当使用for多重嵌套且最内层for只进行少量操作时，for本体就会占用大部分MCU周期频率，与内核指令流水线操作有关；（tip：需强化相关汇编知识）



{% asset_img 9ca4347e-2caa-42bf-83d1-5c88dabaf46f.png  %}

- 总结：缓存区域越大命中率越高（tip：有空做个实验）



{% asset_img 6a76902b-5689-4c96-8ba0-4cf1587d809d.png  %}

- 总结：对于需要频繁调用且函数内部操作少的情况，可以考虑内联



{% asset_img 99677660-3675-40bb-a099-d37b594d94f0.png  %}

- 总结：单独对函数设置优化等级操作



{% asset_img a7d4d9a5-3e54-4a56-a4a7-978dc52697f5.png  %}

- 总结：无法go to define的原因（如果是局部变量go to不到很正常）



{% asset_img e708b2c5-462b-4605-ad0f-6d783fd4492b.png  %}

- 总结：结构体成员对齐要看定义顺序，按成员大小降序排列可最小化填充！



**简化数据结构**：使用位域（bit-field）存储标志位，使用联合体（union）节省空间



**合理使用ITCM和DTCM也可以优化代码**

第一种方法：通过修改链接脚本的分配地址将中间件代码（RTOS调度算法，其他算法）分配到TCM上

第二种方法:

*// 在代码中* 

`__attribute__((section(".itcm_text"))) void critical_motor_control_loop(void) {    *// 这个函数会被编译到.itcm_text段*    *// ... 极其时间敏感的代码* }`



**NEON是ARM的SIMD技术，通过128位寄存器实现数据并行处理，显著提升多媒体、信号处理等场景的性能。**



**学习抢占优先级和响应优先级的设计架构**（有效地拓展了优先级个数却不占用代码运行时间）



