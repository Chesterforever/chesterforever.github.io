---
title: 一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器）
date: 2025-08-03 01:13:07
tags: [MCU]
index_img: /img/avatar.png

---

# 一篇文章讲明白代码编译，链接，烧录全过程（尽可能涵盖不同芯片和不同编译器）

## 引言

如果是科班出身的同学，那么应该学过代码从编译到烧录这一流程的原理，但是还有很多非科班并且初学stm32的同学应该都像我当时那样，觉得代码能跑就行，没必要了解这块方面的知识。事实上随着学习和实践的深入，有这一过程的清晰认知对于代码的调试，对于在脑子里搭建起整个嵌入式运行框架有非常大的作用。比如之后如果要看反汇编，那么肯定要对这个全过程有正确的理解。

其实我之前已经对这个全过程有自己的理解了，但记忆随着时间而丢失，导致现在又有点理不清了。所以我写这篇文章的目的，不仅仅是分享，也是一种再学习的过程（可以去搜一下费曼学习法）。

## 正文

首先先大致介绍一份代码文件在全过程下所需的各种子文件。

一份源代码文件通常包括

.c文件（C source文件，包含C语言编写的函数实现和程序逻辑，可被编译器编译为目标文件）

.h文件（header文件，包含函数声明，宏定义，类型定义等接口信息）

.s文件（汇编文件，包含汇编语言编写的低级代码，通常用于处理器启动，中断处理等底层操作）

.lib或.a文件(windows下为.lib,linux下为.a，涉及很多高级库玩法)

除了源代码文件外还需要有构建系统相关文件，比如

.ld文件或.sct文件（链接文件，控制链接过程的内存布局）

.mk文件或.cmake文件(makefile，构建系统的规则定义文件；cmake，CMake构建系统的配置文件)

### 编译

编译是将高级编程语言（如C、C++）转换为目标机器可理解的低级语言（汇编语言或机器代码）的过程。这个过程由编译器完成，主要包括以下阶段：

**预处理 → 编译 → 转成.o目标文件**

预处理：展开头文件（`#include`）宏替换（`#define`）条件编译（`#ifdef`, `#ifndef`等）

编译：将预处理的代码转换成汇编代码

| 编译器     | 支持架构               | 特点                     | 适用场景                |
| :--------- | :--------------------- | :----------------------- | :---------------------- |
| GCC        | x86, ARM, RISC-V, MIPS | 开源、跨平台             | 嵌入式Linux、通用嵌入式 |
| Clang/LLVM | x86, ARM, RISC-V       | 编译速度快、错误信息友好 | iOS/macOS开发、跨平台   |
| IAR        | ARM, RISC-V, 8051      | 商业级、优化好           | 工业控制、汽车电子      |
| Keil       | ARM Cortex-M           | 集成开发环境             | STM32开发               |
| Xtensa GCC | ESP32                  | 专用于Tensilica架构      | IoT设备                 |

这里着重介绍一下keil，keil针对不同类型的源文件会使用不同的工具处理，与GCC工具链有明显的区别

.c   →   armcc.exe     →   .o (目标文件)    

.s   →   armasm.exe    →   .o (目标文件)   

.lib/.a   ←   armar.exe    ←   多个.o文件

这些可以在keil IDE中魔术棒的target里面做配置，这里不详细展开

### 链接

链接器将多个目标文件（.o）和库文件（.lib）组合成单一的可执行文件(.axf或.elf或.out)，主要任务包括：

**地址分配**：为代码和数据分配具体的内存地址

**符号解析**：解决跨文件的函数和变量引用

**重定位**：根据实际地址调整指令中的地址引用

不同芯片架构需要不同的链接脚本配置,GCC工具链使用.ld文件，Keil MDK使用.sct文件。

**链接脚本的作用**

- [ ] 内存分配：定义Flash和RAM的地址范围
- [ ] 段(Section)布局：控制代码、数据在内存中的位置
- [ ] 符号处理：定义特殊符号（如堆栈起始地址）
- [ ] 启动配置：指定入口点和初始化顺序

> 如果想实现分散加载功能，就要自己写链接脚本
>
> 或者在多核系统下要对内存进行划分，或者带外部存储器时都要对链接脚本进行修改
>
> ai还提到了一种玩法：安全与非安全区域划分

链接过程最后得到的文件格式与使用工具链有关

| 文件格式 | 主要使用工具链 | 文件性质 | 典型扩展名 |
| :------- | :------------- | :------- | :--------- |
| ELF      | GNU工具链      | 标准格式 | .elf, .out |
| AXF      | Keil MDK       | 变种格式 | .axf       |
| OUT      | 传统Unix格式   | 遗留格式 | .out       |

这里还是以axf为例，可以通过工具将其转成.bin，.hex，可以提取出.map,调试时可以很方便地查看代码或某个变量的内存位置

### 烧录

烧录是将生成的可执行文件写入目标芯片的非易失性存储器（Flash）的过程。

##### 常见烧录接口

JTAG接口：

- 标准化的调试和编程接口
- 支持边界扫描测试
- 需要4-5根信号线（TMS, TCK, TDI, TDO, TRST）

SWD接口（Serial Wire Debug）：

- ARM架构专用，引脚更少（SWDIO, SWCLK）
- 适合引脚受限的Cortex-M系列

UART Bootloader：

- 通过串口进行固件更新
- 需要芯片内置bootloader支持
- 成本低，使用广泛



### 待更新部分

需要更新arduino或SOC工具链的全过程

需要更新交叉编译工具链

需要简单了解makefile写法